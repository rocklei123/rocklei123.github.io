<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AJAX跨域问题的全面解读]]></title>
    <url>%2F2019%2F09%2F05%2Fajax%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[1.简介通过本文了解是跨域问题，从系统最常见的部署结构上分析跨域解决的思路，详细讲解jsonp的工作机制，http协议如何支持跨域，以及http服务器nginx和apache的2种不同解决思路，让大家知其然并知其所以然，快速掌握问题本质和分析问题的方法。、 2.什么是跨域​ JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。那什么是跨域呢，简单地理解就是因为JavaScript同源策略的限制，a.com域名下的js无法操作b.com或是c.a.com域名下的对象。​ 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。 ​ 有一点必须要注意：跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 2.跨域产生的原因 浏览器限制。如果浏览器发现请求是跨域的时候，就会做校验，如果校验不通过就会报跨域的错误 发送的XHR(XMLHTTPRequest)请求。如果发送的不是xhr请求，无论是否跨域，浏览器都不会报错 只有这三种原因同时满足时，才会发生跨域 3.解决跨域的思路 浏览器角度。 让浏览器不做校验，浏览器的设置跨域，在浏览器的属性设置页面的目标输入框加上–disable-web-security。这样浏览器将不会去做校验了。但是每个人都需要去改动，==不建议使用。== 发送xhr请求角度。 让跨域的请求不发送xhr请求，就不会再报错了。办法是使用jsonp。 jsonp是非官方协议，是前后端的一种约定，前端使用ajax发送请求，dataType为jsonp，并且带一个参数（默认是callback），当后台发现这个参数之后，就知道这是一个jsonp请求，就会把原本返回json对象编程js返回，js代码是一个函数的执行，函数名是callback的参数值，函数的参数是原本的json对象。 jsonp缺点： 1）.只支持get方法请求； 2）.==需要服务器修改代码；==JSONP需要后台配合, 要有一个参数, 默认是?callback=JQuery1234567… JSONP返回的类型是:javascript, 而非json 3）.发送的不是XHR请求(这也是它可以跨域的原因),没有回调及事件的特性 在跨域角度。 1）.被调用方解决：在响应头增加指定字段，告诉浏览器，允许调用，这种方法的原理是从根源支持跨域的。 2）.调用方解决：这种解决办法原理是隐藏跨域。使用代理，在同一个域请求不同的url地址，转发到不同的域。 4.具体解决跨域问题的方法4.1 跨越问题的现象通过浏览器访问A项目，项目中打开的页面中将通过JavaScript代码访问B项目的地址。出现跨域问题。 A项目Javascript代码（调用方代码） 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;head&gt;&lt;script src="jquery-1.11.3.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" type="text/css" href="jasmine-2.8.0/jasmine.css"&gt;&lt;script src="jasmine-2.8.0/jasmine.js"&gt;&lt;/script&gt;&lt;script src="jasmine-2.8.0/jasmine-html.js"&gt;&lt;/script&gt;&lt;script src="jasmine-2.8.0/boot.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function get1() &#123; $.getJSON("http://localhost:8080/test/get1").then(function(result) &#123; console.log(result); &#125;); &#125; // 每一个测试用例的超时时间 jasmine.DEFAULT_TIMEOUT_INTERVAL = 1000; // 请求的接口的前缀 // http://localhost:8080/test //var base = "/ajaxserverapache"; var base = "http://localhost:8080/test"; //测试模块 describe("晓风轻-ajax跨越完全讲解", function() &#123; // 测试方法 it("get1请求", function(done) &#123; // 服务器返回的结果 var result; $.getJSON(base + "/get1").then(function(jsonObj) &#123; result = jsonObj; &#125;); // 由于是异步请求，需要使用setTimeout来校验 setTimeout(function() &#123; expect(result).toEqual(&#123; "data" : "get1 ok" &#125;); // 校验完成，通知jasmine框架 done(); &#125;, 100); &#125;); 正常访问，服务端返回响应码为200，但是页面会报错。 浏览器的Console中会打印报错信息： 4.2 基于Jsonp 解决4.2.1 前端代码改动​ 在发送ajax请求的时候，设置dataType为jsonp，即告诉后台我需要返回的是script代码，而不是一个json格式的数据。同时==jsonp：“callback”（默认）==，但是可以修改为jsonp：“callback2”这个就是前后台的协议，即后台返回的script的方法的名称，然后后台将原本的json放在该方法的参数中返回给前端，故服务端代码应该也以相同名称返回。 12345678910111213// 测试方法 it("jsonp请求", function(done) &#123; // 服务器返回的结果 var result; $.ajax(&#123; url: base +"/get1", dataType: "jsonp", jsonp: "callback2", cache:true, success: function(json)&#123; result = json; &#125; &#125;); 此时会发生两种变化： 1请求的地址发生改变 2发起请求的类型不在为xhr，而是script。返回的数据类型也为 application/javascript 4.2.2 服务端代码改动服务端需要新增@ControllerAdvice 修饰的方法。默认请求的传递参数为 callback。如果客户端javascript代码中以jsonp：“callback2”访问服务端，服务端也应该以callback2 相同的字符串返回。 12345678910import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.AbstractJsonpResponseBodyAdvice;@ControllerAdvicepublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice &#123; public JsonpAdvice() &#123; super("callback2"); &#125;&#125; 返回内容为javascript内容： 4.2.3 核心原理引入jquery非压缩的js库，可以在浏览器查看JQuery实现jsonp的时候是动态创建异步javascript的代码。 在浏览器查看jsonp请求里除了callback参数外，还有一个名为下划线“_”的参数，值为一串随机数。此参数作用是防止请求被缓存。如果你的请求可以被缓存的话，可以在请求里使用cache:true。 4.3 常见的JAVAEE 架构中的解决跨域问题的方案4.3.1 跨域解决方向 被调用方解决 调用方解决 4.3.2 被调用方解决-支持跨域根据http协议关于跨域方面的要求，增加响应头信息，告诉浏览器允许被跨域调用 4.3.2.1 使用filter解决 res.addHeader(“Access-Control-Allow-Origin”, “http://localhost:8081&quot;); //设置允许http://localhost:8081域访问，*表示所有域都能访问 res.addHeader(“Access-Control-Allow-Methods”, “GET”);//设置允许GET方法访问，*表示所有方法 4.3.2.1.2 简单请求与与非简单请求 简单请求：先执行后判断 非简单请求：当浏览器要发送跨域请求时，如果请求是复杂请求，浏览器会先发送一个options预检命令即一个options请求，当该请求通过时才会再发送真正的请求。 两种请求的区分： 如下为非简单请求 该option请求会根据请求的信息去询问服务端支不支持该请求。比如发送的数据是json类型（通过content-type设置）的话，会携带一个请求头Access-Control-Request-Headers: content-type去询问支不支持该数据类型，如果支持，则请求就会通过，并发送真正的请求。 4.3.2.1.3 非简单请求跨域基于Filter解决办法123456789101112131415161718@SpringBootApplicationpublic class AjaxserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AjaxserverApplication.class, args); &#125; @Bean public FilterRegistrationBean registerFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.addUrlPatterns("/*"); bean.setFilter(new CrosFilter()); return bean ; &#125;&#125; 自定义Filter（同时解决带cookie的跨域、以及自定义请求头） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.tomcat.util.buf.StringUtils;public class CrosFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub HttpServletResponse res = (HttpServletResponse) response; HttpServletRequest req = (HttpServletRequest) request; String origin = req.getHeader("Origin"); if (!org.springframework.util.StringUtils.isEmpty(origin)) &#123; //带cookie的时候，origin必须是全匹配，不能使用* res.addHeader("Access-Control-Allow-Origin", origin); &#125; res.addHeader("Access-Control-Allow-Methods", "*"); String headers = req.getHeader("Access-Control-Request-Headers"); // 支持所有自定义头 if (!org.springframework.util.StringUtils.isEmpty(headers)) &#123; res.addHeader("Access-Control-Allow-Headers", headers); &#125; res.addHeader("Access-Control-Max-Age", "3600"); // enable cookie res.addHeader("Access-Control-Allow-Credentials", "true"); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125;&#125; 4.3.2.2 nginx解决方案在被调用方的代理服务器nginx 上增加请求头信息 4.3.2.3 APACHE解决方案、在被调用方的代理服务器apache上增加请求头信息 4.3.2.4 Spring解决方案在Controller层增加@CrossOrigin注解即可 4.3.3. 调用方使用代理做调用解决跨域问题-隐藏跨域4.3.3.1 基于nginx使用反向代理反向代理：访问同一个域名的两个url，会去到两个不同的服务器. javascript代码中的ajax请求地址也应该为相对地址 4.3.3.2 基于apache使用反向代理 5.参考慕课网 https://www.imooc.com/learn/947 6.欢迎关注米宝窝，持续更新中，谢谢！ [米宝窝 https://rocklei123.github.io/ ](https://rocklei123.github.io/）]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC拦截器及与过滤器对比]]></title>
    <url>%2F2019%2F09%2F02%2FSpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8F%8A%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[1 简介 拦截器是Spring MVC中一个十分重要且应用广泛的内容。通过乱码问题的解决引入Spring MVC拦截器的使用，介绍了拦截器的工作原理、实现方法和使用场景，最后介绍了拦截器与过滤器的区别。以及当多个拦截器多个过滤器使用时，他们的调用顺序。 2 Spring MVC拦截器的实现2.1. 什么是拦截器 使用场景：解决请求的共性问题，如：乱码问题、权限验证问题等 2.2. 拦截器工作原理拦截器（Interceptor）： 它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。 在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用。 由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。 2.3. 拦截器的实现实现SpringMVC拦截器的三个步骤 创建一个实现HandlerInterceptor接口，并实现接口的方法的类 12345678910111213141516171819package org.springframework.web.servlet.handler; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; public abstract class HandlerInterceptorAdapter implements HandlerInterceptor&#123; // 在业务处理器处理请求之前被调用 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception&#123; return true; &#125; // 在业务处理器处理请求完成之后，生成视图之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception&#123; &#125; // 在DispatcherServlet完全处理完请求之后被调用，可用于清理资源 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception&#123; &#125; &#125; 将创建的拦截器注册到SpringMVC的配置文件中实现注册 123&lt;mvc：interceptors&gt; &lt;bean class=" 路径下的类"&gt;&lt;/mvc：interceptors&gt; 配置拦截器的拦截规则： 123456&lt;mvc：interceptors&gt;&lt;mvc：interceptor&gt; &lt;mvc:mapping path="拦截的action"&gt; &lt;bean class="路径下的类"&gt;&lt;/mvc：interceptor&gt;&lt;/mvc：interceptors&gt; 2.4. 拦截器方法介绍 preHandle()方法是否将当前请求拦截下来。 返回true请求继续运行 返回false请求终止（包括action层也会终止） Object arg代表被拦截的目标对象。） postHandle()方法（ModelAndView对象可以改变发往的视图或修改发往视图的信息。） afterCompletion()方法表示视图显示之后在执行该方法。（一般用于资源的销毁，如关闭IO流） 2.5. 多个拦截器应用配置文件做如下配置： 多个拦截器执行顺序： Request–&gt;interceptor1.preHandle()–&gt;interceptor2.preHandle()–&gt;Controller–&gt;interceptor2.postHandle()–&gt;interceptor1.postHandle()–&gt;interceptor2.afterCompletion()–&gt;interceptor1.afterCompletion()–&gt;Response 2.6. 拦截器的其它实现方式 拦截器的类还可以通过实现WebRequestInterceptor（HandlerInterceptor）接口来编写 向SpringMVC框架注册的写法不变 弊端：preHandler方法没有返回值，不能终止请求 建议使用功能更强大的实现方式，实现HandlerInterceptor接口。 123456789101112131415161718192021222324252627282930313233343536373839404142import org.springframework.ui.ModelMap; import org.springframework.web.context.request.WebRequest; import org.springframework.web.context.request.WebRequestInterceptor; public class AllInterceptor implements WebRequestInterceptor &#123; /** * 在请求处理之前执行，该方法主要是用于准备资源数据的，然后可以把它们当做请求属性放到WebRequest中 */ @Override public void preHandle(WebRequest request) throws Exception &#123; // TODO Auto-generated method stub System.out.println("AllInterceptor..............................."); request.setAttribute("request", "request", WebRequest.SCOPE_REQUEST);//这个是放到request范围内的，所以只能在当前请求中的request中获取到 request.setAttribute("session", "session", WebRequest.SCOPE_SESSION);//这个是放到session范围内的，如果环境允许的话它只能在局部的隔离的会话中访问，否则就是在普通的当前会话中可以访问 request.setAttribute("globalSession", "globalSession", WebRequest.SCOPE_GLOBAL_SESSION);//如果环境允许的话，它能在全局共享的会话中访问，否则就是在普通的当前会话中访问 &#125; /** * 该方法将在Controller执行之后，返回视图之前执行，ModelMap表示请求Controller处理之后返回的Model对象，所以可以在 * 这个方法中修改ModelMap的属性，从而达到改变返回的模型的效果。 */ @Override public void postHandle(WebRequest request, ModelMap map) throws Exception &#123; // TODO Auto-generated method stub for (String key:map.keySet()) System.out.println(key + "-------------------------");; map.put("name3", "value3"); map.put("name1", "name1"); &#125; /** * 该方法将在整个请求完成之后，也就是说在视图渲染之后进行调用，主要用于进行一些资源的释放 */ @Override public void afterCompletion(WebRequest request, Exception exception) throws Exception &#123; // TODO Auto-generated method stub System.out.println(exception + "-=-=--=--=-=-=-=-=-=-=-=-==-=--=-=-=-="); &#125; &#125; 2.7 拦截器与过滤器区别拦截器和过滤器 拦截器是基于java的反射机制的，而过滤器是基于函数回调。 拦截器不依赖与servlet容器，过滤器依赖与servlet容器。 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调 拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。 2.8 多过滤器多拦截器共同使用时的顺序下面在一个项目中我们使用既有多个过滤器，又有多个拦截器，并观察它们的执行顺序：（1）第一个过滤器：12345678910public class TestFilter1 extends Filter &#123; @Override protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //在DispatcherServlet之前执行 System.out.println("############TestFilter1 doFilterInternal executed############"); filterChain.doFilter(request, response); //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后 System.out.println("############TestFilter1 doFilter after############"); &#125; &#125; （2）第二个过滤器：12345678910public class TestFilter2 extends Filter &#123; @Overrideprotected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //在DispatcherServlet之前执行 System.out.println("############TestFilter2 doFilterInternal executed############"); filterChain.doFilter(request, response); //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后 System.out.println("############TestFilter2 doFilter after############"); &#125; &#125; （3）在web.xml中注册这两个过滤器： 123456789101112131415161718&lt;!-- 自定义过滤器：testFilter1 --&gt; &lt;filter&gt; &lt;filter-name&gt;testFilter1&lt;/filter-name&gt; &lt;filter-class&gt;com.scorpios.filter.TestFilter1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;testFilter1&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 自定义过滤器：testFilter2 --&gt; &lt;filter&gt; &lt;filter-name&gt;testFilter2&lt;/filter-name&gt; &lt;filter-class&gt;com.scorpios.filter.TestFilter2&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;testFilter2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 再定义两个拦截器：（4）第一个拦截器： 123456789101112131415161718192021222324252627public class BaseInterceptor implements HandlerInterceptor&#123; /** * 在DispatcherServlet之前执行 * */ public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; System.out.println("************BaseInterceptor preHandle executed**********"); return true; &#125; /** * 在controller执行之后的DispatcherServlet之后执行 * */ public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println("************BaseInterceptor postHandle executed**********"); &#125; /** * 在页面渲染完成返回给客户端之前执行 * */ public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; System.out.println("************BaseInterceptor afterCompletion executed**********"); &#125; &#125; （5）第二个拦截器： 1234567891011121314public class TestInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; System.out.println("************TestInterceptor preHandle executed**********"); return true; &#125; public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println("************TestInterceptor postHandle executed**********"); &#125; public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; System.out.println("************TestInterceptor afterCompletion executed**********"); &#125; &#125; （6）、在SpringMVC的配置文件中，加上拦截器的配置： 123456789101112&lt;!-- 拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 对所有请求都拦截，公共拦截器可以有多个 --&gt; &lt;bean name="baseInterceptor" class="com.scorpios.interceptor.BaseInterceptor" /&gt; &lt;mvc:interceptor&gt; &lt;!-- 对/test.html进行拦截 --&gt; &lt;mvc:mapping path="/test.html"/&gt; &lt;!-- 特定请求的拦截器只能有一个 --&gt; &lt;bean class="com.scorpios.interceptor.TestInterceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; （7）、定义一个Controller控制器： 12345678910111213package com.scorpios.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class TestController &#123; @RequestMapping("/test") public ModelAndView handleRequest()&#123; System.out.println("---------TestController executed--------"); return new ModelAndView("test"); &#125; &#125; （8）、测试结果：启动测试项目，地址如下：http://localhost:8080/demo，可以看到控制台中输出如下： 这就说明了过滤器的运行是依赖于servlet容器，跟springmvc等框架并没有关系。并且，多个过滤器的执行顺序跟xml文件中定义的先后关系有关。 接着清空控制台，并访问：http://localhost:8080/demo/test，再次看控制台的输出： 从这个控制台打印输出，就可以很清晰地看到有多个拦截器和过滤器存在时的整个执行顺序了。当然，对于多个拦截器它们之间的执行顺序跟在SpringMVC的配置文件中定义的先后顺序有关。 总结对于上述过滤器和拦截器的测试，可以得到如下结论：（1）、Filter需要在web.xml中配置，依赖于Servlet；（2）、Interceptor需要在SpringMVC中配置，依赖于框架；（3）、Filter的执行顺序在Interceptor之前，具体的流程见下图； 3 部分内容转载或参考 慕课网Spring MVC拦截器 转载本文：拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别 Java过滤器与SpringMVC拦截器之间的关系与区别 4.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix基于snmp协议监控weblogic]]></title>
    <url>%2F2019%2F07%2F01%2Fzabbix%E5%9F%BA%E4%BA%8Esnmp%E5%8D%8F%E8%AE%AE%E7%9B%91%E6%8E%A7weblogic%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[本主题为通过zabbix监控中间件（基于snmp协议）。 zabbix相关介绍​ 本文档讲述的是关于zabbix基于snmp协议监控weblogic相关实现。 ​ 这里首先我们要知道要使用zabbix进行监控，至少需要他的两个部分来实现组成。 ​ 第一部分是在服务端需要部署的zabbix_server，这个程序是部署在LAMP的相关环境下的，后续会有相关文档进行对于zabbix_server安装的说明，这里就不多做赘述了。 ​ 第二部分是在客户端需要部署的zabbix_agent，这个程序是不需要相关的运行环境，只需要在客户端进行相关的配置，以及安装就可以了。 zabbix_agent端的部署​ 首先登录到被监控端Linux 服务器上，安装zabbix agent ，过程不在本文档赘述（本人环境使用rpm包安装）。安装位置在 /etc/zabbix/zabbix_agentd.conf。编辑 /etc/zabbix/zabbix_agentd.conf配置如下几项： 123456PidFile=/var/run/zabbix/zabbix_agentd.pidLogFile=/var/log/zabbix/zabbix_agentd.log 日志位置Server=127.0.0.1 服务器端IPListenPort=10050ServerActive=127.0.0.1 服务器端IPHostname=127.0.0.1 (监控目标端主机名称) 这里配置的是主机名称，这个名称必须与zabbix_server配置的主机名称是一致的。 查看状态、停止、启动相关命令 12345678910111213源码包安装的agent启动：./zabbix_agentd -c /wetc/zabbix/conf/zabbix_agentd.confrpm包安装的agent：Centos6 或者redhat6 chkconfig --list 查看服务名称 service zabbix-agent status service zabbix-agent stop service zabbix-agent startCentOs7 或者Redhat7 systemctl stop zabbix-agent.service systemctl start zabbix-agent.service systemctl status zabbix-agent.service 之后我们可以查看相关的日志文件，也就是zabbix_agentd.log文件中的内容，来查看程序的启动情况。 /var/log/zabbix/zabbix_agentd.log 可能出现的问题 当我们启动agent时，可能日志中会报出如下错误： 这是因为在server端没有配置相应名称的hostname所导致的。 被监控端Weblogic设置我们监控服务器时，需要经过相关的SNMP协议来对服务器进行监控，这里我们需要在控制台上进行相关的配置。 首先我们登录相关的控制台： 会在页面中看到如下内容，点击新建 这里面输入需要创建的SNMP相关的名称，这里请遵循相应的命名规则来进行命名。 之后点入新创建的SNMP进行相关内容的配置 这里先输入 SNMP UDP端口 这里我输入的为8098，后输入主要AgentX端口 同样为8098这里的端口号，请遵循创建时的相应规则。陷阱版本选择V1 将ServerSNMPAgent部署到目标节点上。选择启用后，进行保存，并点击标签中的目标项。 目标项中选择SNMP协议相对应的端点，来进行目标的指向，当所有的节点SNMP均配置完成后，于控制台的配置基本完成。 测试访问联通性确保Weblogic监听SNMP以上配置完成后，需要重启Weblogic节点，查看Weblogic节点启动日志，会出现如下信息，表示Weblogic配置完成，并且已经监听SNMP端口。 测试工具测试安装测试工具snmpwalk1yum -y install net-snmp-utils 测试srv_13_22_7003 节点 ExecuteThreadTotalCount1snmpwalk -v 1 -c public 210.72.13.22:8098 1.3.6.1.4.1.140.625.367.1.25.16.35.6.159.237.53.118.39.151.17.79.45.166.52.193.171.147 测试srv_13_22_7003 节点 ExecuteThreadTotalCount，如果执行成功出现如下信息表示Weblogic SNMP 配置成功： 1SNMPv2-SMI::enterprises.140.625.367.1.25.16.35.6.159.237.53.118.39.151.17.79.45.166.52.193.171.147 = INTEGER: 6 zabbix_server页面相关配置主机的创建基本的准备工作完成之后，我们需要登录zabbix_server控制台进行主机监控项的配置 进入登录页面点击Configuration –&gt; Hosts –&gt; Create host进行主机的创建。 输入Host name ,这里再次强调Host name的内容需要与agent端配置文件中的Host name内容一致 Agent interface中输入需要监控的服务器IP地址，并输入相应的监控端口，这里的端口与zabbix_agentd.conf中配置的一致，这里我并有进行配置，只是用了默认的10050，如果有需要可以修改文件中的变量Listen Port进行相关配置。 点击Add，基本的主机便建立完成了 返回到Hosts页面 发现新建的主机 之后点进去进行相关的配置操作。 SNMP配置这里进行的SNMP配置与控制台的SNMP配置相对应，ip为被监控主机地址，而端口则为控制台所配置的UDP端口。 例如：第一个UDP端口为8098，所以这里相对应的端口号也为8098。 监控项的配置于相应主机栏中，选择items,点击进入 Name：首先输入Name,这里的Name为需要监控的内容名称，可以自己决定取名，但最好遵循相应的规则，这里我选择监控队列数，因为监控的是第一台服务器的第一个节点，所以这里的name我命名为7003-QueueLength Type选择SNMPv1 agent 这里的类型和控制台所配置的陷阱版本是相对应的。 key 和SNMP OID 相同，通过MIB 浏览器来获得： 1queueLength 1.3.6.1.4.1.140.625.367.1.35.16.35.6.159.237.53.118.39.151.17.79.45.166.52.193.171.147 OID 信息可以通过如下命令输出到文件中查询 1snmpwalk -v 1 -c public 210.72.13.22:8098 1.3.6.1.4.1.140.625 &gt; weblogic_oid.txt 在进入监控项页面点击创建监控项，并填入相关内容： OID的获取WebLogic 所有 OID 信息查询1snmpwalk -v 1 -c public 210.72.13.22:8098 1.3.6.1.4.1.140.625 &gt; weblogic_oid.txt WebLogic SNMP Management Guide请参考 https://docs.oracle.com/cd/E13222_01/wls/docs90/snmpman/snmpagent.html 在线版本WebLogic Server® 9.0 MIB Reference https://docs.oracle.com/cd/E13222_01/wls/docs90/snmp/index.html 离线版本WebLogic Server® 9.0 MIB Reference 123456[root@localhost lib]# ls -l *.asn1-rwxr-x--- 1 tomcat tomcat 1879180 Aug 23 14:11 BEA-WEBLOGIC-MIB.asn1[root@localhost lib]# [root@localhost lib]# pwd/home/tomcat/Oracle/Middleware/wlserver_10.3/server/lib[root@localhost lib]# 离线版查看工具：MIB Browser http://ireasoning.com/downloadmibbrowserfree.php 离线MIB Browser的使用运行MIB Browser setup.exe 在安装时按正常顺序安装就可以了，安装好后双击进入MIB Browser 点击File –&gt; Load MIBs 加载BEA-WEBLOGIC-MIB.asn1文件，即可开始使用。 在图中Address位置，输入服务器的ip地址和UDP端口，点击Advanced,连接到相关地址。 查找相关的关键字，例如这里查找QueueLength 选中查找到的内容 会于页面左边显示相应的内容，此时我们就获得了相应的OID了 验证Zabbix与目标主机SNMP连通性zabbix控制台-&gt;目标主机-&gt;监控项 显示已启用为正常 如果被监控主机SNMP选项出现红色，表示该连接有问题，建议查看具体的日志： 欢迎关注米宝窝，持续更新中，谢谢！[米宝窝 https://rocklei123.github.io/ ](]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
        <tag>SNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix基于JMX监控中间件]]></title>
    <url>%2F2019%2F07%2F01%2FZabbix%E5%9F%BA%E4%BA%8EJMX%E7%9B%91%E6%8E%A7%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本主题为通过zabbix监控中间件。 Zabbix 基于JMX agent(zabbix-java-gateway) 获取JVM MBean 信息。 Zabbix Agent安装注意：如果您希望监控目标主机的操作系统相关指标，如CPU、内存、文件系统等信息，那么需要在目标主机安装 zabbix agent。 rpm包安装方式1rpm -ivh zabbix-agent-4.0.0-1.1rc2.el7.x86_64 源码包安装后打tar包介质–解压安装agent12cd /usr/localtar -xvf zabbix_agent.tar.gz Zabbix Agent配置rpm安装配置rpm安装方式配置文件路径为/etc/zabbix/zabbix_agentd.conf 1234LogFile=/tmp/zabbix_agentd.log #日志文件路径Server=192.168.100.1 #zabbix server 服务端地址ServerActive=192.168.100.1 #zabbix server 服务端地址Hostname=192.168.100.104 #被监控端主机ip 源码包安装后打tar包介质–配置配置源码包安装后打tar包介质-安装方式配置文件路径在解压目录，如:/usr/local/zabbix_agent/etc/zabbix_agentd.conf 1234LogFile=/tmp/zabbix_agentd.log #日志文件路径Server=192.168.100.1 #zabbix server 服务端地址ServerActive=192.168.100.1 #zabbix server 服务端地址Hostname=192.168.100.104 #被监控端主机ip 添加为服务与启停服务脚本12cd /etc/init.d/ vi zabbix_agentd 脚本内容为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/sh# chkconfig: 2345 10 90 # description: myservice ....# Zabbix# Copyright (C) 2001-2018 Zabbix SIA## This program is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation; either version 2 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program; if not, write to the Free Software# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.# Start/Stop the Zabbix agent daemon.# Place a startup script in /sbin/init.d, and link to it from /sbin/rc[023].d SERVICE="Zabbix agent"DAEMON=/usr/local/zabbix_agent/sbin/zabbix_agentd PIDFILE=/tmp/zabbix_agentd.pidcase $1 in 'start') if [ -x $&#123;DAEMON&#125; ] then $DAEMON # Error checking here would be good... echo "$&#123;SERVICE&#125; started." else echo "Can't find file $&#123;DAEMON&#125;." echo "$&#123;SERVICE&#125; NOT started." fi ;; 'stop') if [ -s $&#123;PIDFILE&#125; ] then if kill `cat $&#123;PIDFILE&#125;` &gt;/dev/null 2&gt;&amp;1 then echo "$&#123;SERVICE&#125; terminated." rm -f $&#123;PIDFILE&#125; fi fi ;; 'restart') $0 stop sleep 10 $0 start ;; *) echo "Usage: $0 start|stop|restart" ;;esac 添加命令 123chmod u+x zabbix_agentd chkconfig --add zabbix_agentdchkconfig zabbix_agentd on 启停命令 123/etc/init.d/zabbix_agentd start/etc/init.d/zabbix_agentd stop/etc/init.d/zabbix_agentd restart Zabbix 服务端配置请确保zabbix server已经配置java gateway,如果您已经配置，可略过此步骤。 配置文件配置配置zabbix_java_gateway.confvi /etc/zabbix/zabbix_java_gateway.conf 12345LISTEN_IP=&quot;0.0.0.0&quot;LISTEN_PORT=10052PID_FILE=&quot;/var/run/zabbix/zabbix_java.pid&quot;START_POLLERS=5TIMEOUT=3 配置完成后就可以启动zabbix-server 和 zabbix-java-gateway 12systemctl start zabbix-server.servicesystemctl start zabbix-java-gateway.service 配置zabbix/zabbix_server.conf修改zabbix-server的配置，编辑/etc/zabbix/zabbix_server.conf ，修改下面几个参数： 123456JavaGateway的服务器IP地址，一般与zabbix server同一台主机，可直接写zabbix server地址JavaGateway=XXX.XXX.XXX.XXXJavaGateway的服务端口JavaGatewayPort=10052从javaGateway采集数据的进程数StartJavaPollers=5 配置文件修改后，重启zabbix-server： 1systemctl restart zabbix-server.service 被监控端JVM开启JMX使用JMX前需要先开启JMX，默认是关闭的，在启动JAVA程序时,如何开始请参考官方文档https://docs.oracle.com/javase/1.5.0/docs/guide/management/agent.html 下面介绍几种常用中间件JMX开启方式： TomcatLinuxTomcat 编辑TOMCAT_HOME/bin/catalina.sh 在开头加入如下几行 123456CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Djava.rmi.server.hostname=JMX_HOST" # 修改 JMX_HOSTCATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Djavax.management.builder.initial=" CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote=true" CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote.port=JMX_PORT" # 修改JMS PORTCATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote.ssl=false" CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote.authenticate=false" 注意：JMX_HOST为tomcat的主机名或IP地址，JMX_PORT为JMX端口，通常使用12345，然后重启tomcat，JMX就开启了。 Windows123456set CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Djava.rmi.server.hostname=127.0.0.1"set CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Djavax.management.builder.initial=" set CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote=true" set CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote.port=12345"set CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote.ssl=false"set CATALINA_OPTS="$&#123;CATALINA_OPTS&#125; -Dcom.sun.management.jmxremote.authenticate=false" WeblogicWeblogic 编辑WL_DOMAIN_HOME/bin/setDomainEnv.cmd，在文件结尾加入下面几行 123456JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Djava.rmi.server.hostname=JMX_HOST"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Djavax.management.builder.initial=weblogic.management.jmx.mbeanserver.WLSMBeanServerBuilder"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote=true"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote.port=JMX_PORT"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote.ssl=false"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote.authenticate=false" 本地环境配置示例： 123456JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote=true" JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Djava.rmi.server.hostname=192.168.100.1"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote.port=12345"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote.ssl=false"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Dcom.sun.management.jmxremote.authenticate=false"JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Djavax.management.builder.initial=weblogic.management.jmx.mbeanserver.WLSMBeanServerBuilder" IBM WebSphere进入WebSphere Administrative Console open Servers → Server Types → WebSphere application servers → WAS_SERVER_NAME → Java and Process Management → Process definition → Java Virtual Machine. 在“Generic JVM arguments”增加下面环境变量： 1-Djavax.management.builder.initial= 然后再进入 WebSphere Administrative Console, open Servers → Server Types → WebSphere application servers → WAS_SERVER_NAME → Java and Process Management → Process definition → Java Virtual Machine → Custom properties. 增加下面几个环境变量： 123456789101112Name: java.rmi.server.hostnameValue: JMX_HOSTName: javax.management.builder.initialValue: noneName: com.sun.management.jmxremoteValue: trueName: com.sun.management.jmxremote.portValue: JMX_PORTName: com.sun.management.jmxremote.sslValue: falseName: com.sun.management.jmxremote.authenticateValue: false 应用更改，重启应用就开启了。 Oracle GlassFish进入GlassFish Console, open GAS_CONFIG → JVM Settings → JVM Options.加入下面的环境变量到“JVM options”: 12345Value: -Djava.rmi.server.hostname=JMX_HOSTValue: -Dcom.sun.management.jmxremote=trueValue: -Dcom.sun.management.jmxremote.port=JMX_PORTValue: -Dcom.sun.management.jmxremote.ssl=falseValue: -Dcom.sun.management.jmxremote.authenticate=false 重启就开启了。 JMX相关参数注意事项-Djava.rmi.server.hostname=JMX_HOST 在多网卡主机上，启动weblogic,建议增加-Djava.rmi.server.hostname=JMX_HOST参数，-Djava.rmi.server.hostname= 被监控端Weblogic使用的网卡IP。否则使用jconsole或JRMC、jvisual工具连接时，会报出RMI(java.net.ConnectException: Connection refused: connect错误。 测试和查看JMX的配置和状态信息基于jmxcmd.jar命令行方式测试命令行参数建议使用jmxcmd.jar，下载地址如下： https://sourceforge.net/projects/jmxcmd/ 12345678910111213141516171819[tomcat@localhost tmp]$ java -jar jmxcmd.jar - 192.168.100.1:8098 &gt; weblogic_mebean.txt查看所有mbean[tomcat@localhost tmp]$ java -jar jmxcmd.jar - 192.168.100.1:8098 java.lang:type=Memory NonHeapMemoryUsage01/09/2019 10:46:18 +0800 de.layereight.jmxcmd.Client NonHeapMemoryUsage: committed: 271056896init: 270991360max: 587202560used: 92159504查看非堆内存[tomcat@localhost tmp]$ [tomcat@localhost tmp]$ java -jar jmxcmd.jar - 192.168.100.1:8098 com.bea:Name=ThreadPoolRuntime,ServerRuntime=srv_13_22_7003,Type=ThreadPoolRuntime QueueLength01/09/2019 10:28:10 +0800 de.layereight.jmxcmd.Client QueueLength: 0[tomcat@localhost tmp]$ 查看srv_13_22_7003 的线程池队列长度[tomcat@localhost tmp]$ java -jar jmxcmd.jar - 192.168.100.1:8098 com.bea:Name=ThreadPoolRuntime,ServerRuntime=srv_13_22_7003,Type=ThreadPoolRuntime HoggingThreadCount01/09/2019 10:42:36 +0800 de.layereight.jmxcmd.Client HoggingThreadCount: 0[tomcat@localhost tmp]$ 查看srv_13_22_7003 的线程池Hogging线程数 基于Jconsole测试 Jconsole查看 基于JRMC测试 JRMC查看 MbeanWeblogic Mbean在线文档：WebLogic Server® MBean Reference https://docs.oracle.com/middleware/11119/wls/WLMBR/core/index.html Tomcat Mbean在线文档 http://tomcat.apache.org/tomcat-7.0-doc/monitoring.html 同一主机上监控多个Java进程Key健冲突问题生产环境中我们经常使用同一台主机来搭建多个Tomcat或Weblogic节点对外提供服务，可是在监控主机时会碰到这样的问题，在被监控主机上使用模板，只能监控其中一个，如果想监控多个实例，我们只能通过添加多个模板来实现。这里提供两种解决方案： 对每个JVM进程当做一台主机在zabbix 中建立两台主机，jmx接口不同。 缺点，主机监控数据 tomcat1: tomcat2: 使用空格防止Key健冲突在同一主机上，zabbix不允键值重复，但是监控的项目是一样的，不可能键值写的不重复，经过几番搜索，找到方法如下： 只要在箭头处添加1个空格就可以，也可以是多个。（注意位置不要错，在逗到后面） 错误方式： 欢迎关注米宝窝，持续更新中，谢谢！[米宝窝 https://rocklei123.github.io/ ](]]></content>
      <categories>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
        <tag>JMX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSphere Application Server 调优]]></title>
    <url>%2F2019%2F07%2F01%2FWebSphere%20Application%20Server%20%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[WebSphere Application Server 调优（base on Was 8.5.5）作者：周磊，rocklei123.北京 2019.1.10 WebSphere 性能优化概述性能问题发生在 WAS 和操作系统的各个环节中性能问题可能发生于系统的各个环节中，当性能问题出来后很难马上就定位性能的瓶颈在哪里，即使找到了性能瓶颈，在进行调优的时候也要考虑系统整体环境，从上下文中分析，确定调优的策略；系统中一个或者多个“短板”的存在，就能让系统无法达到设计时的目标，无法达到预期的性能提升。 调优前需要知道的 调优是一个持续的过程 调优需要有工具和数据的支撑 漏斗原则 绘制吞吐率曲线 WAS 性能调优没有捷径和魔术，因为每一个应用都有自己独特的特性和资源需求，而且他们使用 WAS 的资源也有各种不同的方式，每一套调优的参数和策略仅适用于当前的系统环境，在实际的系统环境中不能简单的将一种调优策略原封不动的移植到另外一个系统环境中，这样往往得不到预期的调优目的，还可能照成更多的性能瓶颈。 WAS 性能差的几种表现及解决方法系统性能差一般有以下两种非常明显的表现形式 第一种是 CPU 使用不高，用户感觉交易响应时间很长； 可以断定是由于系统的某一小部分造成了瓶颈，导致了所有的请求都在等待。 第二种是 CPU 使用很高，用户感觉交易响应时间很长。 比较复杂。可能的根源之一是硬件资源不够。根源之二是应用系统中产生了多个大对象。根源之三是程序算法有问题。 推荐WebSphere 官方调优文档WebSphere Application Server 调优：建议官方查看调整完整概要文件 https://www.ibm.com/support/knowledgecenter/zh/SSEQTP_8.5.5/com.ibm.websphere.base.doc/ae/tfullp_tun.html 检查硬件配置和设置 优化磁盘速度 提高处理器速度和增大处理器高速缓存 增大系统内存 使网卡和网络交换机以全双工方式工作 调整操作系统 调整 Windows 系统 调整 Linux 系统 调整 AIX 系统 调整 Solaris 系统 调整 HP 系统 调整 Linux 系统根据调整需求，配置下列设置和变量： 更改 TCP 参数 描述： Linux 提供了许多可调 TCP 参数，其缺省值对于 WebSphere Application Server 来说可能就足够了。在某些例外情况下，可能必须调整这些参数。例如，您可能会减少特定状态（例如，TIME_WAIT）下套接字的数目、修改 TCP 保持活动操作或者修改其他功能。 如何查看或设置： 请查阅 Linux 分发中“man tcp”下提供的详细信息。 Linux 文件描述符 (ulimit) 描述：指定支持打开的文件数。通常，缺省设置适合于大多数应用程序。 如果将此参数值设置得太小，那么可能会显示文件打开错误、内存分配故障或连接建立错误。 如何查看或设置：请参阅有关 ulimit 命令的 UNIX 参考页面以了解不同 shell 的语法。对于 KornShell shell (ksh) 程序，要将 ulimit 命令设置为 8000，请发出 ulimit -n 8000 命令。使用 ulimit -a 命令来显示所有系统资源限制的当前值。 缺省值：对于 SUSE Linux Enterprise Server 9 (SLES 9)，缺省值是 1024。 建议值：8000 连接储备 描述： 当由于入局连接请求比率过高而导致连接故障时，请更改下列参数： 12echo 3000 &gt; /proc/sys/net/core/netdev_max_backlogecho 3000 &gt; /proc/sys/net/core/somaxconn TCP_KEEPALIVE_INTERVAL 描述：确定两次 isAlive 时间间隔探测之间的等待时间。 如何查看或设置： 发出以下命令来设置此值： 1echo 15 &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl 缺省值：75 秒 建议值：15 秒 TCP_KEEPALIVE_PROBES 描述：确定超时前的探测次数。 如何查看或设置： 发出以下命令来设置此值： 1echo 5 &gt; /proc/sys/net/ipv4/tcp_keepalive_probes 缺省值：9 秒 建议值：5 秒 调整 AIX 系统根据需要，更改下列配置设置或变量： TCP_TIMEWAIT 描述：指定时间（以 15 秒为时间间隔），TCP/IP 必须经过该时间之后才能释放已关闭的连接并复用其资源。例如，如果对此属性指定值 1，那么 TCP/IP 必须经过 15 秒之后才能释放已关闭的连接并复用其资源。 关闭与释放之间的这段时间称为 TIME_WAIT 状态或者两倍最大段生存期 (2MSL) 状态。此时间期间，重新打开到客户机和服务器的连接的成本少于建立新连接。通过减少此条目的值，TCP/IP 可以更快地释放关闭的连接，并为新连接提供更多资源。如果运行中的应用程序要求快速释放连接或创建新连接，或者由于许多连接处于 TIME_WAIT 状态而导致吞吐量较低，请调整此参数。 如何查看或设置： 发出以下命令以将 TCP_TIMEWAIT 状态设置为 1（15 秒）： 1/usr/sbin/no –o tcp_timewait =1 安装了 DB2® 的 AIX 操作系统 描述：如果将 DB2 日志文件与物理数据库文件分开存储，那么可以提高性能。您还可以将日志和数据库文件从包含日志文件系统 (JFS) 服务的驱动器中分离出来。AIX 使用特定的卷组和文件系统来进行 JFS 记录。 如何查看或设置：使用 AIX filemon 实用程序来查看所有文件系统输入和输出，并在战略上选择 DB2 日志文件的文件系统。根据 DB2 日志记录信息来设置 DB2 日志位置。 缺省值：DB2 日志文件的缺省位置通常是存储数据库表的磁盘驱动器。 建议值：将日志文件移动到不用于存储 DB2 数据并且具有最低输入或输出活动量的磁盘。 AIX 文件描述符 (ulimit) 描述：对用户帐户指定资源使用的各种限制。ulimit -a 命令显示所有 ulimit 限制，其中包括允许打开的文件数。打开文件设置的缺省数目 (2000) 通常足以供大多数应用程序使用。如果对此参数设置的值太小，在打开文件或建立连接时就可能会出错。由于此值限制服务器进程可打开的文件描述符数，因此如果值太小，就会导致性能欠佳。 如何查看或设置： 执行以下步骤将打开文件限制值更改为 10,000 个文件： 打开命令窗口。 编辑/etc/security/limits文件。将以下行添加到运行WebSphere Application Server进程的用户帐户： 12nofiles = 10000 nofiles_hard = 10000 保存所作的更改。 重新启动 AIX 系统。 要验证结果，请在命令行上输入 ulimit -a 命令。 缺省值：对于 AIX 操作系统，缺省设置是 2000。 建议值： 该值取决于应用程序并专门应用于应用程序数据和应用程序堆栈。 增加 ulimit 文件描述符限制值可提高性能。根据应用程序的不同，可能需要增加其他限制的值。对数据或堆栈 ulimit 的任何更改应该确保数据+堆栈 &lt; 256MB（仅限于 32 位 WebSphere Application Server）。 对于数据，建议您将 ulimit 更改为“无限制”。 AIX ARP 表存储区大小 如何查看或设置： netstat -p arp 将显示已发送的 ARP 包数和已从 ARP 表中清除的 ARP 条目数。如果要清除的条目数较大，请增大 ARP 表大小。使用arp -a来显示 ARP 表散列分布。设置： 1no -r -o arptab_size=10 缺省值：14400 个半秒（2 小时）。 建议值：600 个半秒（5 分钟）。 TCP_KEEPINTVL 描述：指定为了验证连接而发送的各个包之间的时间间隔。 如何查看或设置： 使用以下命令来将此值设置为5秒： 1no -o tcp_keepintvl=10 缺省值：150（1/2 秒） 建议值：10（1/2 秒） TCP_KEEPINIT 描述：指定 TCP 连接的初始超时值。 如何查看或设置：使用以下命令来将此值设置为20秒： 1no -o tcp_keepinit=40 缺省值：150（1/2 秒） 建议值：40（1/2 秒） 为 Java 虚拟机堆分配大页 (16 MB) 某些应用程序要求使用非常大的堆以提高性能。通过使用 CPU 和操作系统提供的大页支持，可以降低 CPU 管理大型堆的开销。以下步骤以大页 (16 MB) 形式分配 4 GB 的 RAM： 作为 root 用户，运行下列命令以保留 4 GB 的大页： 123vmo -r -o lgpg_regions=256 -o lgpg_size=16777216 bosboot -ad /dev/ipldevice reboot -q 在重新引导后，运行以下命令以便在 AIX 操作系统上启用大页支持： 1vmo -p -o v_pinshm=1 作为 root 用户，为用户添加下列能力： 1chuser capabilities=CAP_BYPASS_RAC_VMM,CAP_PROPAGATE $USER 将-Xlp Java 选项添加至 Java 命令。 单击服务器 &gt; 服务器类型 &gt; WebSphere 应用程序服务器 &gt; server_name。 在服务器基础结构下，单击 Java 和进程管理 &gt; 进程定义 &gt; Java 虚拟机。 在通用 JVM 参数字段中，添加 -Xlp。 添加EXTSHM 定制属性并设置为OFF。 单击服务器 &gt; 服务器类型 &gt; WebSphere 应用程序服务器 &gt; server_name。 在服务器基础结构下，单击 Java 和进程管理 &gt; 进程定义 &gt; 环境条目 &gt; 新建。 在名称字段中，输入 EXTSHM。 在值字段中，输入 OFF。 使用以下命令验证所使用的大页支持： 1vmstat -l 1 Note当应用程序运行时，“alp”列包含非零值。 启用大页可能会出现严重后果。有关大页的更多详细信息，请参阅有关 AIX 大页的信息。 如果不想使用大页选项，也可以选择中等页面选项。中等页面大小选项在性能收益方面类似或接近于大页面。但是，它并不涉及为特定用户或进程保留物理内存的问题。有关更多信息，请阅读“调整 Java 虚拟机”信息。 其他 AIX 信息 考虑本文档未阐述的其他 AIX 操作系统设置。您还可以调整下列设置： 适配器发送和接收队列 TCP/IP 套接字缓冲区 IP 协议 mbuf 池性能 更新文件描述符 更新调度程序 有关 AIX 操作系统的更多信息，请参阅性能：学习资源信息。 调整HP Unix 系统https://www.ibm.com/support/knowledgecenter/zh/SSEQTP_8.5.5/com.ibm.websphere.base.doc/ae/tprf_tunehp.html 为什么要调整 TCP/IP 缓冲区 WebSphere® Application Server 广泛地使用了 TCP/IP 套接字通信机制。对于 TCP/IP 套接字连接，发送和接收缓冲区大小定义了接收窗口。接收窗口指定在发送被中断前可以发送而不会被接收的数据量。如果发送太多数据，就会使缓冲区过载并中断传输。数据传输中断控制机制称为流量控制。如果 TCP/IP 缓冲区的接收窗口太小，接收窗口缓冲区就会频繁地过载，流量控制机制就会停止数据传输，直到接收缓冲区被清空为止。 调整操作系统总结 对象名 属性名 建议值 操作系统参数 tcp_keepidle 600 tcp_keepintvl 10 tcp_keepinit 40 Soft FILE Size -1 Soft CPU Time -1 Soft STACK Size -1 Soft CORE File Size -1 Hard FILE Size -1 Hard CPU Time -1 Hard STACK Size -1 Hard CORE File Size -1 调整 JVM版本查看1java –fullversion 选择稳定的JVM 选择稳定的JDK：刚刚GA的版本不稳定，比如1.5.0_00 1.6.0_00刚增加新特性的版本不稳定，比如1.7.0_80 1.8.0_74安装JDK之前，先看厂商的Release Notes 根据平台和应用，选择合适厂商的JDK：HP-UX只能选择HP JDK，AIX只能选择IBM JDKWindows、Linux可以选择SUN JDK和JRockitSolaris平台，最好使用SUN JDK开源JDK，目前生产环境中用的极少 调整 IBM Java 虚拟机IBM JVM 内存结构 IBM GC算法虽然每个策略都有独特优点，但对于 WebSphere Application Server V8.0 及更高版本，gencon 是缺省垃圾回收策略。应用程序服务器的先前版本指定 optthruput 作为缺省垃圾回收策略。 策略 选项 描述 针对吞吐量进行优化 -Xgcpolicy:optthruput（可选） 默认策略（WAS8以前版本）。提供高吞吐量，但垃圾回收暂停时间较长。在垃圾回收期间，将停止所有应用程序线程，以便进行标记、清理并根据需要进行压缩。gencon 策略对于大部分应用程序而言已经够用了。 针对停顿时间进行优化 -Xgcpolicy:optavgpause 策略通过在应用程序运行期间执行垃圾回收的标记和清理阶段来缩短垃圾回收暂停时间。此策略会对整体吞吐量产生轻微的性能影响。 分代并发 -Xgcpolicy:gencon 默认策略（WAS8以后版本）此策略与分代垃圾回收器配合使用。分代模式尝试实现高吞吐量并同时缩短垃圾回收暂停时间。为了实现此目标，将堆分为新区域和旧区域。长生命周期对象将被提升到旧空间，而短生命周期对象将在新空间中被迅速地作为垃圾回收。gencon 策略能使许多应用程序受益匪浅。但是，它并不适合所有应用程序，并且通常难以调整。 子池 -Xgcpolicy:subpool 策略可以提高多处理器系统（通常使用 8 个以上处理器）的性能。此策略仅适用于 IBM System i® System p® 和 System z® 处理器。subpool 策略与 gencon 策略类似，只是它将堆划分为子池以提高对象分配可伸缩性。 将 gcpolicy 设置为 gencon 会禁用并发标记。除非应用程序响应时间不规律（这表示可能存在暂停时间问题），否则，使用 gencon 策略应可获得最佳的吞吐量结果。 将 gcpolicy 设置为 optavgpause 会使用缺省值来启用并发标记。此设置将减少由正常垃圾回收所引起的应用程序响应时间不规律情况。但是，此选项可能会降低整体吞吐量。 切换到其他 GC 策略的原因-IBM GC收集器 切换到其他 GC 策略的原因-IBM optavgpause 我的应用程序无法忍受那么长的 GC 停顿时间。如果 GC 停顿时间能够减少的话，性能降低一些也可以接受。 我的应用程序正在一个 64 位平台上运行并使用非常大的堆 —— 超过 3 或 4GB。 我的应用程序是一个 GUI 应用程序，我很关注用户响应时间。 gencon 我的应用程序分配了许多短期存活的对象。 堆空间出现碎片化。 我的应用程序是基于事务的（也就是说，在事务提交之后，事务中的对象就不再存活了）。 subpool 在大型多处理器计算机上，我遇到了可伸缩性问题。 除此之外之外建议增加参数IBM JDK-verbose:gc -Xverbosegclog:&lt;path_GC_log_file_name&gt;-verbose:gc -Xverbosegclog:gc.log-verbose:gc -Xverbosegclog:/tmp/gc.log 中国银行标准环境建议参数配置应用程序服务器(Server)JVM参数进入管理控制台-&gt;应用程序服务器-&gt;server_name-&gt;java和进程管理-&gt;进程定义-&gt;java虚拟机，对server进行如下设置： 64位WAS 报表类、批量操作等需要占用大量内存的系统如下设置： 打开详细垃圾回收； JVM具体设置的参数为：初始堆1024，最大堆6144； JVM通用参数： -Xgcpolicy:gencon -Xmns256m -Xmnx1536m -Djava.net.preferIPv4Stack=true –配置应用程序服务器(Server)JVM参数 进入管理控制台-&gt;应用程序服务器-&gt;server_name-&gt;java和进程管理-&gt;进程定义-&gt;java虚拟机，对server进行如下设置： 1、64位WAS 报表类、批量操作等需要占用大量内存的系统如下设置： 打开详细垃圾回收； JVM具体设置的参数为：初始堆1024，最大堆6144； JVM通用参数： -Xgcpolicy:gencon -Xmns256m -Xmnx1536m -Djava.net.preferIPv4Stack=true –Xdisableexplicitgc -Xgc:preferredHeapBase=0x100000000 点击确定和保存之后，重启WAS Server生效。 非报表类、批量操作，对内存无特殊要求的系统如下设置： 打开详细垃圾回收； JVM具体设置的参数为：初始堆1024，最大堆3072； JVM通用参数： -Xgcpolicy:gencon -Xmns256m -Xmnx768m -Djava.net.preferIPv4Stack=true -Xdisableexplicitgc 点击确定和保存之后，重启WAS Server生效。 测试环境 打开详细垃圾回收； JVM具体设置的参数为：初始堆512，最大堆1024；（如有特殊需求可自定义） JVM通用参数： -Xgcpolicy:gencon -Xmns256m -Xmnx768m -Djava.net.preferIPv4Stack=true –Xdisableexplicitgc 点击确定和保存之后，重启WAS Server生效。 2、32位WAS 打开详细垃圾回收； JVM具体设置的参数为：初始堆512，最大堆1536； JVM通用参数： -Xgcpolicy:gencon -Xmns128m -Xmnx384m -Djava.net.preferIPv4Stack=true -Xdisableexplicitgc 点击确定和保存之后，重启WAS Server生效。-Xgc:preferredHeapBase=0x100000000 点击确定和保存之后，重启WAS Server生效。 非报表类、批量操作，对内存无特殊要求的系统如下设置： 打开详细垃圾回收； JVM具体设置的参数为：初始堆1024，最大堆3072； JVM通用参数： -Xgcpolicy:gencon -Xmns256m -Xmnx768m -Djava.net.preferIPv4Stack=true -Xdisableexplicitgc 点击确定和保存之后，重启WAS Server生效。 测试环境 打开详细垃圾回收； JVM具体设置的参数为：初始堆512，最大堆1024；（如有特殊需求可自定义） JVM通用参数： -Xgcpolicy:gencon -Xmns256m -Xmnx768m -Djava.net.preferIPv4Stack=true –Xdisableexplicitgc 点击确定和保存之后，重启WAS Server生效。 32位WAS打开详细垃圾回收； JVM具体设置的参数为：初始堆512，最大堆1536； JVM通用参数： -Xgcpolicy:gencon -Xmns128m -Xmnx384m -Djava.net.preferIPv4Stack=true -Xdisableexplicitgc 点击确定和保存之后，重启WAS Server生效。 IBM JDK 调优更多信息建议参考https://www.ibm.com/support/knowledgecenter/zh/SSEQTP_8.5.5/com.ibm.websphere.base.doc/ae/tprf_tunejvm_v61.html 调整 HotSpot Java 虚拟机（Solaris 和 HP-UX）HotSpot JVM 内存结构 HotSpot JVM GC根据回收器，简单分为： 串行 –XX:+UseSerialGCOut of Box算法，年轻代串行复制，年老代串行标记整理，主要用于桌面应用 并行 –XX:+UseParallelGC​ 年轻代暂停应用程序，多个垃圾收集线程并行的复制收集，年老代暂停应用程序，与串行收集器一样，单垃圾收集线程标记整理。JDK 6.0启用该算法后，默认启用了-XX:+UseParallelOldGC，性能大为提高 并发(Concurrent Low Pause Collector) –XX:+UseConcMarkSweepGC​ 启用该参数，默认启用了-XX:+UseParNewGC；简单的说，并发是指用户线程与垃圾收集线程并发，程序在继续运行，而垃圾收集程序运行于其他CPU上。 Garbage First (G1) Garbage Collector​ -XX:MaxGCPauseMillis=200 -XX:+UseG1GC​ JDK7u04 以后引入， heap&gt;6G建议使用。 实际生产环境中还很少使用 CMS收集器 即使G1出来几年了，生产环境很多的JVM实例还是采用ParNew+CMS的组合 不只是CMS，就是G1，以及JDK11的ZGC都没有做到完全的并发。就目前笔者了解到的所有GC中，只有Azul的C4是完全并发的。 CMS收集器工作过程 CMS收集器主要参数 -XX:CMSInitiatingOccupancyFraction=80（默认是92%） -XX:+UseCMSInitiatingOccupancyOnly 表示只有在达到阈值才会进行回收。 -XX:CMSWaitDuration=5000 轮询的时间控制（默认是2秒钟）。内存碎片问题，从而埋下发生FullGC导致长时间STW的隐患。 -XX:+UseCMSCompactAtFullCollection （默认值就是true） -XX:CMSFullGCsBeforeCompaction=0在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。（默认值是0） -XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收 CMS GC要决定是否在full GC时做压缩，会依赖几个条件。其中，第一种条件，UseCMSCompactAtFullCollection 与 CMSFullGCsBeforeCompaction 是搭配使用的；前者目前默认就是true了，也就是关键在后者上。第二种条件是用户调用了System.gc()，而且DisableExplicitGC没有开启。第三种条件是young gen报告接下来如果做增量收集会失败；简单来说也就是young gen预计old gen没有足够空间来容纳下次young GC晋升的对象。 考虑下列调整参数： -XX:MaxPermSize（永久区域） -Xmx（最大 Java 堆大小） -XX:+DisableExplicitGC （禁用显式垃圾回收以消除任何不必要或不合时宜的主要垃圾回收循环） 调整区域大小以优化垃圾回收操作。 Sun JDK常用参数-XX:+UseSerialGC：在新生代和老年代使用串行收集器-XX:+UseParNewGC：在新生代使用并行收集器-XX:+UseParallelGC ：新生代使用并行回收收集器（ 使用Parallel收集器+ 老年代串行）-XX:+UseParallelOldGC：使用Parallel收集器+ 老年代并行-XX:ParallelGCThreads：设置用于垃圾回收的线程数-XX:+UseConcMarkSweepGC:设置并发收集器-XX:ParallelCMSThreads：设定CMS的线程数量-Xms:初始堆大小-Xmx:最大堆大小-XX:SurvivorRatio：设置eden区大小和survivior区大小的比例-XX:NewRatio:新生代和老年代的比-XX:NewSize=n:设置年轻代大小 除此之外建议参数Sun JDK-verbose:gc -Xloggc:gc.log-verbosegc -XX:+PrintGCDetails -Xloggc:ms1gc.log-verbosegc -XX:+PrintGCDetails -Xloggc:/tmp/ms1gc.log-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=${目录} 中国银行标准环境参数配置应用程序服务器(Server)JVM参数进入管理控制台-&gt;应用程序服务器-&gt;server_name-&gt;java和进程管理-&gt;进程定义-&gt;java虚拟机，对server进行如下设置：打开详细垃圾回收，JVM堆调整为1024～3072。 建议在HP系统的WAS中添加如下通用JVM参数：-XX:MaxPermSize=768m -Xverbosegc:file=Xverbosegc.out -XX:+HeapDump -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -server 可以防止永久代空间不足，输出更详细的垃圾回收日志，以及在内存溢出和执行kill -3时生成heapdump。其中-XX:MaxPermSize=768m 指定永久代为heap最大堆的1/4，即最大堆为3G时，设为768m，如果最大堆为6G，则设1536m。点击确定和保存之后，重启WAS Server生效。 Websphere JVM 日志优化JVM日志设置：将SystemOut.log和SystemErr.log设置成为每天循环写入的格式，循环30天，具体可参考下图： WebSphere 系统队列介绍和调优WebSphere 排队网络当客户端发出一个请求时，该请求会从网络端开始依次进入 WehSphere 服务器的各个组件，这些请求会在各个组件中进行排队等候使用服务器资源或者等待进入下一个组件进一步被服务器处理请求，每个组件里的请求组成请求队列，而组件依次排列，就够成了 WebSphere 排队网络。正如下图所示，该排队网络包括互联网、Web 服务器、Web 容器、EJB 容器以及数据库端的连接池队列等等。WebSphere 队列里的各个组件是互相资源依赖的，对请求的平均服务时间依赖于服务器队列中每个组件在同一时间的最大并发数。 保守队列和开放队列 开发队列 EJB 容器则继承了对象请求代理（ORB）的队列特性，属于开放队列。 保守队列中的用户请求有两种状态 激活状态 等待状态。 在 WebSphere 服务器的队列网络中，Web 服务器、Web 容器以及数据库连接池都属于保守队列。EJB 容器则继承了对象请求代理（ORB）的队列特性，属于开放队列。 WebSphere 中的队列调优漏斗原则WAS 调优的第一原则就是漏斗原则。一般来说，让客户不能及时得到处理的请求在网络中等待，比让它们在 WebSphere 服务器中等待要好。下图的设置使得只有即将被服务器接受处理的请求才能进入 WAS 的排队网络，这样更能提高服务器的稳定性，而不至于当大量请求突然进入 WAS 时引起资源耗尽的情况。 在上图的例子中，我们可以看出，在 WebSphere 排队网络中，从上到下队列中处理请求的并发数越来越小。当 200 客户端请求到达 Web 服务器的时候，因为 Web 服务器设置了自己的最大并发数是 75，所以剩下的 125 个客户请求只能暂留在网络中进行排队等待被 Web 服务器处理；当这 75 个请求经过 Web 服务器被处理后，其中 25 个仍在停留在 Web 服务器中排队，而剩下的 50 个请求则进去 Web 容器被进一步处理；直到最后有 25 个请求到达最后的数据库端，这时请求被处理完毕。在这个系统中，每一个组件都在充分的工作，没有因为等待请求到来而造成的资源浪费，因为在任何一个时刻，每个队列里都有少量请求在等待着被下一个组件处理。因为大量的请求被阻止在 WebSphere 服务器的外面（网络），所以 WebSphere 的各个组件不会因为大量请求同时到来而引起资源耗尽，这样的设置增加了系统的稳定性。 绘制吞吐率曲线我们需要画出系统在运行时的吞吐率曲线，要完成曲线，需要准备一个测试用例，然后将系统运行起来，我们的目的是要将系统的潜能发挥到最大，即系统运行达到一个资源利用的饱和点。系统运行达到饱和点最有代表性新的特征就是 CPU 的利用率接近 100%。 所有的队列并发数都设置为一个较大的值，而且各个队列的值也设成是相等的 在每一次的测试后，增加用户并发数，迭代测试（1,5,10,25,50,100,150,200…） 记录下每次系统的吞吐率和响应时间，就得到了类似于下图的吞吐率曲线。 根据应用的实际情况来调整队列仅仅根据上面的准则来调优 WAS 是远远不够的，我们还应根据应用的使用环境和访问模型来调整各个队列的大小。并不是所有的请求都会从上一个队列进入到下一个队列中，比如，有些请求可能在经过 Web 服务器处理后就返回给客户端了，因为这些用户仅仅是想请求一些静态的页面内容，这时我们可以将 Web 服务器的队列值设的大一些，我们上面将 Web 服务器设成 75 就是这样的考虑；又比如，如果在一个应用中，大部分的请求都需要进行复杂而耗时的数据库操作，这时我们就应该考虑同时加大数据库连接池和 Web 容器的队列值大小。所以，在我们实际的调优中，必须结合具体的应用来确定合适的值，并在不断调整的过程中，监控 CPU 和内存的使用，避免系统资源耗尽的情况出现。 WebSphere 池资源调优的最佳实践ORB 调优Websphere 架构 WAS EJB容器 可以使用 WAS 管理控制台进行 ORB 线程池的配置，位于 Application servers &gt; AppServer name &gt; Thread pools &gt; ORB.thread.pool 第一种场景中，servlet 主要做一些持续时间非常短的远程调用，servlet 可以重用已经存在的 ORB 线程。在这种情况下，ORB 线程池可以设的比较小，例如只要设置为 Web 容易最大并发量的一半就行； 第二种场景中，持续时间比较长的 EJB 调用将会长期的占用 ORB 连接，因此该连接被重用的机会很小，所以在这种场景中，最好将 ORB 线程池的大小与 Web 容器的最大并发量设置成相等，或者更大。 Web 容器线程池WebContainer线程池 中国银行标准环境调优： 调整WebContainer线程池最小大小和最大大小分别为100、100。确认后保存。 调优准则：一般来说，每个服务器 CPU，5 至 10 个线程将会提供最佳吞吐量。 调优参考：另外我们也可以利用 WAS 自带的 TPV 来帮助我们设置 Web 容器线程池。对系统做一个压力测试，保持一定的负载，观测 TPV 中的 PercentMaxed 和 ActiveCount的值。 PercentMaxed 表示所有线程被使用的平均百分比，如果该值较大，那么就应该增大线程池的值 ActiveCount 表示被激活的线程个数，如果该值远小于当前线程池的大小，那么可以考虑减小线程池的值。` 数据库连接池见下文《JDBC数据库连接池优化》 调整传输通道服务此小结非重点内容，请着重关注中国银行标准环境设置建议总结 传输通道服务管理 HTTP 和 JMS 请求的客户机连接和 I/O 处理。这些 I/O 服务基于 Java™ 提供的非分块 I/O（NIO）功能。 通过更改一个或多个与传输链相关联的传输通道的缺省设置值，可以提高该通道的性能。 调整 TCP 传输通道设置。 减小指定的最大打开连接数属性值。 此参数控制可供服务器使用的最大连接数。如果让此参数保留为缺省值 20000（它是最大连接数），那么可能会导致停止的 Web 站点处于失败状态，因为产品会继续接受连接，因而会增加连接及相关联的工作的积压。应将缺省值更改为一个小很多的值（例如 500），然后应执行其他调整和测试，以确定应为特定 Web 站点或应用程序部署指定的最佳值。 如果关闭客户机连接前未能及时地将数据写回到客户机，那么，请更改“不活动超时”参数值。此参数控制可供服务器使用的最大连接数。接收到新连接后，TCP 传输通道先等待足够的数据到达，然后再将该连接分派给 TCP 传输通道上特定于协议的通道。如果在对“不活动超时”参数指定的时间段内未接收到足够的数据，TCP 传输通道就会关闭该连接。此参数的缺省值是 60 秒。此值适合于大多数应用程序。如果工作负载涉及许多连接，并且所有这些连并非都能够在 60 秒内接受服务，那么应该增大对此参数指定的值。 中国银行标准环境设置建议总结Maximum open connections 将该标准定为1500，但由于该值与server数量和webserver的数量密切相关，所以具体的值还需要根据实际的server数量和webserver数量来调整： 在管理控制台中，单击服务器 &gt; 应用程序服务器 &gt; server_name。然后在 Web 容器设置下，单击Web 容器传输链-&gt; WCInboundDefault &gt; TCP inbound channel (TCP_2), 将Maximum open connections 的值由20000修改为1500。 调整 Web 服务器通过用性整 IBM® HTTP Server 2.0.47.1、Apache 2.0.48、IBM HTTP Server 6.0 和 IBM HTTP Server 6.1。 监视 CPU 利用率并检查 IBM HTTP Server 的 error_log 和 http_plugin.log 文件可以帮助您诊断 Web 服务器性能问题。 打开IBM HTTP Server 监视功能也可以将 IBM HTTP Server 配置为显示状态页面： 编辑 IBM HTTP Server 的 httpd.conf 文件，从此文件的下列各行中除去注释字符 (#)： 1234#LoadModule status_module, modules/ApacheModuleStatus.dll,#&lt;Location/server-status&gt;#SetHandler server-status#&lt;/Location&gt; 保存更改并重新启动 IBM HTTP Server。 在 Web 浏览器中，访问 http://your_host/server-status。或者，单击重新装入以更新状态。 （可选）如果浏览器支持刷新，那么转至 http://your_host/server-status?refresh=5 以便每 5 秒钟刷新一次。 所有这些 Web 服务器都将分配一个线程来处理每个客户机连接。通过确保有足够的线程可用于最大数目的并发客户机连接，有助于确保在此层面不存在瓶颈。可以通过更改 Web 服务器系统上的 httpd.conf 文件来调整这些 Web 服务器的设置。 您可以检查 IBM HTTP Server 的 error_log 文件，以了解是否有任何警告指出已达到最大客户机数 (MaxClients)。有几个参数可用于确定 Web 服务器支持的最大客户机数，具体取决于特定的操作系统平台。请参阅 http://httpd.apache.org/docs-2.0/mod/mpm_common.html#maxclients 以获取 MaxClients 参数的描述。 响应“连接被拒绝”错误消息 ListenBacklog 参数向操作系统指示所允许的最大暂挂连接数。虽然 IBM HTTP Server 的缺省值是 511 StartServers 参数指示最初要启动的 IBM HTTP Server 进程数。通过预先启动这些 IBM HTTP Server 线程/进程，可以减少用户必须等待新进程启动的机率。您应该将此参数设置为等于 MinSpareServers 参数值，以便立即启动此客户机负载所需的最小 IBM HTTP Server 进程数。 防止在用户数出现变化时频繁地创建和破坏客户机线程/进程 您可以使用 MinSpareServers 和 MaxSpareServers 来指定可以处于空闲状态的服务器（客户机线程/进程）的最小数目和最大数目。为了防止在用户数出现变化时频繁地创建和破坏客户机线程/进程，请将此范围设置成足够大，以包括最大并发用户数。 中国银行标准环境建议值 参数建议值 IHS参数 ServerLimit 16ThreadLimit 100StartServers 16MaxClients 1600MinSpareThreads 160MaxSpareThreads 1600ThreadsPerChild 100MaxRequestsPerChild 0 JDBC数据源连接池优化连接池大小调优调整方法进入管理控制台 &gt; 资源 &gt; 数据源 &gt; ${datasource_name} &gt; 连接池属性 : 设置最小/最大连接数为：10/80. 调整依据 监测值名称 描述 调优策略 PooSize 连接池的大小 PooSize 会随着新连接的建立而增加，会随着连接的销毁而减少；应该为连接池设立一个最大值。 PercentUsed 连接池线程被使用的百分比 如果该值长时间都很小，那么你应该调小 PooSize，反之应该增大。 WaitingThreadCount 单位时间内正在等待建立数据库连接的线程的个数 系统最佳的性能体现在该值总是保持在很小的数目，如果该值偏大，则需要对系统进行调优 PercentMaxed 数据库所有连接都被使用的时间所占的百分比 确保这个值不会长时间的达到 100%，如果是那样，那么你该考虑增大 PooSize 值 数据源语句缓存 调整 Web 应用程序 调整 URL 高速缓存 调整会话 调整 URL 高速缓存URL 调用高速缓存用来存放关于将请求 URL 映射至 Servlet 资源的信息。此高速缓存基于 Web 容器，而且供所有 Web 容器线程共享。将为每个可用于处理请求的 Web 容器线程创建所请求大小的高速缓存。调用高速缓存的缺省大小为 500。如果当前正在使用 500 个以上的唯一 URL（每个 JavaServer Page 都是一个唯一的 URL），那么应该增大调用高速缓存的大小。 高速缓存越大，使用的 Java 堆内存量就越大，因此还可能需要增大最大 Java 堆大小。例如，如果每个高速缓存条目需要 2 KB，最大线程大小设为 25，并且 URL 调用高速缓存大小是 100，那么需要 5MB 的 Java 堆。 调整过程 Procedure在管理控制台中，单击服务器 &gt; 服务器类型 &gt; WebSphere 应用程序服务器，然后选择要调整的应用程序服务器。单击 Java 和进程管理。在“其他属性”下单击进程定义。在“其他属性”下面，单击 Java 虚拟机。在“其他属性”下面，单击定制属性。在“名称”字段中指定 invocationCacheSize，并在“值”字段中指定高速缓存的大小。 调用高速缓存的缺省大小为 500 条目。因为调用高速缓存不再基于线程，所以由用户指定的调用高速缓存大小乘以 10，以提供与前发行版相似的功能。例如，如果指定调用高速缓存大小为 50，那么 Web容器将创建大小为 500 的高速缓存。单击应用，然后单击保存以保存更改。停止并重新启动应用程序服务器。 调整会话 Session 会话超时 完成后使用 javax.servlet.http.HttpSession.invalidate() 释放 HttpSession 对象。HttpSession 对象在 Web 容器中存活到： 应用程序使用 javax.servlet.http.HttpSession.invalidate 方法明确地、程序化地释放它；频繁、程序化的无效是应用程序注销功能的一部分。 WebSphere Application Server 在已分配的 HttpSession 到期时（缺省 = 1800 秒或 30 分钟）将其销毁。 当开发要在 HTTP 会话中存储的新对象时，实现 java.io.Serializable 接口 如果类未实现Serializable 接口，那么 JVM 无法将该类的状态保持到数据库或另一个 JVM 中。可序列化类的所有子类型都是可序列化的。以下是此变量的示例： public class MyObject implements java.io.Serializable {…} 会话亲缘关系 使用会话亲缘关系，用户将为第一个请求在 server1上启动；然后，对于每个后续的请求，用户将被导向回 server1 应用程序优化及APM工具应用程序代码优化开发人员控制 性能调优工具APM工具 国外 Dynatrace、NewRelic、AppDynamics、CA、Compuware、Riverbed、IBM、Dell、Microsoft、Splunk、HP、Orcale、BMC Software、Netscout、amics、Ruxit、zoho 国内 云智慧、OneAPM、彩讯、博睿、上海天旦、听云 开源 pinpoint、zipkin、cat、skywalking IBM 官方推荐工具PTTWebSphere Application Server Perfroamcne Tuning Toolkit WebSphere Application Server Performance Tuning Toolkit（简称 PTT）是一款轻量级的基于 eclipse 的客户端软件。启动后的界面如下图 1 所示， 其中，Hosts view 用于创建到 Dmgr（网络部署版）或者 Server(Base 版 ) 的 Soap 连接，连接后系统的拓扑结构会显示在 Topology view 里，Main Area 主要用来显示监控信息，包括主监控面板，每个 Server 的图形化监控页面和详细数据信息等。Tuning Parameters View 和 Scripts View 主要用于性能调优。Tuning Parameters View 用于察看和修改每个服务器的性能参数，比如 JVM 的最大堆大小、垃圾回收策略，各种容器和线程池的大小，HTTP 连接相关设置等。Tuning Parameters View 可以方便得调整 Server 级别的性能参数，尤其是批量调整，但对于很多比较复杂的调优参数，比如 DB 和 JMS 连接池等，则需要通过远程执行 Wsadmin 脚本来优化。 拓扑 监控 规则引擎与警告预定义规则如下： 如果 Java Heap 使用超过 85%，抛出一个运行时警告。 如果线程池使用超过 90%，抛出一个线程池警告。 如果平均 CPU 使用率超过 90%，抛出一个运行时警告。 如果有 servlet 错误发生，抛出一个 servlet 警告。 如果有 JDBC 连接超时，抛出一个连接警告。 如果出现超过 1000 个 prepared statement 被废弃，抛出一个连接警告。 如果有线程等待连接，抛出一个连接警告。 如果发生 JCA 连接错误，抛出一个 JCA 警告。 如果已经无法容纳新的 session，抛出一个 session 警告。 如果有 Thread hung 发生，抛出一个线程池警告。 如果有交易回滚发生，抛出一个交易警告。 如果有交易超时发生，抛出一个交易警告。 如果有代理请求失败，抛出一个代理警告。 如果检测到 servlet 性能下降，抛出一个 servlet 警告。 如果检测到 JDBC 性能问题，抛出一个 警告。 在线调整参数生成 Dump 文件和启用 Trace报表模块 更多PTT工具学习建议查看 WebSphere 应用服务器性能调优工具，第 1 部分: 概述 WebSphere 应用服务器性能调优工具，第 2 部分: 性能监控 WebSphere 应用服务器性能调优工具，第 3 部分: 性能调优 所有调优总结 对象名 属性名 建议值 操作系统参数 tcp_keepidle 600 tcp_keepintvl 10 tcp_keepinit 40 Soft FILE Size -1 Soft CPU Time -1 Soft STACK Size -1 Soft CORE File Size -1 Hard FILE Size -1 Hard CPU Time -1 Hard STACK Size -1 Hard CORE File Size -1 WAS参数 JVM堆设置 1024~3072 JVM日志 24h*30 WebContainer线程池 100~100 通用JVM参数 -Xmns256m -Xmnx768m-Djava.net.preferIPv4Stack=true JDBC连接池大小 10/80 Dmgr超时参数 invalidationTimeout=”180” IHS参数 ServerLimit 16ThreadLimit 100StartServers 16MaxClients 1600MinSpareThreads 160MaxSpareThreads 1600ThreadsPerChild 100MaxRequestsPerChild 0 注：如果是报表类、批量操作等需要占用大量内存的系统，建议JVM堆调整为1024~6144，在JVM通用参数中添加参数为-Xmns256m -Xmnx1536m -Djava.net.preferIPv4Stack=true 欢迎关注rocklei123的技术点滴技术博客: https://rocklei123.github.io/CSDN : http://blog.csdn.net/rocklei123微公众号: rocklei123的技术点滴]]></content>
      <categories>
        <category>WebSphere</category>
      </categories>
      <tags>
        <tag>WebSphere</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Ant的持续集成环境]]></title>
    <url>%2F2018%2F12%2F26%2F%E5%9F%BA%E4%BA%8EAnt%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[需求​ 项目组有一套企业级JavaWeb应用，以前在发布新版本时，都是通过ant将核心源码混淆后打成jar，再通过开发工具导出成war包，然后将加密混淆后的jar添加到war包中，部署到tomcat中。整个流程虽然不够复杂，但整个流程下来至少30分钟。最初的想法就是想让这一切工作全部自动化，节省项目新版本发布时间。 软件选择​ 考察了一些现有持续集成软件，觉得Jenkins 和 Ant都能满足需求。 ​ Jenkins 功能很强大：UI界面、邮件通知、测试报告、分布式构建、多种插件支持。想学习建议参考这篇就够了《Jenkins入门系列之——03PDF文档下载》 ​ 考虑到现有环境一个Ant足以，而且对Ant相对有些了解，所以决定使用Ant搞定持续集成环境。 基于Ant的持续集成环境环境准备 JDK 安装：提供java编译与运行环境 Ant 安装并配置环境变量 123cd /usr/wget http://mirrors.hust.edu.cn/apache//ant/binaries/apache-ant-1.9.13-bin.tar.gztar -zxvf apache-ant-1.9.13-bin.tar.gz Ant 配置环境变量vi /etc/profile 编辑成功后执行source /etc/profile 12export ANT_HOME=/usr/apache-ant-1.9.13export PATH=$PATH:$ANT_HOME/bin 目录准备 123456789[tomcat@localhost packageEnv]$ pwd/home/tomcat/packageEnv[tomcat@localhost packageEnv]$ [tomcat@localhost packageEnv]$ ll-rw-rw-r-- 1 tomcat tomcat 14606 12月 24 17:06 build.xml //核心build文件drwxrwxr-x 5 tomcat tomcat 59 12月 25 19:49 checkout //svn源码检出目录drwxrwxr-x 2 tomcat tomcat 131 12月 25 19:52 encryption //加密程序存放目录drwxr-xr-x 9 tomcat tomcat 4096 12月 19 10:10 smartam //tomcat软件目录，已经更名smartam[tomcat@localhost packageEnv]$ svnant准备 实现ant可以从svn服务器上检出代码要使用svnant相关的jar文件。 下载地址：http://subclipse.tigris.org/files/documents/906/49042/svnant-1.3.1.zip 将下载好的svnant解压将 ib目录下的所有jar复制到ant主目录中的lib目录下。 混淆工具 yguard 下载后放置在项目中，和src 同级目录中。 下载地址：https://www.yworks.com/downloads build 流程 properties配置文件准备 打印环境及 properties信息 停止tomcat 定义ant.svn.classpath，使用svn任务时可以使用 设置svn相关属性 清理旧文件 创建初始化目录结构 从svn 检出源码 初始化classpath 编译java源码 将class文件打成 jar包 混淆源代码 将混淆后的jar包加密 打成war包 将war包部署tomcat 启动tomcat 整个流程下来我们只需要登录目标服务器，切换到/home/tomcat/packageEnv 目录，执行ant命令即可。 核心build.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project name=&quot;smartam&quot; default=&quot;start_tomcat&quot; basedir=&quot;./&quot;&gt; &lt;property environment=&quot;env&quot;/&gt; &lt;property name=&quot;webapp.name&quot; value=&quot;smartam&quot;/&gt; &lt;property name=&quot;ant.name&quot; value=&quot;/usr/apache-ant-1.9.13&quot;/&gt; &lt;property name=&quot;svn.url&quot; value=&quot;svn://127.0.0.1/smartam&quot;/&gt; &lt;property name=&quot;svn.username&quot; value=&quot;rocklei123&quot;/&gt; &lt;property name=&quot;svn.password&quot; value=&quot;xxxxxx&quot;/&gt; &lt;property name=&quot;svn.checkout.dir&quot; value=&quot;$&#123;basedir&#125;/checkout&quot;/&gt; &lt;property name=&quot;svn.checkout.project&quot; value=&quot;$&#123;svn.checkout.dir&#125;/$&#123;webapp.name&#125;&quot;/&gt; &lt;property name=&quot;catalina.home&quot; value=&quot;/home/tomcat/packageEnv/smartam&quot;/&gt; &lt;property name=&quot;dist.dir&quot; value=&quot;$&#123;svn.checkout.dir&#125;/dist&quot;/&gt; &lt;property name=&quot;build.dir&quot; value=&quot;$&#123;svn.checkout.dir&#125;/build&quot;/&gt; &lt;property name=&quot;build.class&quot; value=&quot;$&#123;build.dir&#125;/classes&quot;/&gt; &lt;property name=&quot;build.config&quot; value=&quot;$&#123;build.dir&#125;/META-INF&quot;/&gt; &lt;property name=&quot;webRoot.dir&quot; value=&quot;$&#123;svn.checkout.project&#125;/WebRoot&quot;/&gt; &lt;property name=&quot;src.dir&quot; value=&quot;$&#123;svn.checkout.project&#125;/src&quot;/&gt; &lt;property name=&quot;metainf.dir&quot; value=&quot;$&#123;svn.checkout.project&#125;/src/META-INF&quot;/&gt; &lt;property name=&quot;lib.dir&quot; value=&quot;$&#123;webRoot.dir&#125;/WEB-INF/lib&quot;/&gt; &lt;property name=&quot;app.jar&quot; value=&quot;$&#123;webapp.name&#125;_original.jar&quot;/&gt; &lt;property name=&quot;obf.jar&quot; value=&quot;$&#123;webapp.name&#125;.jar&quot;/&gt; &lt;property name=&quot;encryption.dir&quot; value=&quot;$&#123;basedir&#125;/encryption&quot;/&gt; &lt;property name=&quot;encrypted.webapp.jar.dir&quot; value=&quot;$&#123;encryption.dir&#125;/$&#123;webapp.name&#125;_encrypted.jar&quot;/&gt; &lt;property name=&quot;encrypt.program.jar&quot; value=&quot;$&#123;encryption.dir&#125;/JarByteCodeEncrypt.jar&quot;/&gt; &lt;property name=&quot;shrinklog&quot; value=&quot;$&#123;webapp.name&#125;_shrinklog.xml&quot;/&gt; &lt;property name=&quot;renamelog&quot; value=&quot;$&#123;webapp.name&#125;_renamelog.xml&quot;/&gt; &lt;!-- 使用eclipse jdt进行编译，而不使用JDK编译 &lt;property name=&quot;build.compiler&quot; value=&quot;org.eclipse.jdt.core.JDTCompilerAdapter&quot; /&gt; --&gt; &lt;!-- 打印环境变量和属性赋值情况--&gt; &lt;echoproperties/&gt; &lt;target name=&quot;stop_tomcat&quot; description=&quot;停止Tomcat&quot;&gt; &lt;echo message=&quot;start tomcat...&quot;/&gt; &lt;exec executable=&quot;/bin/sh&quot; os=&quot;Linux&quot; dir=&quot;$&#123;catalina.home&#125;/bin&quot; failonerror=&quot;false&quot;&gt; &lt;env key=&quot;PATH&quot; path=&quot;$&#123;env.PATH&#125;:&quot;/&gt; &lt;env key=&quot;CATALINA_HOME&quot; path=&quot;$&#123;catalina.home&#125;&quot;/&gt; &lt;arg value=&quot;stopsmartam.sh&quot;/&gt; &lt;/exec&gt; &lt;sleep seconds=&quot;2&quot;/&gt; &lt;echo message=&quot;end stop tomcat...&quot;/&gt; &lt;/target&gt; &lt;!-- 定义ant.svn.classpath，使用svn任务时可以使用--&gt; &lt;path id=&quot;ant.svn.classpath&quot;&gt; &lt;fileset dir=&quot;$&#123;ant.home&#125;/lib&quot;&gt; &lt;include name=&quot;*.jar&quot;/&gt; &lt;/fileset&gt; &lt;/path&gt; &lt;pathconvert pathsep=&quot;$&#123;line.separator&#125;| |-- &quot; property=&quot;echo.path.svn&quot; refid=&quot;ant.svn.classpath&quot;&gt; &lt;/pathconvert&gt; &lt;typedef resource=&quot;org/tigris/subversion/svnant/svnantlib.xml&quot; classpathref=&quot;ant.svn.classpath&quot;/&gt; &lt;!-- 设置svn相关属性 --&gt; &lt;svnSetting id=&quot;svn.setting&quot; svnkit=&quot;true&quot; username=&quot;$&#123;svn.username&#125;&quot; password=&quot;$&#123;svn.password&#125;&quot; javahl=&quot;false&quot;/&gt; &lt;!-- show ant classpath jars --&gt; &lt;target name=&quot;print_ant_classpath&quot; depends=&quot;stop_tomcat&quot; description=&quot;输出ant classpath&quot;&gt; &lt;echo message=&quot;|-- ant svn classpath&quot;/&gt; &lt;echo message=&quot;| |&quot;/&gt; &lt;echo message=&quot;| |-- $&#123;echo.path.svn&#125;&quot;/&gt; &lt;/target&gt; &lt;!-- 删除之前的目录结构 --&gt; &lt;target name=&quot;clear&quot; description=&quot;清理旧文件&quot; depends=&quot;print_ant_classpath&quot;&gt; &lt;echo message=&quot;begin clean up directory...&quot;/&gt; &lt;delete dir=&quot;$&#123;build.config&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;delete dir=&quot;$&#123;build.dir&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;delete file=&quot;$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war&quot; quiet=&quot;true&quot;/&gt; &lt;delete dir=&quot;$&#123;dist.dir&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;delete dir=&quot;$&#123;svn.checkout.project&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;delete dir=&quot;$&#123;svn.checkout.dir&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;delete file=&quot;$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;.war&quot; quiet=&quot;true&quot;/&gt; &lt;delete file=&quot;$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;delete includeemptydirs=&quot;true&quot; quiet=&quot;true&quot;&gt; &lt;fileset dir=&quot;$&#123;catalina.home&#125;/logs/&quot; includes=&quot;**/*&quot;/&gt; &lt;/delete&gt; &lt;delete file=&quot;$&#123;encryption.dir&#125;/$&#123;obf.jar&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;delete file=&quot;$&#123;encrypted.webapp.jar.dir&#125;&quot; quiet=&quot;true&quot;/&gt; &lt;echo message=&quot;end clean up directory...&quot;/&gt; &lt;/target&gt; &lt;!-- 创建目录结构 --&gt; &lt;target name=&quot;init&quot; depends=&quot;clear&quot; description=&quot;创建初始化目录结构&quot;&gt; &lt;echo message=&quot;begin mkdir directory...&quot;/&gt; &lt;mkdir dir=&quot;$&#123;build.dir&#125;/classes&quot;/&gt; &lt;mkdir dir=&quot;$&#123;dist.dir&#125;&quot;/&gt; &lt;mkdir dir=&quot;$&#123;build.config&#125;&quot;/&gt; &lt;mkdir dir=&quot;$&#123;svn.checkout.project&#125;&quot;/&gt; &lt;mkdir dir=&quot;$&#123;svn.checkout.dir&#125;&quot;/&gt; &lt;echo message=&quot;end mkdir directory...&quot;/&gt; &lt;/target&gt; &lt;!-- 检出代码 这里使用 export 不是checkout 二者区别 checkout会svn相关信息文件检出，export只是检出最新的文件 &lt;export srcUrl=&quot;$&#123;svn.url&#125;&quot; destPath=&quot;$&#123;svn.checkout.project&#125;&quot; force=&quot;true&quot;/&gt;--&gt; &lt;target name=&quot;checkout&quot; depends=&quot;init&quot; description=&quot;从svn下载源码&quot;&gt; &lt;echo message=&quot;begin svn checkout...&quot;/&gt; &lt;svn refid=&quot;svn.setting&quot;&gt; &lt;checkout url=&quot;$&#123;svn.url&#125;&quot; destPath=&quot;$&#123;svn.checkout.project&#125;&quot; force=&quot;true&quot;/&gt; &lt;/svn&gt; &lt;echo message=&quot;end svn checkout...&quot;/&gt; &lt;/target&gt; &lt;!-- 初始化classpath --&gt; &lt;path id=&quot;project.classpath&quot;&gt; &lt;fileset dir=&quot;$&#123;lib.dir&#125;&quot;&gt; &lt;include name=&quot;**/*.jar&quot;/&gt; &lt;/fileset&gt; &lt;!-- 添加tomcat类路径 --&gt; &lt;fileset dir=&quot;$&#123;catalina.home&#125;/lib&quot;&gt; &lt;include name=&quot;*.jar&quot;/&gt; &lt;/fileset&gt; &lt;/path&gt; &lt;!-- 初始化yguard classpath --&gt; &lt;path id=&quot;yguard.classpath&quot;&gt; &lt;!-- 添加yguard类路径 --&gt; &lt;fileset dir=&quot;$&#123;svn.checkout.project&#125;&quot;&gt; &lt;include name=&quot;yguard.jar&quot;/&gt; &lt;/fileset&gt; &lt;/path&gt; &lt;!-- 编译java --&gt; &lt;target name=&quot;compile&quot; depends=&quot;checkout&quot; description=&quot;编译java文件&quot;&gt; &lt;echo message=&quot;begin compile...&quot;/&gt; &lt;javac srcdir=&quot;$&#123;src.dir&#125;&quot; destdir=&quot;$&#123;build.dir&#125;/classes&quot; includeantruntime=&quot;false&quot; nowarn=&quot;on&quot; source=&quot;1.7&quot; target=&quot;1.7&quot; deprecation=&quot;true&quot; debug=&quot;true&quot; encoding=&quot;UTF-8&quot; classpathref=&quot;project.classpath&quot;&gt; &lt;compilerarg line=&quot;-Xlint:unchecked&quot;/&gt; &lt;/javac&gt; &lt;echo message=&quot;end compile...&quot;/&gt; &lt;/target&gt; &lt;!-- 将class文件打成 jar包 --&gt; &lt;target name=&quot;pack&quot; depends=&quot;compile&quot;&gt; &lt;echo message=&quot;begin pack...&quot;/&gt; &lt;jar jarfile=&quot;$&#123;build.dir&#125;/$&#123;app.jar&#125;&quot;&gt; &lt;fileset dir=&quot;$&#123;build.dir&#125;/classes&quot;&gt; &lt;exclude name=&quot;**/test/&quot;/&gt; &lt;include name=&quot;**/*.class&quot;/&gt; &lt;/fileset&gt; &lt;fileset dir=&quot;$&#123;src.dir&#125;&quot;&gt; &lt;include name=&quot;**/*.xml&quot;/&gt; &lt;include name=&quot;**/*.properties&quot;/&gt; &lt;include name=&quot;**/*.sql&quot;/&gt; &lt;/fileset&gt; &lt;manifest&gt; &lt;!-- If this is an Applet or Web Start application, include the proper attributes from https://docs.oracle.com/javase/8/docs/technotes/guides/jweb/index.html --&gt; &lt;attribute name=&quot;Codebase&quot; value=&quot;www.olm.com.cn&quot;/&gt; &lt;attribute name=&quot;Ant-Version&quot; value=&quot;$&#123;ant.version&#125;&quot;/&gt; &lt;attribute name=&quot;Built-JDK&quot; value=&quot;$&#123;java.runtime.version&#125; $&#123;java.vendor&#125;&quot;/&gt; &lt;!-- Who is building this jar? --&gt; &lt;attribute name=&quot;Built-By&quot; value=&quot;rocklei123&quot;/&gt; &lt;!-- Information about the program itself --&gt; &lt;attribute name=&quot;Implementation-Vendor&quot; value=&quot;Beijing Orient LegendMarker Software Development Co.Ltd&quot;/&gt; &lt;attribute name=&quot;Implementation-Title&quot; value=&quot;smartam&quot;/&gt; &lt;attribute name=&quot;Implementation-Version&quot; value=&quot;3.2.0beta&quot;/&gt; &lt;/manifest&gt; &lt;/jar&gt; &lt;echo message=&quot;end pack...&quot;/&gt; &lt;/target&gt; &lt;!-- 混淆任务--&gt; &lt;target depends=&quot;pack&quot; name=&quot;yguard&quot;&gt; &lt;echo message=&quot;begin yguard jar...&quot;/&gt; &lt;taskdef name=&quot;yguard&quot; classname=&quot;com.yworks.yguard.YGuardTask&quot; classpathref=&quot;yguard.classpath&quot;/&gt; &lt;!-- the following can be adjusted to your needs --&gt; &lt;yguard&gt; &lt;inoutpair in=&quot;$&#123;build.dir&#125;/$&#123;app.jar&#125;&quot; out=&quot;$&#123;build.dir&#125;/$&#123;obf.jar&#125;&quot;/&gt; &lt;externalclasses&gt; &lt;fileset dir=&quot;$&#123;lib.dir&#125;&quot;&gt; &lt;include name=&quot;**/*.jar&quot;/&gt; &lt;/fileset&gt; &lt;fileset dir=&quot;$&#123;catalina.home&#125;/lib&quot;&gt; &lt;include name=&quot;*.jar&quot;/&gt; &lt;/fileset&gt; &lt;/externalclasses&gt; &lt;shrink logfile=&quot;$&#123;build.dir&#125;/$&#123;shrinklog&#125;&quot;&gt; &lt;keep&gt; &lt;class classes=&quot;none&quot; methods=&quot;public&quot; fields=&quot;public&quot;&gt; &lt;patternset&gt; &lt;exclude name=&quot;com.xxxx&quot;/&gt; &lt;/patternset&gt; &lt;/class&gt; &lt;/keep&gt; &lt;/shrink&gt; &lt;rename logfile=&quot;$&#123;build.dir&#125;/$&#123;renamelog&#125;&quot; conservemanifest=&quot;true&quot;&gt; &lt;keep&gt; &lt;class classes=&quot;private&quot; methods=&quot;private&quot; fields=&quot;private&quot;&gt; &lt;patternset&gt; &lt;!-- 不混淆的类--&gt; &lt;include name=&quot;com.olm.**.action.**.*&quot;/&gt; &lt;include name=&quot;com.olm.**.impl.**.*&quot;/&gt; &lt;include name=&quot;com.olm.**.entity.**.*&quot;/&gt; &lt;/patternset&gt; &lt;/class&gt; &lt;package&gt; &lt;patternset&gt; &lt;include name=&quot;com.xxx.*&quot;/&gt; &lt;/patternset&gt; &lt;/package&gt; &lt;/keep&gt; &lt;/rename&gt; &lt;/yguard&gt; &lt;echo message=&quot;end yguard jar...&quot;/&gt; &lt;/target&gt; &lt;!-- 将混淆后的jar包加密 --&gt; &lt;target name=&quot;encrypt&quot; depends=&quot;yguard&quot; description=&quot;将混淆后的jar包加密&quot;&gt; &lt;echo message=&quot;begin encrypt jar...&quot;/&gt; &lt;copy file=&quot;$&#123;build.dir&#125;/$&#123;obf.jar&#125;&quot; todir=&quot;$&#123;encryption.dir&#125;&quot;/&gt; &lt;echo message=&quot;copy Obfuscator jar name of $&#123;build.dir&#125;/$&#123;obf.jar&#125; to drictory $&#123;encryption.dir&#125;&quot;/&gt; &lt;java jar=&quot;$&#123;encrypt.program.jar&#125;&quot; failonerror=&quot;true&quot; fork=&quot;true&quot; maxmemory=&quot;128m&quot;&gt; &lt;classpath&gt; &lt;pathelement location=&quot;$&#123;encrypt.program.jar&#125;&quot;/&gt; &lt;/classpath&gt; &lt;/java&gt; &lt;sleep seconds=&quot;5&quot;/&gt; &lt;echo message=&quot;end encrypt jar...&quot;/&gt; &lt;/target&gt; &lt;!-- 打成war包, 名称默认为 项目名 --&gt; &lt;target name=&quot;war&quot; depends=&quot;encrypt&quot; description=&quot;将工程打成war包&quot;&gt; &lt;echo message=&quot;begin war...&quot;/&gt; &lt;copy file=&quot;$&#123;encrypted.webapp.jar.dir&#125;&quot; todir=&quot;$&#123;lib.dir&#125;&quot;/&gt; &lt;echo message=&quot;copy encrypted jar file name of $&#123;encrypted.webapp.jar.dir&#125; to directory $&#123;lib.dir&#125;...&quot;/&gt; &lt;war destfile=&quot;$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war&quot; basedir=&quot;$&#123;webRoot.dir&#125;&quot; webxml=&quot;$&#123;webRoot.dir&#125;/WEB-INF/web.xml&quot;&gt; &lt;lib dir=&quot;$&#123;lib.dir&#125;&quot;/&gt; &lt;fileset dir=&quot;$&#123;webRoot.dir&#125;&quot;&gt; &lt;include name=&quot;**/**.*&quot;/&gt; &lt;exclude name=&quot;**/test/&quot;/&gt; &lt;exclude name=&quot;$&#123;webRoot.dir&#125;/WEB-INF/classes/&quot;/&gt; &lt;exclude name=&quot;**/*.jar&quot;/&gt; &lt;exclude name=&quot;**/*.class&quot;/&gt; &lt;/fileset&gt; &lt;/war&gt; &lt;echo message=&quot;end war...&quot;/&gt; &lt;/target&gt; &lt;!-- copy war包 tomcat的deploy目录 --&gt; &lt;target name=&quot;deploy&quot; depends=&quot;war&quot; description=&quot;部署项目&quot;&gt; &lt;echo message=&quot;begin deploy...&quot;/&gt; &lt;copy file=&quot;$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war&quot; todir=&quot;$&#123;catalina.home&#125;/webapps&quot;/&gt; &lt;echo message=&quot;end deploy...&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;start_tomcat&quot; depends=&quot;deploy&quot;&gt; &lt;echo message=&quot;starting tomcat...&quot;/&gt; &lt;exec executable=&quot;/bin/sh&quot; os=&quot;Linux&quot; dir=&quot;$&#123;catalina.home&#125;/bin&quot; failonerror=&quot;true&quot;&gt; &lt;env key=&quot;PATH&quot; path=&quot;$&#123;env.PATH&#125;:&quot;/&gt; &lt;env key=&quot;CATALINA_HOME&quot; path=&quot;$&#123;catalina.home&#125;&quot;/&gt; &lt;arg value=&quot;startup.sh&quot;/&gt; &lt;/exec&gt; &lt;sleep seconds=&quot;5&quot;/&gt; &lt;echo message=&quot;end start tomcat...&quot;/&gt; &lt;/target&gt;&lt;/project&gt; 实现效果 Build成功后可直接访问项目地址，查看最新的发布结果。 希望 大家手动敲一遍代码，会收获颇丰！欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/ https://blog.csdn.net/zhouleiblog]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Ant</tag>
        <tag>持续集成</tag>
        <tag>Jenkins</tag>
        <tag>yguard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot热部署及优缺点比较]]></title>
    <url>%2F2018%2F12%2F18%2FSpring-Boot%E7%83%AD%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。 1、模板引擎（不支持Java代码修改热部署）在Spring Boot中开发情况下禁用模板引擎的cache页面模板改变ctrl+F9可以重新编译当前页面并生效 2、Spring Loaded2.1 Spring Loaded介绍Spring官方提供的热部署程序，实现修改类文件的热部署。 2.2 Spring Loaded 使用 下载Spring Loaded（项目地址https://github.com/spring-projects/spring-loaded），放在项目的C:/lib目录中(放在项目目录也可以，在使用时使用相对路径)，然后把idea的run参数里的VM参数设置为：-javaagent:C:/lib/springloaded-1.2.8.RELEASE.jar –noverify 再次修改java文件即时生效，我们修改方法的返回值，这样在run 项目的时候，也能进行热部署了。直接访问就可以得到修改后的结果了。 2.2.3 Spring Loaded缺点引自spring-loaded官方 https://github.com/spring-projects/spring-loaded Q. Does it reload anything that might change in a class file? A. No, you can’t change the hierarchy of a type. Also there are certain constructor patterns of usage it can’t actually handle right now. 并非所有改变都支持热部署，对框架支持比较弱。 3、JRebel（推荐）收费的一个热部署软件，安装插件使用即可。 Jrebel 破解建议查看：https://blog.csdn.net/lawsonjin/article/details/76422807 4、Spring Boot Devtools（推荐）4.1 Spring Boot Devtools原理深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为restart ClassLoader,这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。 4.2 Spring Boot Devtools配置步骤4.2.1 maven 依赖maven引入 Spring Boot Devtools 依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- optional=true,依赖不会传递，该项目依赖devtools；之后依赖myboot项目的项目如果想要使用devtools，需要重新引入 --&gt;&lt;/dependency&gt; 4.2.2 maven 插件在pom.xml文件中，增加如下插件。 12345678910&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;!-- 如果没有该项配置，devtools不会起作用，即应用不会restart ,(这里一直没搞懂)--&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 4.2.3 特殊配置（1） devtools可以实现页面热部署（即页面修改后会立即生效，这个可以直接在application.properties或application.yml 文件中配置spring.thymeleaf.cache=false来实现），实现类文件热部署（类文件修改后不会立即生效），实现对属性文件的热部署。 12345678spring: thymeleaf: cache: false devtools: restart: enabled: true additional-paths: src/main/java exclude: WEB-INF/** （2）配置了后在修改java文件后也就支持了热启动，不过这种方式是属于项目重启（速度比较快的项目重启），会清空session中的值，也就是如果有用户登陆的话，项目重启后需要重新登陆。 （3）默认情况下，/META-INF/maven，/META-INF/resources，/resources，/static，/templates，/public这些文件夹下的文件修改不会使应用重启，但是会重新加载（devtools内嵌了一个LiveReload server，当资源发生改变时，浏览器刷新）。 如果你是eclipse开发，现在已经可以重启项目来使用了。但是，如果你是idea的话，请看4.2.4 的设置！ 4.2.4 IDEA 配合Spring Boot Devtools特殊配置Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG 4.2.4.1 在设置中打开自动编译左上角File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Compiler,选中Build project automaticall 4.2.4.2 打开运行时编译按快捷键 Shift+Ctrl+Alt+/ ，选择 Registryctrl+shift+alt+/（maintenance）勾选compiler.automake.allow.when.app.running 4.2.4.3 关闭自动保存关闭自动保存File—&gt;settings—-&gt;System Settings—&gt;去掉勾选synchronize files on frame or editor tab activation和去掉勾选save files on frame deactivation 123synchronize files on frame or editor tab activation，就是当前应用是intellij时，自动保存文件，比如从浏览器切换到intellij，intellij就是active，会自动保存。save files on frame deactivation,就是从intellij切换到其他应用时，保存文件。 标志修改文件为星号File—-&gt;Settings—–&gt;Editor—-&gt;General—-&gt;Editor tabs—-&gt;勾选 mark modified files as asterisk 4.3 Spring Boot Devtools 测试问题反馈实际测试发现有些修改，需要一并修改标有@SpringBootApplication注解的类，才可以保证修改部署成功,特别是修改Controller标注的类。 12345678@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; 5.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（四）-源码解析AOP原理]]></title>
    <url>%2F2018%2F12%2F16%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%914-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90AOP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring AOP 基础 AOP：【动态代理】 指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式； 实现Spring AOP三部曲： 将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect） 在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式） 123456通知方法：前置通知(@Before)：logStart：在目标方法运行之前运行后置通知(@After)：logEnd：在目标方法运行结束之后运行（无论方法正常结束还是异常结束）返回通知(@AfterReturning)：logReturn：在目标方法正常返回之后运行异常通知(@AfterThrowing)：logException：在目标方法出现异常以后运行环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()） 开启基于注解的aop模式；@EnableAspectJAutoProxy 下文为Spring AOP源码解析 1.@EnableAspectJAutoProxy是什么？ AOP原理：【以@EnableAspectJAutoProxy为入口分析，看给容器中注册了什么组件？这个组件什么时候工作？这个组件的功能是什么？】 @Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar 1234567891011package org.springframework.context.annotation;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)public @interface EnableAspectJAutoProxy &#123; boolean proxyTargetClass() default false; boolean exposeProxy() default false;&#125; 因为AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，ImportBeanDefinitionRegistrar接口我们在前面Bean注册时曾提过，实现该接口可以允许自定义给容器中注册Bean。 1234567891011121314151617class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123; AspectJAutoProxyRegistrar() &#123; &#125; public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class); if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) &#123; AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); &#125; if (enableAspectJAutoProxy.getBoolean("exposeProxy")) &#123; AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); &#125; &#125;&#125; 总结：利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion定义信息为 internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator 总结：给容器中注册一个AnnotationAwareAspectJAutoProxyCreator； 2AnnotationAwareAspectJAutoProxyCreator2.1 AnnotationAwareAspectJAutoProxyCreator 的继承关系AnnotationAwareAspectJAutoProxyCreator -&gt;AspectJAwareAdvisorAutoProxyCreator -&gt;AbstractAdvisorAutoProxyCreator -&gt;AbstractAutoProxyCreator implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware总结：关注SmartInstantiationAwareBeanPostProcessor后置处理器（在bean初始化完成前后做事情）、BeanFactoryAware自动装配BeanFactory 2.2 注册AnnotationAwareAspectJAutoProxyCreator着重关注如下几个类的方法，了解创建和注册AnnotationAwareAspectJAutoProxyCreator的过程 1234AbstractAutoProxyCreator.setBeanFactory()AbstractAutoProxyCreator.有后置处理器的逻辑；AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory()AnnotationAwareAspectJAutoProxyCreator.initBeanFactory() 以下是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程 2.2.1 容器准备工作 1）、传入配置类，创建ioc容器 2）、注册配置类，调用refresh（）刷新容器； 12345public AnnotationConfigApplicationContext(Class... annotatedClasses) &#123; this(); this.register(annotatedClasses); this.refresh();&#125; 3）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建； 2.2.2 registerBeanPostProcessors(beanFactory) 流程 1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor 2）、给容器中加别的BeanPostProcessor 3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor； 123// First, register the BeanPostProcessors that implement PriorityOrdered.sortPostProcessors(priorityOrderedPostProcessors, beanFactory);registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); 4）、再给容器中注册实现了Ordered接口的BeanPostProcessor； 123456789101112131415// Next, register the BeanPostProcessors that implement Ordered.List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;();for (String ppName : orderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125;&#125;sortPostProcessors(orderedPostProcessors, beanFactory);registerBeanPostProcessors(beanFactory, orderedPostProcessors);//其中AbstractAutoProxyCreator 实现了Order接口，就是通过此时注册的AbstractAutoProxyCreator extends ProxyProcessorSupport ProxyProcessorSupport extends ProxyConfig implements Ordered （a） BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 12345public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory &#123;@Override public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123; return doGetBean(name, requiredType, null, false); &#125; （b）然而IOC容器中第一次不会存在该bean,尝试创建Bean 123456789101112131415161718192021public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory// Create bean instance.if (mbd.isSingleton()) &#123; //获取单实例bean为空，尝试createBean sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125; （c）执行createBean:481, AbstractAutowireCapableBeanFactory 和doCreateBean:553, AbstractAutowireCapableBeanFactory （d）initializeBean:1618, AbstractAutowireCapableBeanFactory 详细initializeBean过程见（6） 5）、注册没实现优先级接口的BeanPostProcessor； 123456// Now, register all regular BeanPostProcessors.registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);// Finally, re-register all internal BeanPostProcessors.sortPostProcessors(internalPostProcessors, beanFactory);registerBeanPostProcessors(beanFactory, internalPostProcessors); 6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中； 创建internalAutoProxyCreator的BeanPostProcessor【(类型为)AnnotationAwareAspectJAutoProxyCreator】 1）、创建Bean的实例 doCreateBean（）553, AbstractAutowireCapableBeanFactory 2）、populateBean；给bean的各种属性赋值 3）、initializeBean：初始化bean； 1）、invokeAwareMethods()：处理Aware接口的方法回调 2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（） 3）、invokeInitMethods()；执行自定义的初始化方法 4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）； 1234567891011121314151617181920212223242526272829303132protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–&gt;aspectJAdvisorsBuilder 12345678protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; super.initBeanFactory(beanFactory); if (this.aspectJAdvisorFactory == null) &#123; this.aspectJAdvisorFactory = new ReflectiveAspectJAdvisorFactory(beanFactory); &#125; this.aspectJAdvisorsBuilder = new AnnotationAwareAspectJAutoProxyCreator.BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, this.aspectJAdvisorFactory);&#125; 7）、把BeanPostProcessor注册到BeanFactory中；registerBeanPostProcessors(beanFactory, internalPostProcessors); 12345678910/** * Register the given BeanPostProcessor beans. */private static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors) &#123; for (BeanPostProcessor postProcessor : postProcessors) &#123; beanFactory.addBeanPostProcessor(postProcessor); &#125;&#125; 2.2.3 创建和注册AnnotationAwareAspectJAutoProxyCreator的过程总结流程总结： 1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor 2）、给容器中加别的BeanPostProcessor 3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor； 4）、再给容器中注册实现了Ordered接口的BeanPostProcessor； 5）、注册没实现优先级接口的BeanPostProcessor； 6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中； 创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 1）、创建Bean的实例 2）、populateBean；给bean的各种属性赋值 3）、initializeBean：初始化bean； 1）、invokeAwareMethods()：处理Aware接口的方法回调 2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（） 3）、invokeInitMethods()；执行自定义的初始化方法 4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）； 4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–&gt;aspectJAdvisorsBuilder 7）、把BeanPostProcessor注册到BeanFactory中；beanFactory.addBeanPostProcessor(postProcessor); 2.3 AnnotationAwareAspectJAutoProxyCreator执行时机finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean 1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);​ getBean-&gt;doGetBean()-&gt;getSingleton()-&gt; 2）、创建bean【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】 1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；只要创建好的Bean都会被缓存起来； 2）、createBean（）;创建bean；AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例 1）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation希望后置处理器在此能返回一个代理对象；后置处理器先尝试返回对象；如果能返回代理对象就使用，如果不能就继续执行第二步doCreateBean(). 拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;就执行postProcessBeforeInstantiation 1234bean = applyBeanPostProcessorsBeforeInstantiation（）：if (bean != null) &#123; bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);&#125; 2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和3.6流程一样； 2.3.1后置处理器区别 BeanPostProcessor是在Bean对象创建完成初始化前后调用的 InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】 2.4 InstantiationAwareBeanPostProcessor的作用2.4.1 postProcessBeforeInstantiation 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()； 1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean） 2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect） 3）、是否需要跳过 1）、获取候选的增强器（切面里面的通知方法）【List candidateAdvisors】，每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true 2）、永远返回false 2.4.2 postProcessAfterInitialization 2）、创建对象 postProcessAfterInitialization； 1234567891011121314return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下1）、获取当前bean的所有增强器（通知方法） Object[] specificInterceptors 1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的） 2、获取到能在bean使用的增强器。 3、给增强器排序2）、保存当前bean在advisedBeans中；3）、如果当前bean需要增强，创建当前bean的代理对象； 1）、获取所有增强器（通知方法） 2）、保存到proxyFactory 3）、创建代理对象：Spring自动决定 JdkDynamicAopProxy(config);jdk动态代理； ObjenesisCglibAopProxy(config);cglib的动态代理；4）、给容器中返回当前组件使用cglib增强了的代理对象；5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程； 2.4.3 目标方法执行3）、目标方法执行 ；​ 容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）； 1）、CglibAopProxy.intercept();拦截目标方法的执行 2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); 1）、List interceptorList保存所有拦截器 5一个默认的ExposeInvocationInterceptor 和 4个增强器； 2）、遍历所有的增强器，将其转为Interceptor；registry.getInterceptors(advisor); 3）、将增强器转为List；如果是MethodInterceptor，直接加入到集合中如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；转换完成返回MethodInterceptor数组； 3）、如果没有拦截器链，直接执行目标方法; 拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制） 4）、如果有拦截器链，把需要执行的目标对象，目标方法， 拦截器链等信息传入创建一个 CglibMethodInvocation 对象， 并调用 Object retVal = mi.proceed(); 5）、拦截器链的触发过程; 1)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法； 2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；拦截器链的机制，保证通知方法与目标方法的执行顺序； 2.4.3.1 拦截器链 3. Spring AOP 源码解析总结 总结： 1）、 @Enabl eAspectJAutoProxy 开启AOP功能 2）、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator 3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器； 4）、容器的创建流程： 1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象 2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean 1）、创建业务逻辑组件和切面组件 2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程 3）、组件创建完之后，判断组件是否需要增强 是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）； 5）、执行目标方法： 1）、代理对象执行目标方法 2）、CglibAopProxy.intercept()； 1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor） 2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行； 3）、效果： 正常执行：前置通知-》目标方法-》后置通知-》返回通知 出现异常：前置通知-》目标方法-》后置通知-》异常通知 4 希望大家手动敲一遍代码，会收获颇丰！5.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Annotation</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（五）-源码解析Spring容器创建过程]]></title>
    <url>%2F2018%2F12%2F10%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%915-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Spring容器的refresh()【创建刷新】; 1. prepareRefresh()刷新前的预处理; 1）、initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法； 2）、getEnvironment().validateRequiredProperties();检验属性的合法等 3）、earlyApplicationEvents= new LinkedHashSet();保存容器中的一些早期的事件； 2. obtainFreshBeanFactory();获取BeanFactory； 1）、refreshBeanFactory();刷新【创建】BeanFactory；​ 创建了一个this.beanFactory = new DefaultListableBeanFactory();​ 设置id； 2）、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象； 3）、将创建的BeanFactory【DefaultListableBeanFactory】返回； 3. BeanFactory的预准备工作prepareBeanFactory(beanFactory);BeanFactory的预准备工作（BeanFactory进行一些设置）； 1）、设置BeanFactory的类加载器、支持表达式解析器… 2）、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】 3）、设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx； 4）、注册可以解析的自动装配；我们能直接在任何组件中自动注入：​ BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext 5）、添加BeanPostProcessor【ApplicationListenerDetector】 6）、添加编译时的AspectJ； 7）、给BeanFactory中注册一些能用的组件；​ environment【ConfigurableEnvironment】、​ systemProperties【Map&lt;String, Object&gt;】、​ systemEnvironment【Map&lt;String, Object&gt;】 4.postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作； 1）、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置======================以上是BeanFactory的创建及预准备工作================================== 5.执行BeanFactoryPostProcessor的方法invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor的方法； BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的； 两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 1）、执行BeanFactoryPostProcessor的方法；​ 先执行BeanDefinitionRegistryPostProcessor​ 1）、获取所有的BeanDefinitionRegistryPostProcessor；​ 2）、看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、​ postProcessor.postProcessBeanDefinitionRegistry(registry)​ 3）、在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor；​ postProcessor.postProcessBeanDefinitionRegistry(registry)​ 4）、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors；​ postProcessor.postProcessBeanDefinitionRegistry(registry)​​ 再执行BeanFactoryPostProcessor的方法​ 1）、获取所有的BeanFactoryPostProcessor​ 2）、看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、​ postProcessor.postProcessBeanFactory()​ 3）、在执行实现了Ordered顺序接口的BeanFactoryPostProcessor；​ postProcessor.postProcessBeanFactory()​ 4）、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor；​ postProcessor.postProcessBeanFactory() 6.注册BeanPostProcessorregisterBeanPostProcessors(beanFactory);注册BeanPostProcessor（Bean的后置处理器）【 intercept bean creation】 ​ 不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的​ BeanPostProcessor、​ DestructionAwareBeanPostProcessor、​ InstantiationAwareBeanPostProcessor、​ SmartInstantiationAwareBeanPostProcessor、​ MergedBeanDefinitionPostProcessor【internalPostProcessors】、​​ 1）、获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级​ 2）、先注册PriorityOrdered优先级接口的BeanPostProcessor；​ 把每一个BeanPostProcessor；添加到BeanFactory中​ beanFactory.addBeanPostProcessor(postProcessor);​ 3）、再注册Ordered接口的​ 4）、最后注册没有实现任何优先级接口的​ 5）、最终注册MergedBeanDefinitionPostProcessor；​ 6）、注册一个ApplicationListenerDetector；来在Bean创建完成后检查是否是ApplicationListener，如果是​ applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean); 7.初始化MessageSource组件initMessageSource();初始化MessageSource组件（做国际化功能；消息绑定，消息解析）； ​ 1）、获取BeanFactory​ 2）、看容器中是否有id为messageSource的，类型是MessageSource的组件​ 如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；​ MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；​ 3）、把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；​ beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);​ MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale); 8.初始化事件派发器；initApplicationEventMulticaster();初始化事件派发器； ​ 1）、获取BeanFactory​ 2）、从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；​ 3）、如果上一步没有配置；创建一个SimpleApplicationEventMulticaster​ 4）、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入 9.onRefresh();留给子容器（子类）​ 1、子类重写这个方法，在容器刷新的时候可以自定义逻辑； 10.registerListeners();registerListeners();给容器中将所有项目里面的ApplicationListener注册进来； ​ 1、从容器中拿到所有的ApplicationListener​ 2、将每个监听器添加到事件派发器中；​ getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);​ 3、派发之前步骤产生的事件； 11.finishBeanFactoryInitializationfinishBeanFactoryInitialization(beanFactory);初始化所有剩下的单实例bean； 1、beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean​ 1）、获取容器中的所有Bean，依次进行初始化和创建对象​ 2）、获取Bean的定义信息；RootBeanDefinition​ 3）、Bean不是抽象的，是单实例的，是懒加载；​ 1）、判断是否是FactoryBean；是否是实现FactoryBean接口的Bean；​ 2）、不是工厂Bean。利用getBean(beanName);创建对象​ 0、getBean(beanName)； ioc.getBean();​ 1、doGetBean(name, null, null, false);​ 2、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）​ 从private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);获取的​ 3、缓存中获取不到，开始Bean的创建对象流程；​ 4、标记当前bean已经被创建​ 5、获取Bean的定义信息；​ 6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】​ 7、启动单实例Bean的创建流程；​ 1）、createBean(beanName, mbd, args);​ 2）、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象；​ 【InstantiationAwareBeanPostProcessor】：提前执行；​ 先触发：postProcessBeforeInstantiation()；​ 如果有返回值：触发postProcessAfterInitialization()；​ 3）、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象；调用4）​ 4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean​ 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args);​ 利用工厂方法或者对象的构造器创建出Bean实例；​ 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);​ 调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);​ 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);​ 赋值之前：​ 1）、拿到InstantiationAwareBeanPostProcessor后置处理器；​ postProcessAfterInstantiation()；​ 2）、拿到InstantiationAwareBeanPostProcessor后置处理器；​ postProcessPropertyValues()；​ =====赋值之前：===​ 3）、应用Bean属性的值；为属性利用setter方法等进行赋值；​ applyPropertyValues(beanName, mbd, bw, pvs);​ 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);​ 1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法​ BeanNameAware\BeanClassLoaderAware\BeanFactoryAware​ 2）、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);​ BeanPostProcessor.postProcessBeforeInitialization（）;​ 3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);​ 1）、是否是InitializingBean接口的实现；执行接口规定的初始化；​ 2）、是否自定义初始化方法；​ 4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization​ BeanPostProcessor.postProcessAfterInitialization()；​ 5）、注册Bean的销毁方法；​ 5）、将创建的Bean添加到缓存中singletonObjects；​ ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。；​ 所有Bean都利用getBean创建完成以后；​ 检查所有的Bean是否是SmartInitializingSingleton接口的；如果是；就执行afterSingletonsInstantiated()； 12.完成BeanFactory的初始化创建工作finishRefresh();完成BeanFactory的初始化创建工作；IOC容器就创建完成； ​ 1）、initLifecycleProcessor();初始化和生命周期有关的后置处理器；LifecycleProcessor​ 默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有new DefaultLifecycleProcessor();​ 加入到容器；​​ 写一个LifecycleProcessor的实现类，可以在BeanFactory​ void onRefresh();​ void onClose();​ 2）、 getLifecycleProcessor().onRefresh();​ 拿到前面定义的生命周期处理器（BeanFactory）；回调onRefresh()；​ 3）、publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件；​ 4）、liveBeansView.registerApplicationContext(this); 13. 总结 1）、Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息；​ 1）、xml注册bean；​ 2）、注解注册Bean；@Service、@Component、@Bean、xxx 2）、Spring容器会合适的时机创建这些Bean​ 1）、用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中；​ 2）、统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()； 3）、后置处理器；BeanPostProcessor​ 1）、每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；​ AutowiredAnnotationBeanPostProcessor:处理自动注入​ AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；​ xxx….​ 增强的功能注解：​ AsyncAnnotationBeanPostProcessor​ …. 4）、事件驱动模型；​ ApplicationListener；事件监听；​ ApplicationEventMulticaster；事件派发：​ 15. 欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（二）-Bean的生命周期]]></title>
    <url>%2F2018%2F12%2F09%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%912-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Bean的生命周期：bean创建—初始化—-销毁的过程 容器管理bean的生命周期；我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法。 1. 指定初始化和销毁方法1.1 xml方式12&lt;bean id="person" class="com.rocklei123.bean.Person" init-method="" destroy-method=""&gt;&lt;/bean&gt; 1.2 注解方式可通过@Bean(initMethod = “init”,destroyMethod = “destroy”)指定初始化及销毁方法，通过测试可以确定： 构造对象： 单实例：在容器启动的时候创建对象 多实例：在每次获取的时候创建对象 初始化： * 对象创建完成，并赋值好，调用初始化方法。 销毁： 单实例：容器关闭的时候 多实例：容器不会管理这个bean；容器不会调用销毁方法； 1.2.1 单实例情况测试123456789101112131415161718192021222324252627public class Car &#123; public Car() &#123; System.out.println("Car...Constructor..."); &#125; public void init() &#123; System.out.println("Car...init..."); &#125; public void destroy() &#123; System.out.println("Car...destroy..."); &#125;&#125;@Configurationpublic class MainConfigLifeCycle &#123; @Bean(initMethod = "init",destroyMethod = "destroy") public Car car() &#123; return new Car(); &#125;&#125;@Testpublic void testLifeCycle() &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfigLifeCycle.class); System.out.println("IOC 容器创建完成!"); context.close();&#125; 通过以下测试结果可以确定Spring容器管理(单实例)Bean的过程为： Bean构造方法–&gt;Bean init()–&gt;IOC容器创建完成–&gt;关闭容器–&gt;Bean销毁 12345678十二月 09, 2018 9:25:32 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Sun Dec 09 21:25:32 CST 2018]; root of context hierarchyCar...Constructor...Car...init...IOC 容器创建完成!十二月 09, 2018 9:25:34 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Sun Dec 09 21:25:32 CST 2018]; root of context hierarchyCar...destroy... 1.2.2多实例情况下测试12345678910111213141516@Configurationpublic class MainConfigLifeCycle &#123; @Bean(initMethod = "init", destroyMethod = "destroy") @Scope(value = "prototype") public Car car() &#123; return new Car(); &#125;&#125;@Testpublic void testLifeCycle() &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfigLifeCycle.class); System.out.println("IOC 容器创建完成!"); Car car = (Car) context.getBean("car"); System.out.println(car); context.close();&#125; 通过以下测试结果可以确定Spring容器管理(多实例)Bean的过程为（多实例注意：不会调用销毁方法）： IOC容器创建完成–&gt;Bean构造方法–&gt;Bean init()–&gt;关闭容器 12345678十二月 14, 2018 10:11:55 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 10:11:55 CST 2018]; root of context hierarchyIOC 容器创建完成!Car...Constructor...十二月 14, 2018 10:11:56 上午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 10:11:55 CST 2018]; root of context hierarchyCar...init...com.rocklei123.bean.Car@77e4c80f 2. 实现InitializingBean和DisposableBean接口Bean实现InitializingBean（定义初始化逻辑）；重写afterPropertiesSet()方法，表示构造方法完成后，并且属性赋值完成后执行该方法 DisposableBean（定义销毁逻辑）;容器销毁时调用 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//实体类package com.rocklei123.bean;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;import org.springframework.stereotype.Component;@Componentpublic class Cat implements InitializingBean, DisposableBean &#123; public Cat() &#123; System.out.println("cat...constructor..."); &#125; @Override public void destroy() throws Exception &#123; System.out.println("cat...destroy..."); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("cat...afterPropertiesSet..."); &#125;&#125;//配置类import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(value = "com.rocklei123.bean")public class MainConfigLifeCycle &#123;&#125;//测试类@Testpublic void testLifeCycleByInterface() &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfigLifeCycle.class); System.out.println("IOC 容器创建完成!"); Cat cat = (Cat) context.getBean("cat"); System.out.println(cat); context.close();&#125; 测试结果： 123456789十二月 14, 2018 3:27:38 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 15:27:37 CST 2018]; root of context hierarchycat...constructor...cat...afterPropertiesSet...十二月 14, 2018 3:27:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 15:27:37 CST 2018]; root of context hierarchyIOC 容器创建完成!com.rocklei123.bean.Cat@61009542cat...destroy... 3. JSR250 @PostConstruct 和@PreDestroy @PostConstruct：在bean创建完成并且属性赋值完成；来执行初始化方法 @PreDestroy：在容器销毁bean之前通知我们进行清理工作 示例代码： 1234567891011121314151617181920import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Componentpublic class Dog &#123; public Dog() &#123; System.out.println("dog...Construct..."); &#125; @PostConstruct public void init()&#123;&#125;&#123; System.out.println("dog...init..."); &#125; @PreDestroy public void destory()&#123; System.out.println("dog...destory..."); &#125;&#125; 测试结果： 123456789101112十二月 14, 2018 3:33:03 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 15:33:03 CST 2018]; root of context hierarchycat...constructor...cat...afterPropertiesSet...dog...init...dog...Construct...十二月 14, 2018 3:33:07 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 15:33:03 CST 2018]; root of context hierarchyIOC 容器创建完成!com.rocklei123.bean.Dog@2ea6137dog...destory...cat...destroy... 4. 实现BeanPostProcessor接口 BeanPostProcessor【interface】：Spring 为我们提供的bean的后置处理器；在bean初始化前后进行一些处理工作；同时可以对这个bean进行包装并返回。 postProcessBeforeInitialization:在任何初始化方法调用之前工作 postProcessAfterInitialization:在任何初始化方法调用之后工作 1234567891011121314151617181920212223242526272829303132333435package com.rocklei123.bean;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.stereotype.Component;/** * @ClassName: MyBeanPostProcessor * @Author: rocklei123 * @Date: 2018/12/14 15:39 * @Description: 后置处理器：初始化前后进行处理工作，将后置处理器加入到容器中 * @Version 1.0 */@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("MyBeanPostProcessor...postProcessBeforeInitialization..." + beanName + "=&gt;" + bean); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("MyBeanPostProcessor...postProcessAfterInitialization..." + beanName + "=&gt;" + bean); return bean; &#125;&#125;//测试代码 @Testpublic void testLifeCycleBeanPostProcessor() &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfigLifeCycle.class); System.out.println("IOC 容器创建完成!"); context.close();&#125; 测试结果： 123456789101112131415161718192021十二月 14, 2018 5:09:06 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 17:09:06 CST 2018]; root of context hierarchyMyBeanPostProcessor...postProcessBeforeInitialization...org.springframework.context.event.internalEventListenerProcessor=&gt;org.springframework.context.event.EventListenerMethodProcessor@7ff2a664MyBeanPostProcessor...postProcessAfterInitialization...org.springframework.context.event.internalEventListenerProcessor=&gt;org.springframework.context.event.EventListenerMethodProcessor@7ff2a664MyBeanPostProcessor...postProcessBeforeInitialization...org.springframework.context.event.internalEventListenerFactory=&gt;org.springframework.context.event.DefaultEventListenerFactory@58c1c010MyBeanPostProcessor...postProcessAfterInitialization...org.springframework.context.event.internalEventListenerFactory=&gt;org.springframework.context.event.DefaultEventListenerFactory@58c1c010MyBeanPostProcessor...postProcessBeforeInitialization...mainConfigLifeCycle=&gt;com.rocklei123.config.MainConfigLifeCycle$$EnhancerBySpringCGLIB$$a5cb492c@b7f23d9MyBeanPostProcessor...postProcessAfterInitialization...mainConfigLifeCycle=&gt;com.rocklei123.config.MainConfigLifeCycle$$EnhancerBySpringCGLIB$$a5cb492c@b7f23d9cat...constructor...MyBeanPostProcessor...postProcessBeforeInitialization...cat=&gt;com.rocklei123.bean.Cat@3f200884cat...afterPropertiesSet...MyBeanPostProcessor...postProcessAfterInitialization...cat=&gt;com.rocklei123.bean.Cat@3f200884dog...init...dog...Construct...MyBeanPostProcessor...postProcessBeforeInitialization...dog=&gt;com.rocklei123.bean.Dog@4d49af10MyBeanPostProcessor...postProcessAfterInitialization...dog=&gt;com.rocklei123.bean.Dog@4d49af10十二月 14, 2018 5:09:11 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@77556fd: startup date [Fri Dec 14 17:09:06 CST 2018]; root of context hierarchyIOC 容器创建完成!dog...destory...cat...destroy... 5. Bean 生命周期管理方法总结 1）、指定初始化和销毁方法；通过@Bean指定init-method和destroy-method； 2）、通过让Bean实现InitializingBean（定义初始化逻辑），DisposableBean（定义销毁逻辑）; 3）、可以使用JSR250； @PostConstruct：在bean创建完成并且属性赋值完成；来执行初始化方法 @PreDestroy：在容器销毁bean之前通知我们进行清理工作 4）、BeanPostProcessor【interface】：bean的后置处理器； 在bean初始化前后进行一些处理工作； postProcessBeforeInitialization:在初始化之前工作 postProcessAfterInitialization:在初始化之后工作 6. BeanPostProcessor介绍与原理BeanPostProcessor 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory //给bean进行属性赋值 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; // this.populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = this.initializeBean(beanName, exposedObject, mbd); &#125; &#125; //初始化bean protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; AbstractAutowireCapableBeanFactory.this.invokeAwareMethods(beanName, bean); return null; &#125; &#125;, this.getAccessControlContext()); &#125; else &#123; this.invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //执行初始化前的方法 wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName); &#125; try &#123; //执行自定义初始化 this.invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable var6) &#123; throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, "Invocation of init method failed", var6); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; //执行初始化之后的方法 wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; BeanPostProcessor核心原理总结1234567populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值initializeBean&#123; applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化 applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);&#125; Spring底层大量 BeanPostProcessor 的使用；比如bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async,xxx BeanPostProcessor; 6.1 ApplicationContextAwareProcessor 后置处理器ApplicationContextAwareProcessor 接口，是Spring容器提供获取IOC容器接口，其内部实现也是后置处理器原理。示例代码： 12345678public class Dog implements ApplicationContextAware &#123; private ApplicationContext context; @Override //业务代码注入IOC容器 public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.context = applicationContext; &#125;&#125; 7. Bean生命周期总结 构造（对象创建） 12* 单实例：在容器启动的时候创建对象* 多实例：在每次获取的时候创建对象 BeanPostProcessor.postProcessBeforeInitialization 初始化： 1* 对象创建完成，并赋值好，调用初始化方法。。。 BeanPostProcessor.postProcessAfterInitialization 销毁： 12* 单实例：容器关闭的时候* 多实例：容器不会管理这个bean；容器不会调用销毁方法； 其实Spring容器整个生命周期还有其他几个步骤，下图给出整个Spring容器管理bean的生命周期。 8.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（三）-属性赋值和自动装配]]></title>
    <url>%2F2018%2F12%2F01%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%913-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.属性赋值1.1 @Value使用@Value注解赋值； 基本数值 可以写Spring的EL表达式; #{} 可以写${}；取出配置文件【properties】中的值（在运行环境变量里面的值） 1.2 @PropertySource 使用@PropertySource读取外部配置文件中的k/v保存到运行的环境变量中; 加载完外部的配置文件以后使用${}取出配置文件的值 @PropertySource(value={“classpath:/person.properties”}) 数组类型，可以支持一次性引入多个文件。 另外@PropertySource 是一个可重复的注解，可以使用@PropertySources注解引入多个@PropertySource标注的properties配置文件 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface PropertySources &#123; PropertySource[] value();&#125; 测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//实体类信息package com.rocklei123.bean;import org.springframework.beans.factory.annotation.Value;/** * @ClassName: Person * @Author: rocklei123 * @Date: 2018/12/1 21:27 * @Description: TODO * @Version 1.0 */public class Person &#123; @Value(value = "张三") private String name; @Value(value = "#&#123;20-2&#125;") private Integer age; @Value(value = "$&#123;person.nickName&#125;") private String nickName; public Person() &#123; System.out.println("Person默认构造方法"); &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + ", nickName='" + nickName + '\'' + '&#125;'; &#125;&#125;//配置类信息package com.rocklei123.config;import com.rocklei123.bean.Person;import org.springframework.context.annotation.*;@PropertySource(value = &#123;"classpath:/person.properties"&#125;)@Configurationpublic class MainConfigOfPropertyValues &#123; @Bean public Person person() &#123; return new Person(); &#125;&#125;//测试类信息public class IocTestOfPropertyValues &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfPropertyValues.class); public void printBean(ApplicationContext applicationContext) &#123; String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; Object o = applicationContext.getBean(beanDefinitionName); System.out.println(o); &#125; &#125; @Test public void testValue() &#123; printBean(applicationContext); Environment environment = applicationContext.getEnvironment(); String nickName = environment.getProperty("person.nickName"); System.out.println("环境信息中property=" + nickName); &#125;&#125; 测试结果： 12Person&#123;name=&apos;张三&apos;, age=18, nickName=&apos;小李四&apos;&#125;环境信息中property=小李四 2.自动装配自动装配; Spring利用依赖注入（DI），完成对IOC容器中中各个组件的依赖关系赋值； 2.1 @Autowired、@Qualifier、@Primary2.1.1 @Autowired2.1.1.1 概念性总结 概念：Spring 2.5 引入了 @Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。 原理：其实在启动spring IOC容器时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。 注意事项： 1）、默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值 2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查 applicationContext.getBean(“bookDao”)所以容器中有多个相同组件时，名称不应该乱起。 3）、自动装配默认一定要将属性赋值好，没有就会报错；可以使用@Autowired(required=false);默认required=true 2.1.1.2 默认注入情况测试默认注入情况：名字默认是类名首字母小写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//service 层代码，自动注入dao层@Servicepublic class BookService &#123; @Autowired BookDao bookDao; @Override public String toString() &#123; return "BookService&#123;" + "bookDao=" + bookDao + '&#125;'; &#125;&#125;//dao层代码，加入一个默认名称区别@Repositorypublic class BookDao &#123; private String nameFlag = "1"; public BookDao() &#123; &#125; public BookDao(String nameFlag) &#123; this.nameFlag = nameFlag; &#125; public String getNameFlag() &#123; return nameFlag; &#125; public void setNameFlag(String nameFlag) &#123; this.nameFlag = nameFlag; &#125; @Override public String toString() &#123; return "BookDao&#123;" + "nameFlag='" + nameFlag + '\'' + '&#125;'; &#125;&#125;//配置类，向容器中注入另一个bookDao，名称为BookDao2@ComponentScan(value = &#123;"com.rocklei123.service", "com.rocklei123.controller", "com.rocklei123.repository"&#125;)@Configurationpublic class MainConfigOfAutowired &#123; @Bean(value = "bookDao2") public BookDao bookDao2(BookDao bookDao) &#123; BookDao bookDao2 = new BookDao(); bookDao2.setNameFlag("2"); return bookDao2; &#125;&#125;//测试类public class IocTestOfAutowired &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class); @Test public void testValue() &#123; BookService bean = applicationContext.getBean(BookService.class); System.out.println(bean); &#125;&#125; 测试结果:通过上文注意事项可知，Spring容器注入时会先通过类型找到两个BookDao类型的对象，第二次会通过 默认是类名首字母小写在查找一次。故Service层注入的BookDao对象应该为nameFlag = “1”; 的对象 12信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@4aa8f0b4: startup date [Sat Dec 15 18:56:29 CST 2018]; root of context hierarchyBookService&#123;bookDao=BookDao&#123;nameFlag=&apos;1&apos;&#125;&#125; 如果此时修改测试类使用IOC容器按类型获取BookDao此时，因为容器中有两个BookDao类型的对象，当打印时就会报错。 12345678@Testpublic void testValue() &#123; BookDao bean = applicationContext.getBean(BookDao.class); System.out.println(bean);&#125;//异常信息org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.rocklei123.repository.BookDao' available: expected single matching bean but found 2: bookDao,bookDao2 2.1.1.3 @Autowired(required=false)自动装配默认一定要将属性赋值好，没有就会报错；可以使用@Autowired(required=false); 1234567@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123; boolean required() default true;&#125;默认required 为true 测试用例 1234567891011121314151617//业务层代码，自动注入Dao层对象，required = falsepublic class BookService &#123; @Qualifier(value = "bookDao2") @Autowired(required = false) BookDao bookDao;&#125;//将BookDao不注入到容器中//虽然容器中不含有BookDao,通过测试类打印业务层代码时，也不会报错。@Testpublic void testValue() &#123; BookService bean = applicationContext.getBean(BookService.class); System.out.println(bean);&#125;//测试结果BookService&#123;bookDao=null&#125; 2.1.1.4 @Autowired:构造器，参数，方法，属性@Autowired:构造器，参数，方法，属性；都是从容器中获取参数组件的值 默认情况说明： @Bean标注的方法创建对象的时候，方法参数的值从容器中获取 默认加在ioc容器中的组件，容器启动会调用无参构造器创建对象，再进行初始化赋值等操作 @Autowired标注说明： 1）、[标注在方法位置]：@Bean+方法参数；参数从容器中获取;默认不写@Autowired效果是一样的；都能自动装配 2）、[标在构造器上]：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取. 3）、放在参数位置： 2.1.2 @Qualifier​ @Qualifier(“XXX”) Spring的Bean注入配置注解，该注解指定注入的Bean的名称，Spring框架使用byName方式寻找合格的bean，这样就消除了byType方式产生的歧义。 ​ @Qualifier(“bookDao”)：使用@Qualifier指定需要装配的组件的id，而不是使用属性名。@Qualifier需要和 @Autowired一起使用。 1234567public class BookService &#123; @Qualifier(value = "bookDao2") //指定装配组件的Id为bookDao2 @Autowired BookDao bookDao;&#125;//测试结果BookService&#123;bookDao=BookDao&#123;nameFlag='2'&#125;&#125; 2.1.3 @Primary​ @Primary：让Spring进行自动装配的时候，默认使用首选的bean；也可以继续使用@Qualifier指定需要装配的bean的名字。 ​ 通过下面的示例也可以看出@Primary和@Qualifier 在一定程度上有所冲突，如果我们service层代码使用@Qualifier指定注入名称，即使在相同类型的其他Bean 上标注@Primary，Spring注入Service层的也是根据@Qualifier标注注入的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class BookService &#123; @Qualifier(value = "bookDao") @Autowired(required = false) BookDao bookDao; @Override public String toString() &#123; return "BookService&#123;" + "bookDao=" + bookDao + '&#125;'; &#125;&#125;@ComponentScan(value = &#123;"com.rocklei123.service", "com.rocklei123.controller", "com.rocklei123.repository"&#125;)@Configurationpublic class MainConfigOfAutowired &#123; @Primary @Bean(value = "bookDao2") public BookDao bookDao2(BookDao bookDao) &#123; BookDao bookDao2 = new BookDao(); bookDao2.setNameFlag("2"); return bookDao2; &#125;&#125;//测试代码public class IocTestOfAutowired &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAutowired.class); public void printBean(ApplicationContext applicationContext) &#123; String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; Object o = applicationContext.getBean(beanDefinitionName); System.out.println(o); &#125; &#125; @Test public void testValue() &#123; printBean(applicationContext); System.out.println("-----------------------------------"); BookService bean = applicationContext.getBean(BookService.class); System.out.println(bean); &#125;&#125; 测试结果:可以看出Spring容器加载了两个BookDao类型的bean,向Serveice层注入的是 @Qualifier(value = “bookDao”)标注的。 1234567com.rocklei123.config.MainConfigOfAutowired$$EnhancerBySpringCGLIB$$7d34398f@37e547daBookService&#123;bookDao=BookDao&#123;nameFlag=&apos;1&apos;&#125;&#125;com.rocklei123.controller.BookController@5db45159BookDao&#123;nameFlag=&apos;1&apos;&#125;BookDao&#123;nameFlag=&apos;2&apos;&#125;-----------------------------------BookService&#123;bookDao=BookDao&#123;nameFlag=&apos;1&apos;&#125;&#125; 2.2 @Resource(JSR250)和@Inject(JSR330)Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解] 2.2.1 @Resource: 可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的； 没有能支持@Primary功能 没有支持@Autowired（reqiured=false）; 12345@Servicepublic class BookService &#123; @Resource(name = "bookDao2") BookDao bookDao;&#125; 2.2.2 @Inject:​ @Inject支持构造函数、方法和字段注解，也可能使用于静态实例成员。可注解成员可以是任意修饰符（private,package-private,protected,public）。注入顺序：构造函数、字段，然后是方法。父类的字段和方法注入优先于子类的字段和方法，同一类中的字段和方法是没有顺序的。 需要导入javax.inject的包，和Autowired的功能一样。没有required=false的功能；但是支持@Primary 123456&lt;!-- https://mvnrepository.com/artifact/javax.inject/javax.inject --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; 2.3 @Autowired 和 @Resource、@Inject 的区别相同点 @Autowired和@Inject基本是一样的，因为两者都是使用AutowiredAnnotationBeanPostProcessor来处理依赖注入。但是@Resource是个例外，它使用的是CommonAnnotationBeanPostProcessor来处理依赖注入。当然，两者都是BeanPostProcessor。 三个注解都能实现自动装配功能 不同点 注解定义不同 @Autowired:Spring定义的，脱离Spring框架就没有了； @Resource、@Inject都是java规范，其他IOC框架也会支持。 默认注入方式不同 @Autowired和@Inject： 默认 autowired by type，可以通过@Qualifier 显式指定； @Resource：默认 autowired by field name，如果 autowired by field name失败，会退化为 autowired by type；可以 通过@Qualifier 显式指定 autowired by qualifier name；如果 autowired by qualifier name失败，会退化为 autowired by field name。 功能性差异 @Resource 没有能支持@Primary功能;没有支持@Autowired（reqiured=false）功能; @Inject 虽然支持@Primary功能功能，但是不支持@Autowired（reqiured=false）功能; @Autowired支持@Primary功能，@Autowired（reqiured=false）功能； 2.4 自定义组件注入Spring容器底层的一些组件2.4.1 xxxAware介绍自定义组件实现xxxAware接口，在创建对象的时候，会调用接口规定的方法注入相关组件；xxxxAware接口把Spring底层一些组件注入到自定义的Bean中； 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.rocklei123.bean;import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.config.EmbeddedValueResolver;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.context.EmbeddedValueResolverAware;import org.springframework.context.EnvironmentAware;import org.springframework.core.env.Environment;import org.springframework.stereotype.Component;import org.springframework.util.StringValueResolver;/** * @ClassName: Apple * @Author: rocklei123 * @Date: 2018/12/15 20:46 * @Description: 自定义组件注入Spring容器底层的一些组件 * @Version 1.0 */@Componentpublic class Apple implements ApplicationContextAware, BeanNameAware, EnvironmentAware, EmbeddedValueResolverAware &#123; private ApplicationContext applicationContext; @Override public void setBeanName(String s) &#123; System.out.println("当前Bean的名称：" + s); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println("传入的IOC:" + applicationContext); this.applicationContext = applicationContext; &#125; @Override public void setEnvironment(Environment environment) &#123; System.out.println("当前person.properties文件中的昵称名：" + environment.getProperty("person.nickName")); &#125; @Override public void setEmbeddedValueResolver(StringValueResolver stringValueResolver) &#123; String s = stringValueResolver.resolveStringValue("我的操作系统类型$&#123;os.name&#125;,我的年龄#&#123;26+1&#125;"); System.out.println(s); &#125;&#125;//配置类@PropertySource(value = &#123;"classpath:/person.properties"&#125;)@ComponentScan(value = &#123;"com.rocklei123.bean", "com.rocklei123.service", "com.rocklei123.controller", "com.rocklei123.repository"&#125;)@Configurationpublic class MainConfigOfAutowired &#123; @Primary @Bean(value = "bookDao2") public BookDao bookDao2(BookDao bookDao) &#123; BookDao bookDao2 = new BookDao(); bookDao2.setNameFlag("2"); return bookDao2; &#125;&#125;//测试结果当前Bean的名称：apple当前person.properties文件中的昵称名：小李四我的操作系统类型Windows 10,我的年龄27传入的IOC:org.springframework.context.annotation.AnnotationConfigApplicationContext@1e81f4dc: startup date [Sat Dec 15 20:57:18 CST 2018]; root of context hierarchy 2.4.2 xxxAware底层原理 xxxAware原理：功能使用xxxProcessor，通过后置处理器功能实现； 如： ApplicationContextAware==》ApplicationContextAwareProcessor； 以ApplicationContextAwareProcessor为例源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package org.springframework.context.support;class ApplicationContextAwareProcessor implements BeanPostProcessor &#123; private final ConfigurableApplicationContext applicationContext; private final StringValueResolver embeddedValueResolver; public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123; AccessControlContext acc = null; if (System.getSecurityManager() != null &amp;&amp; (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123; acc = this.applicationContext.getBeanFactory().getAccessControlContext(); &#125; if (acc != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; ApplicationContextAwareProcessor.this.invokeAwareInterfaces(bean); return null; &#125; &#125;, acc); &#125; else &#123; this.invokeAwareInterfaces(bean); &#125; return bean; &#125; private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware)bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext); &#125; &#125; &#125; public Object postProcessAfterInitialization(Object bean, String beanName) &#123; return bean; &#125;&#125; 3 希望大家手动敲一遍代码，会收获颇丰！4.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（一）-Bean注入相关注解]]></title>
    <url>%2F2018%2F12%2F01%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%911-Bean%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.介绍1.1 目标通过本系列文章能够熟悉并掌握Spring注解驱动开发。本小结将介绍通过注解给容器中注册组件；通过本小结，将了解如下注解： AnnotationConfigApplicationContext 组件添加 @ComponentScan @Bean @PostConstruct @PreDestroy BeanPostProcessor @Configuration @Component @Service @Controller @Repository @Conditional @Primary @Lazy @Scope @Import ImportSelector FactoryBean 1.2 环境信息环境信息如下：1234567891011121314151617&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.20.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 2.传统方式使用spring配置文件的方式给容器注入bean （1）定义一个Java类，如定义一个Person类 123public class Person &#123; private String name; private Integer age; （2）在maven工程的resources文件夹下定义XML文件，如定义beans.xml，并在xml文件中引入命名空间，同时定义bean组件，即Person类的Bean。 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 传统方法使用spring配置文件的方式--&gt; &lt;bean id="person" class="com.rocklei123.bean.Person"&gt; &lt;property name="name" value="zhangsan"&gt;&lt;/property&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; （3）通过ApplicationContext 获取bean，并打印，代码如下： 12345678public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:beans.xml"); Person p = (Person) applicationContext.getBean("person"); System.out.println(p); &#125; 执行结果为Person&#123;name='zhangsan', age=18&#125; 3.注解式开发-通过配置类方式给容器注入bean （1）定义@Configuration 注解标注的配置类，告诉Spring这是一个配置类。 （2）通过@Bean 注解给容器中注册一个Bean;类型返回值的类型，id默认是用方法名作为id。也可以通过value属性重新定义id。 123456789101112131415161718192021222324package com.rocklei123.config;import com.rocklei123.bean.Person;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @ClassName: MainConfig * @Author: rocklei123 * @Date: 2018/12/1 22:05 * @Description: * @Version 1.0 */@Configurationpublic class MainConfig &#123; //给容器中注册一个Bean;类型返回值的类型，id默认是用方法名作为id。也可以通过value属性重新定义id @Bean(value = "person1") public Person person() &#123; return new Person("lisi", 26); &#125;&#125; 通过AnnotationConfigApplicationContext 类型的上下文获取bean，测试结果如下：12345ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);Person p = (Person) applicationContext.getBean("person1");System.out.println(p);//结果为Person&#123;name='lisi', age=26&#125; 4.@ComponentScan包扫描4.1 原有配置文件方式包扫描：12&lt;!--包扫描:只要标注了@Controller、@Service、@Repository、@Component--&gt; &lt;context:component-scan base-package="com.rocklei123"&gt;&lt;/context:component-scan&gt; 4.2 @ComponentScan基本使用注解方式通过@ComponentScan(value = “com.rocklei123”)设置，value指定要扫描的包 1234567891011121314151617181920212223242526272829303132@Configuration@ComponentScan(value = "com.rocklei123")public class MainConfig &#123; //给容器中注册一个Bean;类型返回值的类型，id默认是用方法名作为id。也可以通过value属性重新定义id @Bean(value = "person1") public Person person() &#123; return new Person("lisi", 26); &#125;&#125;@Test public void printBean() &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();//idea 快捷键Ctrl + ALT + V自动补全方法返回值 for (String beanDefinitionName : beanDefinitionNames) &#123; //idea 快捷iter 自动生成for each循环体 System.out.println(beanDefinitionName); &#125; &#125;执行结果：org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigpersonControllerpersonRepositorypersonServiceperson1 4.3 @ComponentScan高级用法-ComponentScans 等介绍 @ComponentScans通过源码可以需要封装ComponentScan[]，即可以定义多个ComponentScan includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件 excludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件 FilterType.ANNOTATION：按照注解 FilterType.ASSIGNABLE_TYPE：按照给定的类型； FilterType.ASPECTJ：使用ASPECTJ表达式 FilterType.REGEX：使用正则指定 FilterType.CUSTOM：使用自定义规则 4.4 includeFilters includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件 示例1 ：只包含Controller注解的类注入到Spring容器中 123456789101112131415@Configuration@ComponentScans(value = &#123;@ComponentScan(value = "com.rocklei123", includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;, useDefaultFilters = false)&#125;)public class MainConfig &#123; //给容器中注册一个Bean;类型返回值的类型，id默认是用方法名作为id。也可以通过value属性重新定义id @Bean(value = "person1") public Person person() &#123; return new Person("lisi", 26); &#125;&#125;结果（不计入Spring本身的类）：mainConfigpersonControllerperson1 4.5 excludeFilters excludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件 useDefaultFilters 默认为true 示例2 ：所有PersonService 类型（包括子类）注不入到Spring容器中 12345678910111213141516@Configuration@ComponentScans(value = &#123;@ComponentScan(value = "com.rocklei123", excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;PersonService.class&#125;)&#125;)&#125;)public class MainConfig &#123; //给容器中注册一个Bean;类型返回值的类型，id默认是用方法名作为id。也可以通过value属性重新定义id @Bean(value = "person1") public Person person() &#123; return new Person("lisi", 26); &#125;&#125;结果（不计入Spring本身的类）：mainConfigpersonControllerpersonRepositoryperson1 4.6 自定义TypeFilter示例3 ：只包含Controller注解的类、PersonService类或其子类、及匹配自定义注解的类。注入到Spring容器中 1234567891011@Configuration@ComponentScans(value = &#123;@ComponentScan(value = "com.rocklei123", includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;PersonService.class&#125;), @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;), @ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)&#125;, useDefaultFilters = false)&#125;)public class MainConfig &#123; //给容器中注册一个Bean;类型返回值的类型，id默认是用方法名作为id。也可以通过value属性重新定义id @Bean(value = "person1") public Person person() &#123; return new Person("lisi", 26); &#125;&#125; 自定义过滤规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.rocklei123.config;import org.springframework.core.io.Resource;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.ClassMetadata;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.core.type.filter.TypeFilter;import java.io.IOException;/** * @ClassName: MyTypeFilter * @Author: rocklei123 * @Date: 2018/12/1 23:23 * @Description: TODO * @Version 1.0 */public class MyTypeFilter implements TypeFilter &#123; //metadataReader:读取当前正在扫描的类的信息 //metadataReaderFactory:读取任何类的信息 @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); ClassMetadata classMetadata = metadataReader.getClassMetadata(); Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); System.out.println("----》" + className); if (className.contains("tory")) &#123; return true; &#125; return false; &#125;&#125;//结果----》com.rocklei123.IocTest----》com.rocklei123.bean.Person----》com.rocklei123.config.MyTypeFilter----》com.rocklei123.MainTest----》com.rocklei123.repository.PersonRepositoryorg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigpersonControllerpersonRepositorypersonServiceperson1 5. @Scope@Scope:注解可以调整作用域 prototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。每次获取的时候才会调用方法创建对象； singleton：单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。以后每次获取就是直接从容器（map.get()）中拿。 request：同一次请求创建一个实例 session：同一个session创建一个实例 默认是单实例的 1234* ConfigurableBeanFactory#SCOPE_PROTOTYPE* @see ConfigurableBeanFactory#SCOPE_SINGLETON* @see org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST request* @see org.springframework.web.context.WebApplicationContext#SCOPE_SESSION sesssion 5.1 singleton（默认）测试示例123456789101112131415161718192021@Configurationpublic class MainConfig2 &#123; @Bean public Person person() &#123; System.out.println("给容器中添加person bean..."); return new Person("wangwu", 18); &#125;&#125;@Test public void test2() &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); //从容器获取的Bean为一个bean实例 Person person1 = (Person) applicationContext.getBean("person"); Person person2 = (Person) applicationContext.getBean("person"); System.out.println(person1 == person2); &#125; //测试结果 给容器中添加person bean... true 5.2 @Scope(value = “prototype”)测试示例1234567891011121314151617181920212223@Configurationpublic class MainConfig2 &#123; @Bean @Scope(value = "prototype") public Person person() &#123; System.out.println("给容器中添加person bean..."); return new Person("wangwu", 18); &#125;&#125;@Testpublic void test2() &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); Person person1 = (Person) applicationContext.getBean("person"); Person person2 = (Person) applicationContext.getBean("person"); System.out.println(person1 == person2);&#125; //结果 给容器中添加person bean... 给容器中添加person bean... false 6.@Lazy 注解懒加载： 单实例bean：默认在容器启动的时候创建对象； 懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化； 通过以下测试代码，可以很清楚的看到容器启动不创建对象。第一次使用(获取)Bean创建对象。测试代码如下： 123456789101112131415161718192021222324252627282930@Configurationpublic class MainConfig2 &#123; @Bean @Lazy public Person person() &#123; System.out.println("给容器中添加person bean..."); return new Person("wangwu", 18); &#125;&#125;@Testpublic void testLazy() &#123; System.out.println("IOC容器准备初始化..."); ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); System.out.println("IOC容器初始化已经完成...打印当前容器中的Bean名称"); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();//idea 快捷键Ctrl + ALT + V自动补全方法返回值 for (String beanDefinitionName : beanDefinitionNames) &#123; //idea 快捷iter 自动生成for each循环体 System.out.println(beanDefinitionName); &#125; System.out.println("通过applicationContext.getBean方法获取Person Bean"); System.out.println("Person Bean Lazy注解标注的Bean添加到容器中..."); Person person = (Person) applicationContext.getBean("person"); System.out.println("打印当前容器中的Bean名称..."); String[] beanDefinitionNames2 = applicationContext.getBeanDefinitionNames();//idea 快捷键Ctrl + ALT + V自动补全方法返回值 for (String beanDefinitionName : beanDefinitionNames2) &#123; //idea 快捷iter 自动生成for each循环体 System.out.println(beanDefinitionName); &#125;&#125; 测试结果（过滤Spring自动注入容器的的Bean打印信息）12345678910IOC容器准备初始化...IOC容器初始化已经完成...打印当前容器中的Bean名称mainConfig2person通过applicationContext.getBean方法获取Person BeanPerson Bean Lazy注解标注的Bean添加到容器中...给容器中添加person bean...打印当前容器中的Bean名称...mainConfig2person 7.@Conditional7.1 @Conditional 注解介绍@Conditional 注解： 按照一定的条件进行判断，满足条件给容器中注册bean 可通过实现org.springframework.context.annotation.Condition接口，重写public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)方法，判断是否加入容器中。返回true表示条件成立，向容器中注入Bean。 ConditionContext conditionContext 判断条件能使用的上下文 AnnotatedTypeMetadata annotatedTypeMetadata 注释信息 12345678//1、能获取到ioc使用的beanfactoryConfigurableListableBeanFactory beanFactory = context.getBeanFactory();//2、获取类加载器ClassLoader classLoader = context.getClassLoader();//3、获取当前环境信息Environment environment = context.getEnvironment();//4、获取到bean定义的注册类BeanDefinitionRegistry registry = context.getRegistry(); 7.2 @Conditional 注解示例本例根据操作系统环境信息 os.name 确定加载的Person Bean信息。因为开发环境为Windows 10 操作系统，故本例结果将加载Person Bean为bill。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class LinuxCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment environment = conditionContext.getEnvironment(); String property = environment.getProperty("os.name"); if (property.contains("Linux") || property.contains("linux")) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;public class WinCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment environment = conditionContext.getEnvironment(); String property = environment.getProperty("os.name"); if (property.contains("Windows") || property.contains("win")) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;@Configurationpublic class MainConfig3 &#123; @Bean @Lazy public Person person() &#123; System.out.println("给容器中添加person bean..."); return new Person("wangwu", 18); &#125; /** * @return * @Conditional() 根据条件进行判断，满足条件加入到容器中 */ @Bean @Conditional(value = WinCondition.class) public Person person1() &#123; return new Person("bill", 43); &#125; @Bean @Conditional(value = LinuxCondition.class) public Person person2() &#123; return new Person("linus", 44); &#125;&#125; @Test public void testCondition() &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig3.class); Environment environment = applicationContext.getEnvironment(); String property = environment.getProperty("os.name"); System.out.println("环境信息为:" + property); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; Object bean = applicationContext.getBean(beanDefinitionName); System.out.println(bean); &#125; &#125; 运行结果(过滤Spring自动注入的类) 12345环境信息为:Windows 10com.rocklei123.config.MainConfig3$$EnhancerBySpringCGLIB$$bddb8d66@1e67a849给容器中添加person bean...Person&#123;name=&apos;wangwu&apos;, age=18&#125;Person&#123;name=&apos;bill&apos;, age=43&#125; 8.@Import@Import[快速给容器中导入一个组件] 1）、@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名 2）、ImportSelector:返回需要导入的组件的全类名数组； 3）、ImportBeanDefinitionRegistrar:手动注册bean到容器中 8.1 @Import 使用@Import 的Value是一个Class[] 数组，可以传入多个值，也可以传入单个值。 123public @interface Import &#123; Class&lt;?&gt;[] value();&#125; 向Spring容器中导入一个Color组件 12345678910111213141516171819202122232425public class Color &#123;&#125;@Configuration@Import(value = Color.class)public class MainConfigImport &#123;&#125;public class IocTest &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigImport.class); public void printBean(ApplicationContext applicationContext ) &#123; String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; System.out.println(beanDefinitionName); &#125; &#125; @Test public void testImport()&#123; printBean(applicationContext ); &#125;&#125; 测试结果 12mainConfigImportcom.rocklei123.bean.Color 8.2 ImportSelector接口ImportSelector 自定义逻辑返回需要导入的组件。返回值，就是到导入到容器中的组件全类名，方法不要返回null值，否则报空指针。 123456789101112131415public class MyImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; //AnnotationMetadata:当前标注@Import注解的类的所有注解信息 String className = annotationMetadata.getClassName(); System.out.println("---------" + className); return new String[]&#123;"com.rocklei123.bean.Red", "com.rocklei123.bean.Yellow"&#125;; &#125;&#125;@Configuration@Import(&#123;Color.class, MyImportSelector.class&#125;)public class MainConfigImport &#123;&#125; 测试结果 12345---------com.rocklei123.config.MainConfigImportmainConfigImportcom.rocklei123.bean.Colorcom.rocklei123.bean.Redcom.rocklei123.bean.Yellow 8.3 ImportBeanDefinitionRegistrar接口 AnnotationMetadata：当前类的注解信息 BeanDefinitionRegistry:BeanDefinition注册类； 把所有需要添加到容器中的bean；调用BeanDefinitionRegistry.registerBeanDefinition手工注册进来 1234567891011121314151617181920212223242526272829303132package com.rocklei123.importSelector;import com.rocklei123.bean.RainBow;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.type.AnnotationMetadata;/** * @ClassName: MyImportBeanDefinitionRegistrar * @Author: rocklei123 * @Date: 2018/12/9 14:15 * @Description: TODO * @Version 1.0 */public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; boolean a = beanDefinitionRegistry.containsBeanDefinition("com.rocklei123.bean.Red"); boolean b = beanDefinitionRegistry.containsBeanDefinition("com.rocklei123.bean.Yellow"); if (a &amp;&amp; b) &#123; RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class); beanDefinitionRegistry.registerBeanDefinition("rainBow", rootBeanDefinition); &#125; &#125;&#125;@Configuration@Import(&#123;Color.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)public class MainConfigImport &#123;&#125; 9 FactoryBean 接口通过实现Spring提供的FactoryBean，将Bean注入到容器中。 9.1 FactoryBean方法介绍12345678910111213141516171819@Override//获取到的是工厂bean调用getObject创建的对象,将该对象注入到容器中public Color getObject() throws Exception &#123; System.out.println("ColorFactoryBean...getObject..."); return new Color();&#125;@Override//返回对象的类型public Class&lt;?&gt; getObjectType() &#123; return Color.class;&#125;@Override//true：这个bean是单实例，在容器中保存一份//false：多实例，每次获取都会创建一个新的bean；public boolean isSingleton() &#123; return true;&#125; 9.2 要获取工厂Bean本身 我们需要给id前面加一个&amp;（如&amp;colorFactoryBean） 12public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = "&amp;"; 9.3 FactoryBean测试代码及结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.springframework.beans.factory.FactoryBean;/** * @ClassName: ColorFactoryBean * @Author: rocklei123 * @Date: 2018/12/9 19:41 * @Description: TODO * @Version 1.0 */public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; @Override public Color getObject() throws Exception &#123; System.out.println("ColorFactoryBean...getObject..."); return new Color(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Color.class; &#125; @Override public boolean isSingleton() &#123; return true; &#125;&#125;@Configurationpublic class MainConfigBeanFactory &#123; @Bean public ColorFactoryBean colorFactoryBean() &#123; return new ColorFactoryBean(); &#125;&#125; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigBeanFactory.class);@Testpublic void testFactoryBean() &#123; printBean(applicationContext); Object colorFactoryBean1 = applicationContext.getBean("colorFactoryBean"); Object colorFactoryBean2 = applicationContext.getBean("colorFactoryBean"); System.out.println("colorFactoryBean1=" + colorFactoryBean1 + ",colorFactoryBeanType=" + colorFactoryBean1 .getClass()); System.out.println("colorFactoryBean2=" + colorFactoryBean2 + ",colorFactoryBeanType=" + colorFactoryBean2 .getClass()); System.out.println(colorFactoryBean1 == colorFactoryBean2); Object bean = applicationContext.getBean("&amp;colorFactoryBean"); System.out.println(bean.getClass());&#125; 测试结果： 1234567mainConfigBeanFactorycolorFactoryBeanColorFactoryBean...getObject...colorFactoryBean1=com.rocklei123.bean.Color@4461c7e3,colorFactoryBeanType=class com.rocklei123.bean.ColorcolorFactoryBean2=com.rocklei123.bean.Color@4461c7e3,colorFactoryBeanType=class com.rocklei123.bean.Colortrueclass com.rocklei123.bean.ColorFactoryBean 10. Spring容器注册组件总结给容器中注册组件； 1）、包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类] 2）、@Bean[导入的第三方包里面的组件] 3）、@Import[快速给容器中导入一个组件] 1）、@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名 2）、ImportSelector:返回需要导入的组件的全类名数组； 3）、ImportBeanDefinitionRegistrar:手动注册bean到容器中 4）、使用Spring提供的FactoryBean（工厂Bean）; 1）、默认获取到的是工厂bean调用getObject创建的对象 2）、要获取工厂Bean本身，我们需要给id前面加一个&amp;（如&amp;colorFactoryBean） 11. 希望大家手动敲一遍代码，会收获颇丰！12. 欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列(六)-SpringBoot与数据访问]]></title>
    <url>%2F2018%2F11%2F21%2FSpringBoot%E7%B3%BB%E5%88%97-%E5%85%AD-SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[1. 2.新建项目 （1） 使用idea工具中的Spring Initialzer 新建Springboot项目 （2）选择项目依赖 （3）依赖配置pom.xml 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 9 希望大家手动敲一遍代码，会收获颇丰！10.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之-代理模式]]></title>
    <url>%2F2018%2F10%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.目标随着对spring框架的了解，代理模式在其中发乎了很大作用，要想更好的理解spring的核心之一AOP需要对代理模式有一些了解。通过本本能够更好的理解代理模式设计思想、应用实例、优缺点、与适配器模式的不同、JDK动态代理、Cglib动态代理。 2.介绍2.1 概述在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。一句话总结： 为其他对象提供一种代理以控制对这个对象的访问。代理对象起到中介作用，可去掉功能服务或增加额外的服务。 2.2 代理模式详细理解 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 2.3 实际用途 1、Windows 里面的快捷方式。 2、买火车票不一定在火车站买，也可以去代售点。 3、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 4、spring aop。 2.4 代理模式优缺点 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 2.5 按使用场景分类使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 2.6 与适配器模式和装饰器模式的不同 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 适配器模式是因为新旧接口不一致导致出现了客户端无法得到满足的问题，因为我们还想使用实现了这个接口的一些服务，旧的接口是不能被完全重构掉。故：那么为了使用以前实现旧接口的服务，我们就应该把新的接口转换成旧接口；相比于适配器的应用场景，代理就不一样了，虽然代理也同样是增加了一层，但是， 代理提供的接口和原本的接口是一样的 ，代理模式的作用是不把实现直接暴露给client，而是通过代理这个层，代理能够做一些处理； 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 3.静态代理静态代理： 代理和被代理对象在代理之前是确定的。他们都实现相同的接口或者继承相同的抽象类 3.1 静态代理简单实现以汽车行驶，记录汽车行驶时间为例子进行讲解，首先创建一个Movable接口。12345package com.rocklei123.designpatterns.proxypattern.staticproxy;public interface MoveAble &#123; void move();&#125; 创建一个Car实现MoveAble接口1234567891011121314151617181920212223242526package com.rocklei123.designpatterns.proxypattern.staticproxy;import java.util.Random;/** * @ClassName: Car * @Author: rocklei123 * @Date: 2018/10/28 23:35 * @Description: TODO * @Version 1.0 */public class Car implements MoveAble &#123; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println("汽车开始行驶。。。"); //实现开车 try &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println("汽车行驶中。。。"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long endtime = System.currentTimeMillis(); System.out.println("汽车结束行驶。。。 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); &#125;&#125; 创建一个测试Client类用户测试123456789101112131415package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: Client * @Author: rocklei123 * @Date: 2018/10/28 23:38 * @Description: TODO * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; Car car = new Car(); car.move(); &#125;&#125; 测试结果123汽车开始行驶。。。汽车行驶中。。。汽车结束行驶。。。 汽车行驶时间：717毫秒！ 3.2 通过继承实现代理创建一个ExtendsCarForProxy继承Car，然后删除Car里面有关计时的代码，放到ExtendsCarForProxy里面。 修改Car类代码1234567891011121314151617181920212223242526package com.rocklei123.designpatterns.proxypattern.staticproxy;import java.util.Random;/** * @ClassName: Car * @Author: rocklei123 * @Date: 2018/10/28 23:35 * @Description: TODO * @Version 1.0 */public class Car implements MoveAble &#123; @Override public void move() &#123; /* long starttime = System.currentTimeMillis(); System.out.println("汽车开始行驶。。。"); //实现开车*/ try &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println("汽车行驶中。。。"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; /*long endtime = System.currentTimeMillis(); System.out.println("汽车结束行驶。。。 汽车行驶时间：" + (endtime - starttime) + "毫秒！");*/ &#125;&#125; 创建ExtendsCarForProxy集成Car 类，重写move方法 12345678910111213141516171819package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: ExtendsCarForProxy * @Author: rocklei123 * @Date: 2018/10/28 23:39 * @Description: TODO * @Version 1.0 */public class ExtendsCarForProxy extends Car &#123; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println("ExtendsCarForProxy 汽车开始行驶。。。"); super.move(); long endtime = System.currentTimeMillis(); System.out.println("ExtendsCarForProxy 汽车结束行驶。。。 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); &#125;&#125; 修改Client类代码12345678910111213141516package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: Client * @Author: rocklei123 * @Date: 2018/10/28 23:38 * @Description: TODO * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; //Car car = new Car(); MoveAble m = new ExtendsCarForProxy(); m.move(); &#125;&#125; 通过继承实现代理结果输出 123ExtendsCarForProxy 汽车开始行驶。。。汽车行驶中。。。ExtendsCarForProxy 汽车结束行驶。。。 汽车行驶时间：838毫秒！ 3.3 使用聚合方式创建聚合方式的Car类AggregationCarForProxy,实现MoveAble接口，并创建有参构造方法1234567891011121314151617181920212223242526package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: AggregationCarForProxy * @Author: rocklei123 * @Date: 2018/10/28 23:51 * @Description: TODO * @Version 1.0 */public class AggregationCarForProxy implements MoveAble &#123; private Car car; public AggregationCarForProxy(Car car) &#123; super(); this.car = car; &#125; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println("AggregationCarForProxy 汽车开始行驶。。。"); car.move(); long endtime = System.currentTimeMillis(); System.out.println("AggregationCarForProxy 汽车结束行驶。。。 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); &#125;&#125; 修改Client类代码12345678910111213141516171819package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: Client * @Author: rocklei123 * @Date: 2018/10/28 23:38 * @Description: TODO * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; /* Car car = new Car(); MoveAble m = new ExtendsCarForProxy(); m.move();*/ Car car = new Car(); MoveAble m = new AggregationCarForProxy(car); m.move(); &#125;&#125; 聚合类型执行结果123AggregationCarForProxy 汽车开始行驶。。。汽车行驶中。。。AggregationCarForProxy 汽车结束行驶。。。 汽车行驶时间：764毫秒！ 聚合方式就是两个类实现同一个接口，Car类实现move功能，然后通过构造函数把Car类注入到AggregationCarForProxy中，在调用Car类move时做一些处理，从而实现了代理功能。 3.4 聚合方式优点体现 问题 如果我们需要在Move上实现时间处理、权限、日志等功能。比如需要实现先输出时间，再输出日志就需要创建一个Car4继承Car，如果我想先输出日志，再输出时间呢？就需要在创建一个Car5继承Car，只是顺序颠倒一下，就需要在创建一个，如果功能多的话，就需要创建很多类，太麻烦了。使用聚合就不会有这种问题出现。 聚合方式创建多个代理类，根据需求顺序调用 创建时间代理类，专门处理时间1234567891011121314151617181920212223242526package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: AggregationCarTimeStaticProxy * @Author: rocklei123 * @Date: 2018/10/29 00:05 * @Description: TODO * @Version 1.0 */public class AggregationCarTimeStaticProxy implements MoveAble &#123; private MoveAble m; public AggregationCarTimeStaticProxy(MoveAble m) &#123; super(); this.m = m; &#125; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println("AggregationCarTimeStaticProxy 汽车开始行驶。。。"); m.move(); long endtime = System.currentTimeMillis(); System.out.println("AggregationCarTimeStaticProxy 汽车结束行驶。。。 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); &#125;&#125; 创建专门处理日志的代理类123456789101112131415161718192021222324package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: AggregationCarLogStaticProxy * @Author: rocklei123 * @Date: 2018/10/29 00:06 * @Description: TODO * @Version 1.0 */public class AggregationCarLogStaticProxy implements MoveAble &#123; private MoveAble m; public AggregationCarLogStaticProxy(MoveAble m) &#123; super(); this.m = m; &#125; @Override public void move() &#123; System.out.println("AggregationCarLogStaticProxy 开始日志记录。。。"); m.move(); System.out.println("AggregationCarLogStaticProxy 日志记录结束。。。"); &#125;&#125; 修改Client类代码123456789101112131415161718192021222324package com.rocklei123.designpatterns.proxypattern.staticproxy;/** * @ClassName: Client * @Auther: rocklei123 * @Date: 2018/10/28 23:38 * @Description: TODO * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; /* Car car = new Car(); MoveAble m = new ExtendsCarForProxy(); m.move();*/ /*Car car = new Car(); MoveAble m = new AggregationCarForProxy(car); m.move();*/ Car car = new Car(); MoveAble ctp = new AggregationCarTimeStaticProxy(car);//执行时间 MoveAble clp = new AggregationCarLogStaticProxy(ctp);//记录日志 clp.move(); &#125;&#125; 执行结果12345AggregationCarLogStaticProxy 开始日志记录。。。AggregationCarTimeStaticProxy 汽车开始行驶。。。汽车行驶中。。。AggregationCarTimeStaticProxy 汽车结束行驶。。。 汽车行驶时间：881毫秒！AggregationCarLogStaticProxy 日志记录结束。。。 3.5 静态代理类优缺点总结 优点： 代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合）。 缺点： 1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 2）代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。即静态代理类只能为特定的接口(Service)服务。如想要为多个接口服务则需要建立很多个代理类。 引入下文，动态代理 4.Java动态代理书接上文，现在只是对小汽车进行代理，如果要实现对火车，自行车的代理是不是需要创建火车代理类，自行车代理类等，太麻烦了。可以通过动态代理进行实现。 4.1 Java动态代理概念Java 动态代理机制的出现，使得 Java 开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。 4.2 JDK动态代理JDK自从1.3版本开始，就引入了动态代理，JDK的动态代理用起来非常简单，但是它有一个限制，就是使用动态代理的对象必须实现一个或多个接口 。如果想代理没有实现接口的类可以使用CGLIB包。 首先让我们来了解一下如何使用 Java 动态代理。具体有如下四步骤： 1、通过实现 InvocationHandler 接口创建自己的调用处理器； 2、通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入 自定义自己的InvocationHandler123456789101112131415161718192021222324252627282930313233343536package com.rocklei123.designpatterns.proxypattern.dynamic.jdkdynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * @ClassName: TimeHadlerJdkDynamicProxy * @Author: rocklei123 * @Date: 2018/10/29 11:22 * @Description: TODO * @Version 1.0 */public class TimeHadlerJdkDynamicProxy implements InvocationHandler &#123; private Object target; public TimeHadlerJdkDynamicProxy(Object target) &#123; this.target = target; &#125; /** * @param proxy proxy 被代理对象 * @param method 被代理对象的方法 * @param args 被代理对象方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long starttime = System.currentTimeMillis(); System.out.println("TimeHadlerJdkDynamicProxy 汽车开始行驶。。。"); method.invoke(target); long endtime = System.currentTimeMillis(); System.out.println("TimeHadlerJdkDynamicProxy 汽车结束行驶。。。 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); return null; &#125;&#125; 客户端调用1234567891011121314151617181920212223242526272829package com.rocklei123.designpatterns.proxypattern.dynamic.jdkdynamicproxy;import com.rocklei123.designpatterns.proxypattern.staticproxy.Car;import com.rocklei123.designpatterns.proxypattern.staticproxy.MoveAble;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;/** * @ClassName: Client * @Author: rocklei123 * @Date: 2018/10/29 11:27 * @Description: TODO * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; Car car = new Car(); InvocationHandler h = new TimeHadlerJdkDynamicProxy(car); Class&lt;?&gt; clazz = car.getClass(); /** * loader 类加载器 * interfaces 实现接口 * h InvocationHandler * */ MoveAble m = (MoveAble) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), h); m.move(); &#125;&#125; 执行效果123TimeHadlerJdkDynamicProxy 汽车开始行驶。。。汽车行驶中。。。TimeHadlerJdkDynamicProxy 汽车结束行驶。。。 汽车行驶时间：524毫秒！ 4.2 Cglib动态代理CGLIB(Code Generation Library)是一个开源项目。是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理. cglib有两种可选方式，继承和引用。第一种是基于继承实现的动态代理，所以可以直接通过super调用target方法，但是这种方式在spring中是不支持的，因为这样的话，这个target对象就不能被spring所管理，所以cglib还是才用类似jdk的方式，通过持有target对象来达到拦截方法的效果。 注意： CGLIB不能对final修饰的类进行代理。 CGLIB的核心类： * net.sf.cglib.proxy.Enhancer – 主要的增强类 * net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现 * net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用： * Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。 Maven 构建需要的jar包123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt;&lt;/dependency&gt; 准备被代理类1234567891011121314package com.rocklei123.designpatterns.proxypattern.dynamic.cglibdynamicproxy;/** * @ClassName: Train * @Author: rocklei123 * @Date: 2018/10/29 12:30 * @Description: TODO * @Version 1.0 */public class Train &#123; public void move() &#123; System.out.println("火车行驶中。。。"); &#125;&#125; cglib实现动态代理 123456789101112131415161718192021222324252627282930313233343536373839404142package com.rocklei123.designpatterns.proxypattern.dynamic.cglibdynamicproxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * @ClassName: TrainTimerCglibDynamicProxy * @Author: rocklei123 * @Date: 2018/10/29 12:31 * @Description: TODO * @Version 1.0 */public class TrainTimerCglibDynamicProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class clazz) &#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; /** * @param o 目标类的实例 * @param method 目标类的反射方法 * @param objects 方法的参数 * @param methodProxy 代理类的实例 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; long starttime = System.currentTimeMillis(); System.out.println("TrainTimerCglibDynamicProxy 火车开始行驶。。。"); Object c = methodProxy.invokeSuper(o, objects); long endtime = System.currentTimeMillis(); System.out.println("TrainTimerCglibDynamicProxy 火车结束行驶。。。 火车行驶时间：" + (endtime - starttime) + "毫秒！"); return c; &#125;&#125; 客户端测试类12345678910111213141516package com.rocklei123.designpatterns.proxypattern.dynamic.cglibdynamicproxy;/** * @ClassName: Client * @Author: rocklei123 * @Date: 2018/10/29 13:05 * @Description: TODO * @Version 1.0 */public class TrainClient &#123; public static void main(String[] args) &#123; TrainTimerCglibDynamicProxy proxy = new TrainTimerCglibDynamicProxy(); Train train = (Train) proxy.getProxy(Train.class); train.move(); &#125;&#125; 测试结果 123TrainTimerCglibDynamicProxy 火车开始行驶。。。火车行驶中。。。TrainTimerCglibDynamicProxy 火车结束行驶。。。 火车行驶时间：127毫秒！ 4.3 JDK动态代理和Cglib动态代理的区别 JDK动态代理 CGLIB动态代理 只能代理实现了接口的类 针对类来实现代理的 没有实现接口的类不能实现JDK的动态代理 对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用 5 希望大家手动敲一遍代码，会收获颇丰！6.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL-SQL开发总结（三）-开发技巧2]]></title>
    <url>%2F2018%2F10%2F16%2FMYSQL-SQL%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A72%2F</url>
    <content type="text"><![CDATA[0. 目标通过本文可以了解在使用mysql数据库开发时，一些开发技巧。本文比较基础，大神请绕道。 通过本人能够掌握： MySQL 行列转换 MySQL 列转行 MySQL 行转列 MySQL 生成唯一序列号 MySQL 删除重复数据 使用数据及导入方法见MYSQL-SQL开发总结（一）-SQL基础 1. 测试表数据1234567891011121314151617181920212223242526272829mysql&gt; SELECT * FROM websites;+----+----------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+----------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA |+----+----------+---------------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; SELECT * FROM access_log;+-----+---------+-------+------------+| aid | site_id | count | date |+-----+---------+-------+------------+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+-----+---------+-------+------------+9 rows in set (0.00 sec)mysql&gt; 123456789101112131415mysql&gt; SELECT w.name ,a.count FROM websites w JOIN access_log a ON w.id = a.site_id;+----------+-------+| name | count |+----------+-------+| Google | 45 || Google | 230 || 淘宝 | 10 || 菜鸟教程 | 100 || 菜鸟教程 | 220 || 菜鸟教程 | 201 || 微博 | 13 || Facebook | 205 || Facebook | 545 |+----------+-------+9 rows in set (0.01 sec) 2.行转列场景欲实现效果，将各个公司网站访问总数统一在一行显示。实现效果如下： 2.1 使用自连接方法实现行转列 思路 我们可以通过单独查询其中一种应用总的访问次数，然后在对几种结果通过cross join 聚合。 Google 公司网站访问次数总计 123456789mysql&gt; SELECT SUM(COUNT) AS 'Google' FROM access_log a JOIN websites w ON w.id = a.site_id AND w.name = 'Google';+--------+| Google |+--------+| 275 |+--------+1 row in set (0.00 sec)mysql&gt; Facebook公司网站访问次数总计 123456789mysql&gt; SELECT SUM(COUNT) AS 'Facebook' FROM access_log a JOIN websites w ON w.id = a.site_id AND w.name = 'Facebook';+----------+| Facebook |+----------+| 750 |+----------+1 row in set (0.00 sec)mysql&gt; 菜鸟教程公司网站访问次数总计 123456789mysql&gt; SELECT SUM(COUNT) AS '菜鸟教程' FROM access_log a JOIN websites w ON w.id = a.site_id AND w.name = '菜鸟教程';+----------+| 菜鸟教程 |+----------+| 521 |+----------+1 row in set (0.00 sec)mysql&gt; 通过cross join 结果聚合 12345678910111213141516171819SELECT *FROM (SELECT SUM(COUNT) AS 'Google' FROM access_log a JOIN websites w ON w.id = a.site_id AND w.name = 'Google') G CROSS JOIN (SELECT SUM(COUNT) AS 'Facebook' FROM access_log a JOIN websites w ON w.id = a.site_id AND w.name = 'Facebook') F CROSS JOIN (SELECT SUM(COUNT) AS '菜鸟教程' FROM access_log a JOIN websites w ON w.id = a.site_id AND w.name = '菜鸟教程') C; 123456789mysql&gt;+--------+----------+----------+| Google | Facebook | 菜鸟教程 |+--------+----------+----------+| 275 | 750 | 521 |+--------+----------+----------+1 row in set (0.01 sec)mysql&gt; 缺点： 是将原来查询的结果每一行单独查询出来，再进行拼接。因此每增加一个同学就增加一个SELECT语句。并且是通过交叉连接，要保证每个查询的结果只能是一个，不然没办法通过交叉连接实现转换。 2.2 使用CASE实现行转列1234567SELECT SUM(CASE WHEN NAME = 'Google' THEN COUNT END ) AS 'Google', SUM(CASE WHEN NAME = 'Facebook' THEN COUNT END ) AS 'Facebook', SUM(CASE WHEN NAME = '菜鸟教程' THEN COUNT END ) AS '菜鸟教程'FROM websites w JOIN access_log a ON w.id = a.site_id; 3 列转行场景3.1 单列转多行场景3.1.1 单列转多行场景实际用途 （1）属性拆分 （2）ETL数据处理 3.1.2 单列转多行场景演示-权限拆分 原始数据建表语句及数据 1234567891011121314151617181920212223242526Create Table: CREATE TABLE `user_roles` ( `user_roles_id` int(11) DEFAULT NULL, `role_name` varchar(100) DEFAULT NULL, `major_roles` varchar(100) DEFAULT NULL, `creation_time` datetime DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mysql&gt;INSERT INTO USER_ROLES (USER_ROLES_ID, ROLE_NAME, MAJOR_ROLES, CREATION_TIME)VALUES (1, 'middleware', '2,21,22,23,24', CURTIME());INSERT INTO USER_ROLES (USER_ROLES_ID, ROLE_NAME, MAJOR_ROLES, CREATION_TIME)VALUES (2, 'db','9,10', CURTIME());INSERT INTO USER_ROLES (USER_ROLES_ID, ROLE_NAME, MAJOR_ROLES, CREATION_TIME)VALUES (3, 'SYSTEM', '4,6,7,8', CURTIME());INSERT INTO USER_ROLES (USER_ROLES_ID, ROLE_NAME, MAJOR_ROLES, CREATION_TIME)VALUES (4, 'bcy109', '21,22,25,26,27,28,23,24,16',CURTIME());INSERT INTO USER_ROLES (USER_ROLES_ID, ROLE_NAME, MAJOR_ROLES, CREATION_TIME)VALUES (5, 'bcytest', '17,18,23,24',CURTIME()); 表数据 预期实现目标 3.1.3 使用序列化表的方法实现行转列 建立序列表：1234567891011121314151617181920CREATE TABLE tb_sequence(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY);INSERT INTO tb_sequence VALUES(),(),(),(),(),(),(),(),();mysql&gt; SELECT * FROM tb_sequence;+----+| id |+----+| 1 || 2 || 3 || 4 || 5 || 6 || 7 || 8 || 9 |+----+9 rows in set (0.01 sec)mysql&gt; 最终语句 1234SELECT b.user_roles_id,b.role_name,REPLACE(SUBSTRING(SUBSTRING_INDEX(major_roles,',',a.id),CHAR_LENGTH(SUBSTRING_INDEX(major_roles,',',a.id-1))+1),',','') AS major_roles FROM tb_sequence a CROSS JOIN(SELECT user_roles_id,role_name,CONCAT(major_roles,',') AS major_roles,LENGTH(major_roles)-LENGTH(REPLACE(major_roles,',',''))+1 sizeFROM user_roles b ORDER BY b.user_roles_id) b ON a.id&lt;=b.size; 语句解读 内部子查询：目的是在 major_roles 每行数据增加一个逗号，在用总长度减去没有逗号的情况时的长度 = size （表示有几个权限，将要转成几行记录） 123456789101112131415mysql&gt; SELECT user_roles_id,role_name,CONCAT(major_roles,',') AS major_roles, -&gt; LENGTH(major_roles)-LENGTH(REPLACE(major_roles,',',''))+1 size -&gt; FROM user_roles b ORDER BY b.user_roles_id;+---------------+------------+-----------------------------+------+| user_roles_id | role_name | major_roles | size |+---------------+------------+-----------------------------+------+| 1 | middleware | 2,21,22,23,24, | 5 || 2 | db | 9,10, | 2 || 3 | SYSTEM | 4,6,7,8, | 4 || 4 | bcy109 | 21,22,25,26,27,28,23,24,16, | 9 || 5 | bcytest | 17,18,23,24, | 4 |+---------------+------------+-----------------------------+------+5 rows in set (0.00 sec)mysql&gt; 外部查询：外层查询根据序列表 cross join 子查询结果 3.2 多列转多行场景3.2.1 多列转多行场景实际用途 （1）学生成绩查询 （2） ETL 数据抽取 3.2.2 多列转多行案例分析-学生成绩行列转换 建表语句及原始数据插入语句 12345678910111213CREATE TABLE `TB_GRADE` ( `ID` INT(10) NOT NULL AUTO_INCREMENT, `USER_NAME` VARCHAR(20) DEFAULT NULL, `CN_SCORE` FLOAT DEFAULT '0', `MATCH_SCORE` FLOAT DEFAULT '0', `EN_SCORE` FLOAT DEFAULT '0', PRIMARY KEY (`ID`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;INSERT INTO TB_GRADE(USER_NAME, CN_SCORE, MATCH_SCORE,EN_SCORE) VALUES("张三",58 ,34,72),("李四",87 ,79,72),("王五",88 ,76,90); 表中原始数据 1234567891011mysql&gt; SELECT * FROM TB_GRADE;+----+-----------+----------+-------------+----------+| ID | USER_NAME | CN_SCORE | MATCH_SCORE | EN_SCORE |+----+-----------+----------+-------------+----------+| 1 | 张三 | 58 | 34 | 72 || 2 | 李四 | 87 | 79 | 72 || 3 | 王五 | 88 | 76 | 90 |+----+-----------+----------+-------------+----------+3 rows in set (0.02 sec)mysql&gt; 预期实现目标 12345678910111213+-----------+-------------+------+| user_name | 学科 | 成绩 |+-----------+-------------+------+| 张三 | CN_SCORE | 58 || 李四 | CN_SCORE | 87 || 王五 | CN_SCORE | 88 || 张三 | MATCH_SCORE | 34 || 李四 | MATCH_SCORE | 79 || 王五 | MATCH_SCORE | 76 || 张三 | EN_SCORE | 72 || 李四 | EN_SCORE | 72 || 王五 | EN_SCORE | 90 |+-----------+-------------+------+ 3.2.3 使用UNION方法实现列转行 语句拆分解读 1234567891011121314151617181920212223242526272829mysql&gt; SELECT user_name,'CN_SCORE' AS '语文',CN_SCORE AS '成绩' FROM TB_GRADE a;+-----------+----------+------+| user_name | 语文 | 成绩 |+-----------+----------+------+| 张三 | CN_SCORE | 58 || 李四 | CN_SCORE | 87 || 王五 | CN_SCORE | 88 |+-----------+----------+------+3 rows in set (0.00 sec)mysql&gt; SELECT user_name,'MATCH_SCORE' AS '数学',MATCH_SCORE AS '成绩' FROM TB_GRADE a;+-----------+-------------+------+| user_name | 数学 | 成绩 |+-----------+-------------+------+| 张三 | MATCH_SCORE | 34 || 李四 | MATCH_SCORE | 79 || 王五 | MATCH_SCORE | 76 |+-----------+-------------+------+3 rows in set (0.00 sec)mysql&gt; SELECT user_name,'EN_SCORE' AS '英语',EN_SCORE AS '成绩' FROM TB_GRADE a;+-----------+----------+------+| user_name | 英语 | 成绩 |+-----------+----------+------+| 张三 | EN_SCORE | 72 || 李四 | EN_SCORE | 72 || 王五 | EN_SCORE | 90 |+-----------+----------+------+3 rows in set (0.00 sec) 最终语句 123456SELECT user_name,'CN_SCORE' AS '学科',CN_SCORE AS '成绩' FROM TB_GRADE aUNION ALLSELECT user_name,'MATCH_SCORE' AS '学科',MATCH_SCORE AS '成绩' FROM TB_GRADE aUNION ALLSELECT user_name,'EN_SCORE' AS '学科',EN_SCORE AS '成绩' FROM TB_GRADE a; 最终效果 123456789101112131415161718192021mysql&gt; SELECT user_name,'CN_SCORE' AS '学科',CN_SCORE AS '成绩' FROM TB_GRADE a -&gt; UNION ALL -&gt; SELECT user_name,'MATCH_SCORE' AS '学科',MATCH_SCORE AS '成绩' FROM TB_GRADE a -&gt; UNION ALL -&gt; SELECT user_name,'EN_SCORE' AS '学科',EN_SCORE AS '成绩' FROM TB_GRADE a;+-----------+-------------+------+| user_name | 学科 | 成绩 |+-----------+-------------+------+| 张三 | CN_SCORE | 58 || 李四 | CN_SCORE | 87 || 王五 | CN_SCORE | 88 || 张三 | MATCH_SCORE | 34 || 李四 | MATCH_SCORE | 79 || 王五 | MATCH_SCORE | 76 || 张三 | EN_SCORE | 72 || 李四 | EN_SCORE | 72 || 王五 | EN_SCORE | 90 |+-----------+-------------+------+9 rows in set (0.01 sec)mysql&gt; 3.2.4 使用序列化表的方法实现列转行 语句拆分解析 通过序列固定获取学科 12345678910111213141516171819mysql&gt; SELECT user_name, CASE WHEN c.id=1 THEN 'CN_SCORE' WHEN c.id=2 THEN 'MATCH_SCORE' WHEN c.id=3 THEN 'EN_SCORE' END AS '学科' -&gt; FROM TB_GRADE a -&gt; CROSS JOIN tb_sequence c WHERE c.id&lt;=3 ;+-----------+-------------+| user_name | 学科 |+-----------+-------------+| 张三 | CN_SCORE || 李四 | CN_SCORE || 王五 | CN_SCORE || 张三 | MATCH_SCORE || 李四 | MATCH_SCORE || 王五 | MATCH_SCORE || 张三 | EN_SCORE || 李四 | EN_SCORE || 王五 | EN_SCORE |+-----------+-------------+9 rows in set (0.00 sec)mysql&gt; 通过序列固定获取成绩 123456789101112131415161718192021mysql&gt; SELECT user_name, COALESCE(CASE WHEN c.id=1 THEN CN_SCORE END, CASE WHEN c.id=2 THEN MATCH_SCORE END, CASE WHEN c.id=3 THEN EN_SCORE END) AS '成绩' -&gt; FROM TB_GRADE a -&gt; CROSS JOIN tb_sequence c WHERE c.id&lt;=3 -&gt; ;+-----------+------+| user_name | 成绩 |+-----------+------+| 张三 | 58 || 李四 | 87 || 王五 | 88 || 张三 | 34 || 李四 | 79 || 王五 | 76 || 张三 | 72 || 李四 | 72 || 王五 | 90 |+-----------+------+9 rows in set (0.00 sec)mysql&gt; 最终查询 1234SELECT user_name, CASE WHEN c.id=1 THEN 'CN_SCORE' WHEN c.id=2 THEN 'MATCH_SCORE' WHEN c.id=3 THEN 'EN_SCORE' END AS '学科',COALESCE(CASE WHEN c.id=1 THEN CN_SCORE END, CASE WHEN c.id=2 THEN MATCH_SCORE END, CASE WHEN c.id=3 THEN EN_SCORE END) AS '成绩'FROM TB_GRADE aCROSS JOIN tb_sequence c WHERE c.id&lt;=3 ORDER BY user_name; 1234567891011121314151617181920mysql&gt; SELECT user_name, CASE WHEN c.id=1 THEN 'CN_SCORE' WHEN c.id=2 THEN 'MATCH_SCORE' WHEN c.id=3 THEN 'EN_SCORE' END AS '学科', -&gt; COALESCE(CASE WHEN c.id=1 THEN CN_SCORE END, CASE WHEN c.id=2 THEN MATCH_SCORE END, CASE WHEN c.id=3 THEN EN_SCORE END) AS '成绩' -&gt; FROM TB_GRADE a -&gt; CROSS JOIN tb_sequence c WHERE c.id&lt;=3 ORDER BY user_name;+-----------+-------------+------+| user_name | 学科 | 成绩 |+-----------+-------------+------+| 张三 | MATCH_SCORE | 34 || 张三 | EN_SCORE | 72 || 张三 | CN_SCORE | 58 || 李四 | CN_SCORE | 87 || 李四 | MATCH_SCORE | 79 || 李四 | EN_SCORE | 72 || 王五 | CN_SCORE | 88 || 王五 | MATCH_SCORE | 76 || 王五 | EN_SCORE | 90 |+-----------+-------------+------+9 rows in set (0.00 sec)mysql&gt; 4. 生成唯一序列号4.1 唯一序列号场景及序列号生成方式 需要使用唯一序列号的场景： 作为数据库主键。 业务序列号。 生成序列号的方法： MySQL：AUTO_INCREMENT SQLServer：IDENTITY/SEQUENCE Oracle：SEQUENCE PgSQL：SEQUENCE 如何选择生成序列号的方式： 【原则】：优先选择系统提供的序列号生成方式。 【优点】： 控制并发； 不重复，保证序列号的唯一性。 【缺点】：序列号不连续（数据空洞），例如 1、2、4。 【原因】：对已有的数据的删除，以及事务回滚等方式不会影响自增长的序号，例如已有数据 1、2、3，删除 3 号数据。之后再插入一条数据，此时数据表的数据为 1、2、4。 4.2 建立特殊需求的序列号创建订单号，订单序列号格式如下：YYYYMMDDnnnnnnn。如201810170000002 基础表 1234CREATE TABLE order_seq(timestr INT UNSIGNED,order_sn INT UNSIGNED); 存储过程 1234567891011121314151617181920DELIMITER // CREATE PROCEDURE seq_no() BEGIN DECLARE v_cnt INT; DECLARE v_timestr INT; DECLARE rowcount BIGINT; SET v_timestr = DATE_FORMAT(NOW(), '%Y%m%d'); SELECT ROUND(RAND() * 100, 0) + 1 INTO v_cnt; START TRANSACTION; UPDATE order_seq SET order_sn = order_sn + v_cnt WHERE timestr = v_timestr; IF ROW_COUNT() = 0 THEN INSERT INTO order_seq(timestr, order_sn) VALUES(v_timestr,v_cnt); END IF; SELECT CONCAT(v_timestr, LPAD(order_sn, 7, 0)) AS order_sn FROM order_seq WHERE timestr = v_timestr; COMMIT; END//DELIMITER ; 结果展示 此存储过程经测试，每秒中可以生成1千个订单号 12345678910111213141516171819mysql&gt; call seq_no();+-----------------+| order_sn |+-----------------+| 201810170000135 |+-----------------+1 row in set (0.01 sec)Query OK, 0 rows affected (0.05 sec)mysql&gt; select * from order_seq;+----------+----------+| timestr | order_sn |+----------+----------+| 20181017 | 135 |+----------+----------+1 row in set (0.00 sec)mysql&gt; 知识点： 1、在sql语句中添加变量。 declare @local_variable data_type 声明时需要指定变量的类型，可以使用SET、SELECT、SELECT…INTO对变量进行赋值，在sql语句中就可以使用@local_variable来调用变量。 2、RAND()返回一个介于 0 到 1（不包括 0 和 1）之间的伪随机 float 值。 3、事务 4、ROW_COUNT()函数返回查询语句执行后，被影响的列数目 5、IF…THEN…END IF; 5. 删除重复数据5.1 查询数据是否重复1234567891011121314151617181920212223mysql&gt; SELECT * FROM runoob_tbl;+-----------+--------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+--------------+---------------+-----------------+| 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 || 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 || 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 5 | 学习 C | FK | 2017-04-05 |+-----------+--------------+---------------+-----------------+5 rows in set (0.00 sec)mysql&gt;mysql&gt; SELECT runoob_author,COUNT(*) FROM runoob_tbl GROUP BY runoob_author HAVING COUNT(*)&gt;1;+---------------+----------+| runoob_author | COUNT(*) |+---------------+----------+| RUNOOB.COM | 2 || 菜鸟教程 | 2 |+---------------+----------+2 rows in set (0.00 sec)mysql&gt; 5.2 删除重复数据，对于相同数据保留ID最大的 sql 语句 1234567891011DELETE aFROM runoob_tbl a JOIN (SELECT runoob_author, COUNT(*), MAX(runoob_id) AS runoob_id FROM runoob_tbl GROUP BY runoob_author HAVING COUNT( * ) &gt; 1) b ON a.runoob_author = b.runoob_authorWHERE a.runoob_id &lt; b.runoob_id; 效果 123456789101112131415161718192021222324mysql&gt; DELETE a -&gt; FROM runoob_tbl a -&gt; JOIN (SELECT -&gt; runoob_author, -&gt; COUNT(*), -&gt; MAX(runoob_id) AS runoob_id -&gt; FROM runoob_tbl -&gt; GROUP BY runoob_author -&gt; HAVING COUNT( * ) &gt; 1) b -&gt; ON a.runoob_author = b.runoob_author -&gt; WHERE a.runoob_id &lt; b.runoob_id;Query OK, 2 rows affected, 1 warning (0.22 sec)mysql&gt; select * from runoob_tbl;+-----------+--------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+--------------+---------------+-----------------+| 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 5 | 学习 C | FK | 2017-04-05 |+-----------+--------------+---------------+-----------------+3 rows in set (0.00 sec)mysql&gt; 6 希望大家手动敲一遍代码，会收获颇丰！7 参考菜鸟教程 http://www.runoob.com/sql/sql-tutorial.html 慕课网sqlercn老师-mysql 开发技巧 https://www.imooc.com/learn/427 10.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL-SQL开发总结（一）-SQL基础]]></title>
    <url>%2F2018%2F10%2F11%2FMYSQL-SQL%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89-SQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.目标通过本文可以了解在使用mysql数据库开发时，一些开发技巧。本文比较基础，大神请绕道。 通过本人能够掌握： MySQL UNION MySQL 排序 MySQL 分组 Mysql 连接的使用 MySQL 导入数据 2.环境准备本教程的 SQL 在 MySQL 中测试通过。使用基础数据下载地址：sql 教程 本教程使用到的 Websites 表 SQL 文件：websites.sql。 本教程使用到的 access_log 表 SQL 文件：access_log.sql。 本教程使用到的 apps 表 SQL 文件：apps.sql。 Mysql join 使用到的表结构下载地址： runoob-mysql-join-test.sql mysql 分组使用到的 employee_tbl 表语句如下： 1234567891011121314151617181920212223SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `employee_tbl`-- ----------------------------DROP TABLE IF EXISTS `employee_tbl`;CREATE TABLE `employee_tbl` ( `id` INT(11) NOT NULL, `name` CHAR(10) NOT NULL DEFAULT '', `date` DATETIME NOT NULL, `singin` TINYINT(4) NOT NULL DEFAULT '0' COMMENT '登录次数', PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;-- ------------------------------ Records of `employee_tbl`-- ----------------------------BEGIN;INSERT INTO `employee_tbl` VALUES ('1', '小明', '2016-04-22 15:25:33', '1'), ('2', '小王', '2016-04-20 15:25:47', '3'), ('3', '小丽', '2016-04-19 15:26:02', '2'), ('4', '小王', '2016-04-07 15:26:14', '4'), ('5', '小明', '2016-04-11 15:26:40', '4'), ('6', '小明', '2016-04-04 15:26:54', '2');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 2.1 建库准备创建数据库，该命令的作用： 如果数据库不存在则创建，存在则不创建。 创建RUNOOB数据库，并设定编码集为utf8 1CREATE DATABASE IF NOT EXISTS RUNOOB DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2.2 导入数据 通过sqlyog 工具或其他图形化工具的 import功能 登录mysql cli 执行：source /home/abc/abc.sql; 123mysql&gt; use abc; # 使用已创建的数据库mysql&gt; set names utf8; # 设置编码mysql&gt; source /home/abc/abc.sql # 导入备份数据库 mysql -uroot -p123456 &lt; runoob.sql 3 开发技巧整理3.1 MySQL 排序案例分析12345678910111213mysql&gt; SELECT * FROM websites ORDER BY country,alexa;+----+----------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+----------+---------------------------+-------+---------+| 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 1 | Google | https://www.google.cm/ | 1 | USA || 5 | Facebook | https://www.facebook.com/ | 3 | USA |+----+----------+---------------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; ORDER BY 多列的时候，先按照第一个column name排序，在按照第二个column name排序； 1）、先将country值这一列排序，同为CN的排前面，同属USA的排后面； 2）、然后在同属CN的这些多行数据中，再根据alexa值的大小排列。 3）、ORDER BY 排列时，不写明ASC DESC的时候，默认是ASC(升序)。 多列排序注意事项 ORDER BY 多列的时候，eg: order by A,B 这个时候都是默认按升序排列 order by A desc,B 这个时候 A 降序，B 升序排列 order by A ,B desc 这个时候 A 升序，B 降序排列 即 desc 或者 asc 只对它紧跟着的第一个列名有效，其他不受影响，仍然是默认的升序。 3.2 MySQL UNION 操作符3.2.1 MySQL UNION 语法及注意事项 语法 MySQL UNION 操作符语法格式：1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; 参数 expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据 请注意 ，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 3.2.2 测试表原始数据（JOIN测试时也需要此表数据演示）1234567891011121314151617181920212223mysql&gt; SELECT * FROM apps;+----+----------+-------------------------+---------+| id | app_name | url | country |+----+----------+-------------------------+---------+| 1 | QQ APP | http://im.qq.com/ | CN || 2 | 微博 APP | http://weibo.com/ | CN || 3 | 淘宝 APP | https://www.taobao.com/ | CN |+----+----------+-------------------------+---------+3 rows in set (0.02 sec)mysql&gt; SELECT * FROM websites;+----+----------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+----------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA |+----+----------+---------------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; 3.2.3 MySQL UNION 实例演示 SQL UNION 实例 （无重复数据） 1234567891011121314mysql&gt; SELECT country,url FROM websites UNION SELECT country,url FROM apps ORDER BY country ;+---------+---------------------------+| country | url |+---------+---------------------------+| CN | http://weibo.com/ || CN | http://im.qq.com/ || CN | https://www.taobao.com/ || CN | http://www.runoob.com/ || USA | https://www.facebook.com/ || USA | https://www.google.cm/ |+---------+---------------------------+6 rows in set (0.00 sec)mysql&gt; SQL UNION ALL 实例 （存在重复数据） 12345678910111213141516mysql&gt; SELECT country,url FROM websites UNION ALL SELECT country,url FROM apps ORDER BY country ;+---------+---------------------------+| country | url |+---------+---------------------------+| CN | http://weibo.com/ || CN | http://im.qq.com/ || CN | http://weibo.com/ || CN | https://www.taobao.com/ || CN | https://www.taobao.com/ || CN | http://www.runoob.com/ || USA | https://www.facebook.com/ || USA | https://www.google.cm/ |+---------+---------------------------+8 rows in set (0.00 sec)mysql&gt; 带有 WHERE 的 SQL UNION ALL 1234567891011121314mysql&gt; SELECT country,url FROM websites WHERE country = 'CN' UNION ALL SELECT country,url FROM apps WHERE country = 'CN' ORDER BY country;+---------+-------------------------+| country | url |+---------+-------------------------+| CN | http://im.qq.com/ || CN | http://weibo.com/ || CN | https://www.taobao.com/ || CN | https://www.taobao.com/ || CN | http://www.runoob.com/ || CN | http://weibo.com/ |+---------+-------------------------+6 rows in set (0.00 sec)mysql&gt; 3.3 MySQL 分组 原始数据 123456789101112mysql&gt; SELECT * FROM employee_tbl;+----+--------+---------------------+--------+| id | name | date | singin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+6 rows in set (0.00 sec) GROUP BY 语句将数据表按名字进行分组，并统计每个人有多少条记录,并排序 1234567891011mysql&gt; SELECT NAME,COUNT(*) AS count_num FROM employee_tbl GROUP BY NAME ORDER BY count_num DESC ;+------+-----------+| NAME | count_num |+------+-----------+| 小明 | 3 || 小王 | 2 || 小丽 | 1 |+------+-----------+3 rows in set (0.03 sec)mysql&gt; 使用 WITH ROLLUP WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。（目的看谁登录次数最多）123456789101112mysql&gt; SELECT NAME,SUM(singin) AS singin_count FROM employee_tbl GROUP BY NAME WITH ROLLUP;+------+--------------+| NAME | singin_count |+------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+------+--------------+4 rows in set (0.00 sec)mysql&gt; 其中记录 NULL 表示所有人的登录次数。我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：12select coalesce(a,b,c);参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。 以下实例中如果名字为空我们使用总数代替： 123456789101112mysql&gt; SELECT COALESCE(NAME,'总数'),SUM(singin) FROM employee_tbl GROUP BY NAME WITH ROLLUP;+-----------------------+-------------+| COALESCE(NAME,'总数') | SUM(singin) |+-----------------------+-------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || 总数 | 16 |+-----------------------+-------------+4 rows in set (0.01 sec)mysql&gt; 注意事项 1、group by 可以实现一个最简单的去重查询，假设想看下有哪些员工，除了用 distinct,还可以用：12SELECT name FROM employee_tb1 GROUP BY name;返回的结果集就是所有员工的名字。SELECT DISTINCT NAME FROM employee_tbl; 哪种效率更高呢？&lt;做过对比测试的兄弟希望能给出你的建议&gt; 2、分组后的条件使用 HAVING 来限定，WHERE 是对原始数据进行条件限制。几个关键字的使用顺序为 where 、group by 、having、order by ，例如： 12345678910mysql&gt; SELECT NAME,SUM(singin) AS singin_count FROM employee_tbl WHERE id &lt;&gt; 1 GROUP BY NAME HAVING singin_count &gt; 5 ORDER BY singin_count DESC ;+------+--------------+| NAME | singin_count |+------+--------------+| 小王 | 7 || 小明 | 6 |+------+--------------+2 rows in set (0.00 sec)mysql&gt; 3.4 MySQL 连接JOINSQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 3.4.1 内连接 INNER JOIN INNER JOIN：如果表中有至少一个匹配，则返回行1234567891011121314151617mysql&gt; SELECT a.country ,a.app_name ,a.url,b.country ,b.name,b.alexa FROM apps a INNER JOIN websites b ON a.country = b.country;+---------+----------+-------------------------+---------+----------+-------+| country | app_name | url | country | name | alexa |+---------+----------+-------------------------+---------+----------+-------+| CN | QQ APP | http://im.qq.com/ | CN | 淘宝 | 13 || CN | 微博 APP | http://weibo.com/ | CN | 淘宝 | 13 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 淘宝 | 13 || CN | QQ APP | http://im.qq.com/ | CN | 菜鸟教程 | 4689 || CN | 微博 APP | http://weibo.com/ | CN | 菜鸟教程 | 4689 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 菜鸟教程 | 4689 || CN | QQ APP | http://im.qq.com/ | CN | 微博 | 20 || CN | 微博 APP | http://weibo.com/ | CN | 微博 | 20 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 微博 | 20 |+---------+----------+-------------------------+---------+----------+-------+9 rows in set (0.00 sec)mysql&gt; 3.4.1 外连接 LEFT JOIN LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 12345678910111213141516171819mysql&gt; SELECT a.country ,a.NAME ,a.url,a.alexa,b.country ,b.app_name FROM websites a LEFT JOIN apps b ON a.country = b.country;+---------+----------+---------------------------+-------+---------+----------+| country | NAME | url | alexa | country | app_name |+---------+----------+---------------------------+-------+---------+----------+| CN | 淘宝 | https://www.taobao.com/ | 13 | CN | QQ APP || CN | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN | QQ APP || CN | 微博 | http://weibo.com/ | 20 | CN | QQ APP || CN | 淘宝 | https://www.taobao.com/ | 13 | CN | 微博 APP || CN | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN | 微博 APP || CN | 微博 | http://weibo.com/ | 20 | CN | 微博 APP || CN | 淘宝 | https://www.taobao.com/ | 13 | CN | 淘宝 APP || CN | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN | 淘宝 APP || CN | 微博 | http://weibo.com/ | 20 | CN | 淘宝 APP || USA | Google | https://www.google.cm/ | 1 | NULL | NULL || USA | Facebook | https://www.facebook.com/ | 3 | NULL | NULL |+---------+----------+---------------------------+-------+---------+----------+11 rows in set (0.00 sec)mysql&gt; RIGHT JOIN RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行12345678910111213141516171819mysql&gt; SELECT a.country ,a.app_name ,a.url,b.country ,b.name,b.alexa FROM apps a RIGHT JOIN websites b ON a.country = b.country;+---------+----------+-------------------------+---------+----------+-------+| country | app_name | url | country | name | alexa |+---------+----------+-------------------------+---------+----------+-------+| CN | QQ APP | http://im.qq.com/ | CN | 淘宝 | 13 || CN | QQ APP | http://im.qq.com/ | CN | 菜鸟教程 | 4689 || CN | QQ APP | http://im.qq.com/ | CN | 微博 | 20 || CN | 微博 APP | http://weibo.com/ | CN | 淘宝 | 13 || CN | 微博 APP | http://weibo.com/ | CN | 菜鸟教程 | 4689 || CN | 微博 APP | http://weibo.com/ | CN | 微博 | 20 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 淘宝 | 13 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 菜鸟教程 | 4689 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 微博 | 20 || NULL | NULL | NULL | USA | Google | 1 || NULL | NULL | NULL | USA | Facebook | 3 |+---------+----------+-------------------------+---------+----------+-------+11 rows in set (0.01 sec)mysql&gt; FULL JOIN FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行. FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。 MySQL 中不支持Full JOIN 连接，错误如下:123mysql&gt; SELECT a.country ,a.app_name ,a.url,b.country ,b.name FROM apps a FULL JOIN websites b ON a.country = b.country;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FULL JOIN websites b ON a.country = b.country' at line 1mysql&gt; 技巧1 （使MYSQL 支持Full JOIN ，通过UNION ALL 代替:123SELECT a.country ,a.NAME ,a.url,a.alexa,b.country ,b.app_name FROM websites a LEFT JOIN apps b ON a.country = b.countryUNION ALLSELECT a.country ,a.app_name ,a.url,b.country ,b.name,b.alexa FROM apps a RIGHT JOIN websites b ON a.country = b.country 123456789101112131415161718192021222324252627282930313233mysql&gt; SELECT a.country ,a.NAME ,a.url,a.alexa,b.country ,b.app_name FROM websites a LEFT JOIN apps b ON a.country = b.country -&gt; UNION ALL -&gt; SELECT a.country ,a.app_name ,a.url,b.country ,b.name,b.alexa FROM apps a RIGHT JOIN websites b ON a.country = b.country;+---------+----------+---------------------------+-------+----------+----------+| country | NAME | url | alexa | country | app_name |+---------+----------+---------------------------+-------+----------+----------+| CN | 淘宝 | https://www.taobao.com/ | 13 | CN | QQ APP || CN | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN | QQ APP || CN | 微博 | http://weibo.com/ | 20 | CN | QQ APP || CN | 淘宝 | https://www.taobao.com/ | 13 | CN | 微博 APP || CN | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN | 微博 APP || CN | 微博 | http://weibo.com/ | 20 | CN | 微博 APP || CN | 淘宝 | https://www.taobao.com/ | 13 | CN | 淘宝 APP || CN | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN | 淘宝 APP || CN | 微博 | http://weibo.com/ | 20 | CN | 淘宝 APP || USA | Google | https://www.google.cm/ | 1 | NULL | NULL || USA | Facebook | https://www.facebook.com/ | 3 | NULL | NULL || CN | QQ APP | http://im.qq.com/ | CN | 淘宝 | 13 || CN | QQ APP | http://im.qq.com/ | CN | 菜鸟教程 | 4689 || CN | QQ APP | http://im.qq.com/ | CN | 微博 | 20 || CN | 微博 APP | http://weibo.com/ | CN | 淘宝 | 13 || CN | 微博 APP | http://weibo.com/ | CN | 菜鸟教程 | 4689 || CN | 微博 APP | http://weibo.com/ | CN | 微博 | 20 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 淘宝 | 13 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 菜鸟教程 | 4689 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 微博 | 20 || NULL | NULL | NULL | USA | Google | 1 || NULL | NULL | NULL | USA | Facebook | 3 |+---------+----------+---------------------------+-------+----------+----------+22 rows in set (0.01 sec)mysql&gt; 关键字 on 数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。 在使用 left jion 时，on 和 where 条件的区别如下： 1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 SQL JOIN 中 on 与 where 的区别 3.4.1 Cross 交叉连接 CROSS JOIN 把表A和表B的数据进行一个N*M的组合，即笛卡尔积。如本例会产生3x5=15条记录，在开发过程中我们肯定是要过滤数据，所以这种很少用。 1234567891011121314151617181920212223mysql&gt; SELECT a.country ,a.app_name ,a.url,b.country ,b.name,b.alexa FROM apps a CROSS JOIN websites b ;+---------+----------+-------------------------+---------+----------+-------+| country | app_name | url | country | name | alexa |+---------+----------+-------------------------+---------+----------+-------+| CN | QQ APP | http://im.qq.com/ | USA | Google | 1 || CN | 微博 APP | http://weibo.com/ | USA | Google | 1 || CN | 淘宝 APP | https://www.taobao.com/ | USA | Google | 1 || CN | QQ APP | http://im.qq.com/ | CN | 淘宝 | 13 || CN | 微博 APP | http://weibo.com/ | CN | 淘宝 | 13 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 淘宝 | 13 || CN | QQ APP | http://im.qq.com/ | CN | 菜鸟教程 | 4689 || CN | 微博 APP | http://weibo.com/ | CN | 菜鸟教程 | 4689 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 菜鸟教程 | 4689 || CN | QQ APP | http://im.qq.com/ | CN | 微博 | 20 || CN | 微博 APP | http://weibo.com/ | CN | 微博 | 20 || CN | 淘宝 APP | https://www.taobao.com/ | CN | 微博 | 20 || CN | QQ APP | http://im.qq.com/ | USA | Facebook | 3 || CN | 微博 APP | http://weibo.com/ | USA | Facebook | 3 || CN | 淘宝 APP | https://www.taobao.com/ | USA | Facebook | 3 |+---------+----------+-------------------------+---------+----------+-------+15 rows in set (0.00 sec)mysql&gt; 4 参考借鉴菜鸟教程mysql 5.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL-SQL开发总结（二）-开发技巧1]]></title>
    <url>%2F2018%2F10%2F11%2FMYSQL-SQL%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A71%2F</url>
    <content type="text"><![CDATA[1.目标通过本文可以了解在使用mysql数据库开发时，一些开发技巧。本文比较基础，大神请绕道。 通过本人能够掌握： MySQL 使用JOIN更新表 MySQL 使用JOIN优化子查询 MySQL 使用JOIN优化聚合子查询 MySQL 实现分组选择 使用数据及导入方法见MYSQL-SQL开发总结（一）-SQL基础 2. 测试表数据123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; SELECT * FROM apps;+----+----------+-------------------------+---------+| id | app_name | url | country |+----+----------+-------------------------+---------+| 1 | QQ APP | http://im.qq.com/ | CN || 2 | 微博 APP | http://weibo.com/ | CN || 3 | 淘宝 APP | https://www.taobao.com/ | CN |+----+----------+-------------------------+---------+3 rows in set (0.02 sec)mysql&gt; SELECT * FROM websites;+----+----------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+----------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA |+----+----------+---------------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; SELECT * FROM access_log;+-----+---------+-------+------------+| aid | site_id | count | date |+-----+---------+-------+------------+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+-----+---------+-------+------------+9 rows in set (0.00 sec)mysql&gt; 3. 使用JOIN更新表3.1 测试场景测试 apps 表中url字段与 websites表url相等的记录中，将 apps 的country字段都更改为‘中国’，预期目标效果如下： 3.2 用JOIN更新表失败执行更新发现会报错，update的表不能出现在from语句中，原因是mysql对子查询的支持是比较薄弱的 123mysql&gt; UPDATE apps SET country=&apos;中国&apos; WHERE url IN (SELECT b.url FROM apps a JOIN websites b ON a.url = b.url);ERROR 1093 (HY000): You can t specify target table &apos;apps&apos; for update in FROM clausemysql&gt; 如下情况mysql 都会报错: 123456In general, you cannot modify a table and select from the same table in a subquery. For example, this limitation applies to statements of the following forms:DELETE FROM t WHERE ... (SELECT ... FROM t ...);UPDATE t ... WHERE col = (SELECT ... FROM t ...);&#123;INSERT|REPLACE&#125; INTO t (SELECT ... FROM t ...);Exception: The preceding prohibition does not apply if you are using a subquery for the modified table in the FROM clause. Example:UPDATE t ... WHERE col = (SELECT (SELECT ... FROM t...) AS _t ...); 3.3 解决办法官方手册推荐如下两种方式解决 内连接方式1UPDATE apps a INNER JOIN websites b ON a.url = b.url SET a.country='中国'; 嵌套一层1UPDATE apps a JOIN (SELECT b.url FROM apps a JOIN websites b ON a.url = b.url) b ON a.url = b.url SET a.country='CN' ; 4.使用JOIN优化子查询4.1 一般查询方法1234567891011mysql&gt; SELECT a.app_name,(SELECT NAME FROM websites b WHERE a.url = b.url ) AS app_name2 FROM apps a;+----------+-----------+| app_name | app_name2 |+----------+-----------+| QQ APP | NULL || 微博 APP | 微博 || 淘宝 APP | 淘宝 |+----------+-----------+3 rows in set (0.00 sec)mysql&gt; 问题：子查询对apps表的每一条记录都要进行一次子查询，数据小时，没有多大影响，如果数据量大时，则要消耗大量的查寻 4.2 JOIN优化(左连接)后的写法1234567891011mysql&gt; SELECT a.app_name ,b.name FROM apps a LEFT JOIN websites b ON a.url = b.url ;+----------+------+| app_name | name |+----------+------+| 淘宝 APP | 淘宝 || 微博 APP | 微博 || QQ APP | NULL |+----------+------+3 rows in set (0.00 sec)mysql&gt; 5.使用JOIN优化聚合子查询5.1 测试场景统计website 表中不同应用类型在 access_log 表中登录count最大的记录中的日期。 5.2 一般写法，未能解决无法达到预期效果1234567891011121314151617mysql&gt; SELECT w.name,MAX(a.count),a.date FROM websites AS w JOIN access_log a ON w.id = a.site_id GROUP BY w.name ,a.date ;+----------+--------------+------------+| name | MAX(a.count) | date |+----------+--------------+------------+| Facebook | 205 | 2016-05-14 || Facebook | 545 | 2016-05-16 || Google | 45 | 2016-05-10 || Google | 230 | 2016-05-14 || 微博 | 13 | 2016-05-15 || 淘宝 | 10 | 2016-05-14 || 菜鸟教程 | 100 | 2016-05-13 || 菜鸟教程 | 220 | 2016-05-15 || 菜鸟教程 | 201 | 2016-05-17 |+----------+--------------+------------+9 rows in set (0.00 sec)mysql&gt; 5.3 使用聚合子查询实现12345678910111213mysql&gt; SELECT w.name,a.count,a.date FROM websites AS w JOIN access_log a ON w.id = a.site_id WHERE a.count = (SELECT MAX(c.count) FROM access_log c WHERE w.id = c.site_id);+----------+-------+------------+| name | count | date |+----------+-------+------------+| Google | 230 | 2016-05-14 || 淘宝 | 10 | 2016-05-14 || 菜鸟教程 | 220 | 2016-05-15 || 微博 | 13 | 2016-05-15 || Facebook | 545 | 2016-05-16 |+----------+-------+------------+5 rows in set (0.03 sec)mysql&gt; 5.4 使用JOIN优化聚合子查询优化查询效率1234567891011SELECT w.name, a.count, a.dateFROM websites AS w JOIN access_log a ON w.id = a.site_id JOIN access_log b ON w.id = b.site_idGROUP BY w.name,a.date,a.countHAVING a.count = MAX(b.count); 12345678910111213mysql&gt; SELECT w.name,a.count,a.date FROM websites AS w JOIN access_log a ON w.id = a.site_id JOIN access_log b ON w.id = b.site_id GROUP BY w.name ,a.date,a.count HAVING a.count = MAX(b.count);+----------+-------+------------+| name | count | date |+----------+-------+------------+| Facebook | 545 | 2016-05-16 || Google | 230 | 2016-05-14 || 微博 | 13 | 2016-05-15 || 淘宝 | 10 | 2016-05-14 || 菜鸟教程 | 220 | 2016-05-15 |+----------+-------+------------+5 rows in set (0.03 sec)mysql&gt; 6.实现分组选择6.1 测试场景查询website表中每种name的app在access_log 表中count字段数据最大的两条数据 6.2 传统模式Google 公司网站访问次数最多的两条记录12345678910mysql&gt; SELECT w.name,a.date,a.count FROM websites AS w JOIN access_log a ON w.id = a.site_id WHERE w.name = 'Google' ORDER BY a.count DESC LIMIT 2 ;+--------+------------+-------+| name | date | count |+--------+------------+-------+| Google | 2016-05-14 | 230 || Google | 2016-05-10 | 45 |+--------+------------+-------+2 rows in set (0.00 sec)mysql&gt; Facebook 公司网站访问次数最多的两条记录12345678910mysql&gt; SELECT w.name,a.date,a.count FROM websites AS w JOIN access_log a ON w.id = a.site_id WHERE w.name = 'Facebook' ORDER BY a.count DESC LIMIT 2 ;+----------+------------+-------+| name | date | count |+----------+------------+-------+| Facebook | 2016-05-16 | 545 || Facebook | 2016-05-14 | 205 |+----------+------------+-------+2 rows in set (0.00 sec)mysql&gt; 菜鸟教程公司网站访问次数最多的两条记录12345678910mysql&gt; SELECT w.name,a.date,a.count FROM websites AS w JOIN access_log a ON w.id = a.site_id WHERE w.name = '菜鸟教程' ORDER BY a.count DESC LIMIT 2 ;+----------+------------+-------+| name | date | count |+----------+------------+-------+| 菜鸟教程 | 2016-05-15 | 220 || 菜鸟教程 | 2016-05-17 | 201 |+----------+------------+-------+2 rows in set (0.01 sec)mysql&gt; 缺点： 1 如果分类或是应用类型很多的情况下则需要多次执行同一查询 2 增加应用程序同数据的交互次数 3 增加数据库执行查询的次数，不符合批处理原则 4 增加网络流量 6.2 通过join和子查询实现分组12345678910111213141516171819SELECT d.name, c.date, c.countFROM (SELECT a.aid, a.site_id, a.date, a.count, (SELECT COUNT(*) FROM access_log b WHERE b.site_id = a.site_id AND a.count &lt;= b.count) AS cnt FROM access_log a GROUP BY a.aid,a.date,a.count) c JOIN websites d ON c.site_id = d.idWHERE cnt &lt;= 2; 结果：123456789101112131415+----------+------------+-------+| name | date | count |+----------+------------+-------+| Google | 2016-05-14 | 230 || Google | 2016-05-10 | 45 || 淘宝 | 2016-05-14 | 10 || 菜鸟教程 | 2016-05-15 | 220 || 菜鸟教程 | 2016-05-17 | 201 || 微博 | 2016-05-15 | 13 || Facebook | 2016-05-16 | 545 || Facebook | 2016-05-14 | 205 |+----------+------------+-------+8 rows in set (0.00 sec)mysql&gt; 7 希望大家手动敲一遍代码，会收获颇丰！8.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebLogic Java反序列化漏洞终极建议]]></title>
    <url>%2F2018%2F09%2F25%2FWebLogic-Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%BB%88%E6%9E%81%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[0. 概述：本文针对这几年来WebLogic软件经常报出的java反序列化漏洞问题进行总结，其他中间件软件本文暂不讨论。内容主要涵盖客户最关心的一些问题、工程师打补丁时需要注意事项。 1. 序列化与反序列化介绍Java 序列化与反序列化 Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。 Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。 序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。主要应用在以下场景： HTTP： 多平台之间的通信，管理等 RMI： 是 Java 的一组拥护开发分布式应用程序的 API，实现了不同操作系统之间程序的方法调用。值得注意的是，RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是 1099 端口。 JMX： JMX 是一套标准的代理和服务，用户可以在任何 Java 应用程序中使用这些代理和服务实现管理,中间件软件 WebLogic 的管理页面就是基于 JMX 开发的，而 JBoss 则整个系统都基于 JMX 构架。 ​ 2016年Spring RMI反序列化漏洞今年比较出名的：Jackson，FastJsonJava 十分受开发者喜爱的一点是其拥有完善的第三方类库，和满足各种需求的框架；但正因为很多第三方类库引用广泛，如果其中某些组件出现安全问题，那么受影响范围将极为广泛。 2. Java反序列化漏洞与Weblogic反序列化漏洞介绍2.1 Java反序列化漏洞历史最为出名的大概应该是：15年的Apache Commons Collections 反序列化远程命令执行漏洞，其当初影响范围包括：WebSphere、JBoss、Jenkins、WebLogic 和 OpenNMSd等。 Apache Commons Collections 3和4，Groovy，Spring，只要目标应用的Class Path中包含这些库，可让readObject()实现任意命令执行。影响比较广泛的就是Apache Commons Collections这个库，中间件基本都会涉及使用此库。 2.2 Weblogic Java反序列化漏洞介绍因为weblogic底层也使用Apache Commons Collections库，WebLogic 存在Java反序列化漏洞无疑的。不过在漏洞修复这方面，Oracle可是不走心啊。正所谓，新三年，旧三年，缝缝补补又三年，还是未修完。以下是基于Weblogic t3协议引起远程代码执行的反序列化漏洞统计：123456789CVE-2015-4852CVE-2016-0638CVE-2016-3510CVE-2017-3248CVE-2018-2628 从2015年一直修到2018年，反复修，反复被绕过，基于t3协议的Java反序列化漏洞还在继续。 问：那么为什么Java反序列化漏洞为什么波及范围如此广泛？Weblogic 的java反序列化漏洞未来可能还是会存在吗？ 答： （1）因为Apache Commons Collections 这个库使用太广泛了，市面主流中间件、Spring、fastjson 等都使用这个库。 （2）Oracle的Weblogic补丁是采用黑名单的方式过滤危险的反序列化类 ，每次新出现一种漏洞就提供一个新的黑名单，这种方式极不安全的。 一旦黑客发现新的漏洞，绕过这个黑名单就能攻击。详细原因请开大神分析 原因就在下文链接中： https://paper.seebug.org/333/ Weblogic 反序列化漏洞(CVE-2018-2628)漫谈 3.Weblogic Java 反序列化客户关心的几个问题?3.1 客户关心的：t3协议是否默认开启？ 问题 ：大多数WebLogic反序列化漏洞主要是针对T3协议，我们默认是否已经启用此协议？通过什么方法确认？ 答 ：t3协议默认都是开启的，t3协议是非常重要的WebLogic内部的通讯协议。 3.2 客户关心的：关于配置t3协议过滤器相关问题因为基本都是基于t3协议造成的Java反序列化问题，且Oracle提供的补丁集合无法完全解决java反序列化问题，官方提供一种临时解决办法就是过滤T3协议，即WebLogicServer 提供了名为weblogic.security.net.ConnectionFilterImpl 的默认连接筛选器，在此连接筛选器上添加过滤规则过滤连接。如果参考 http://www.sohu.com/a/241934306_465935 ，是否起到防护作用，文中配置方式是否正确？ 3.2.1 t3过滤器是否起到防护作用？ 问题：临时方案是否一定程度的起到预防的作用 答：临时方案在一定程度的起到预防的作用。 3.2.1 能否禁用所有t3协议？问题 ：能否禁用所有t3协议？ 下文配置方式是错误的配置方式 答：文中提到的方法是错误的方法。文中提到：筛选规则填取： 7001 deny t3 t3s ，此种规则相当于禁用了t3 协议。禁用后会影响到使用t3协议启动的受管节点，WLST监控脚本、停止脚本…等等。 4 Weblogic Java 反序列化问题最终建议4.1 针对10.3.6 及以上版本建议 （1）Oracle每个季度都会更新补丁集合，这个补丁集合不仅包含软件的安全漏洞修复而且包含软件的功能漏洞修复。所以不管怎样，即使没有完全解决反序列化漏洞，打补丁还是很有必要的。至于修复了哪些漏洞建议查bugsfixed 列表 （2）推荐Configure Weblogic Connection Filters思路：需要禁用t3协议，但是不能禁死，对于受管节点或有需求的特定节点，需要放开限制。见4.3 、4.4 参考官方doc链接（这两篇文档需要买了Oracle服务才可以下载）：Steps to Configure Weblogic Connection Filters ( Doc ID 1508748.1 ) Connection-filter Rules To Allow Few Ips To Access One Port And To Allow All Ips To Access Another Port ( Doc ID 1494692.1 ) 参考官方Doc链接：http://download.oracle.com/docs/cd/E12839_01/web.1111/e13711/con_filtr.htm#i1029357 （3）针对bsu升级工具的weblogic版本，建议先升级补丁工具，否则检查冲突时间过程WLS BSU (Smart Update) Takes Very Long Time to Apply Patches - Especially When Checking for Patch Conflicts (文档 ID 2271366.1)下载补丁集合p25153061_1036_Generic.zip 123456补丁工具升级#cd /home/cfmmc/Oracle/Middleware/utils/bsu/#unzip p25153061_1036_Generic.zip # . ./bsu_fix.sh install回滚# . ./bsu_fix.sh rollback （4）调整bsu.sh 或bsu.cmd 内存，防止内容溢出WL_HOME/utils/bsu 目录，vi bsu.sh 1"$JAVA_HOME/bin/java" -Xms2048m -Xmx2048m -jar patch-client.jar $* （5）注意事项 注意事项：临时方案存在一定风险，需要在测试环境严格实测，一旦禁用规则配置错误，可能会导致生产系统启动或调用失败。故内网环境酌情考虑，外网环境系统建议配置。 4.2 针对weblogic 1036以下版本解决建议按照oracle官网所说8和9、10版本没有反序列漏洞，但是实际中，如果在应用中含’commons.collections’的jar包，还是会在安全软件中扫描出反序列化漏洞。 非官方 的修复方式有如下两种方法： (1)下载Apache官方最新的commons-collections包，替换有漏洞的commons-collections组件地址：http://commons.apache.org/proper/commons-collections/download_collections.cgi (2)调整应用程序，使用SerialKiller类包替换进行反序列化操作的ObjectInputStream类。下载jar包和实施步骤请参考链接：https://github.com/ikkisoft/SerialKiller 题外话：不过运维人员还是不要背这颗雷吧，生产环境复杂，真出了事故我们付不起责任，更何况国企的企业政治复杂，就别把自己置于水火之中了。我们只提供建议，让甲方人员决定吧！ 4.3 Connection Filters规则示例及解读一般写法示例（第二、第三个域用*号代替，意在简化配置，用户可根据自己的需要进行精准的控制，必须填写端口信息）： 127.0.0.1 allow 10.1.34.205 allow 10.156.0.57/255.255.255.0 allow 或 10.156.0.57/24 allow 0.0.0.0/0 deny t3 t3s 解读第一条（127.0.0.1 allow）表示允许本机回环地址所有协议的连接第二条（10.10.5.68 allow）表示允许来自10.10.5.68地址任何协议的访问请求第三条（10.10.3.0/255.255.255.0 allow）表示允许10.10.3.0网段所有协议的连接，最后一条（0.0.0.0/0 denyt3 t3s）表示禁止除上面三条规则以外所有IP地址或网段t3、t3s协议的连接。 4.4 Connection Filters规则示例2 目标 The Admin server is running on port 8001 and the application is deployed on Managedserver, on port 7001The purpose is that only 4 IPs should be able to access the console and no one elseshould be allowed to access the console but all the IPs, internal or external, should haveaccess on the application 错误配置 1234510.1.34.205 * 8001 allow10.156.0.57 * 8001 allow10.156.0.58 * 8001 allow0.0.0.0/0 * 7001 allow0.0.0.0/0 * * deny 正确配置 123410.1.34.205 * 8001 allow10.156.0.57 * 8001 allow10.156.0.58 * 8001 allow* * 8001 deny Make use of * instead of 0 (0.0.0.0/0) “The default connection filter implementation interprets a target address of 0 (0.0.0.0/0)as meaning “the rule should apply to all IP addresses.”By design, the default filter doesnot evaluate the port or the local address, just the action. To clearly specify restrictionswhen using the default filter, modify the rules.Another option is to implement a custom connection filter. 5 参考田东云 -【无效的安全补丁】说说WebLogic那修不完的Java反序列化漏洞 王德富 -Weblogic之反序列化高危漏洞 6.其他博文CVE-2015-4852 java 反序列化漏洞–weblogic补丁 7.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>WebLogic</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>WebLogic</tag>
        <tag>Java 反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构师不得不知的Spring事务不能回滚的深层次原因]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84Spring%E4%BA%8B%E5%8A%A1%E4%B8%8D%E8%83%BD%E5%9B%9E%E6%BB%9A%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[1.目标 本文汇总了常见Spring事务无法回滚的问题，并配合实际案例模拟，并给出解决方案。通过本文可以更加详细的了解Spring事务无法回滚的原因。 希望大家手动敲一遍代码，会收获颇丰。 2.测试环境信息 核心jar版本 1234567spring-web-4.1.7.RELEASE.jarspring-core-4.1.7.RELEASE.jarspring-jdbc-4.1.7.RELEASE.jarmybatis-spring-1.3.1.jarmybatis-3.4.6.jarojdbc6-6.0.jarjunit-4.11.jar 3.try{}catch{非RuntimeException} 导致回滚失败3.1 测试场景模拟从中国农业银行（abcBank）张三账户转账给工商银行（icbcBank）李四账户200元。两个账户初始账户金额都为1000： 3.2 测试代码测试入口123456@Testpublic void testTransferAccountsFromZsABCBankToLsICBCBankRuntimeException() &#123; System.out.println("test开始转账........."); int success = transferAccountsService.transferAccountRuntimeException("zhangsan", "lisi", 200); System.out.println("test转账业务完成 and success = " + success + ".........");&#125; transferAccountsService （service层代码）123456789101112131415161718@Transactional public int transferAccountRuntimeException(String username1, String username2, double money) &#123; int success = -1; try &#123; System.out.println("transferAccountRuntimeException 开始转账业务------------------------"); System.out.println("transferAccountRuntimeException 张三开始取钱------------------------"); abcUserMoneyDao.drawMoney(username1, money); System.out.println("transferAccountRuntimeException 李四开始存钱------------------------"); int a = 1 / 0; //模拟出现异常 icbcUserMoneyDao.saveMoney(username2, money); System.out.println("transferAccountRuntimeException 转账业完成务------------------------"); success = 1; &#125; catch (Exception e) &#123; e.printStackTrace(); success = 0; &#125; return success; &#125; 3.3 测试结果张三取钱成功，李四存钱失败。钱转丢了！！！但是Spring事务并未回滚 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758test开始转账.........2018-09-19 10:58:15,998 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:248) org.springframework.beans.factory.support.DefaultListableBeanFactoryDEBUG: Returning cached instance of singleton bean &apos;txManager&apos;2018-09-19 10:58:15,999 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:248) org.springframework.beans.factory.support.DefaultListableBeanFactoryDEBUG: Returning cached instance of singleton bean &apos;transactionManager&apos;2018-09-19 10:58:16,079 org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:367) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Creating new transaction with name [com.rocklei123.spring.transaction.transferAccount.service.Impl.TransferAccountsServiceImpl.transferAccountRuntimeException]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &apos;&apos;2018-09-19 10:58:29,487 org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:206) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Acquired Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] for JDBC transaction2018-09-19 10:58:29,555 org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:223) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Switching JDBC Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] to manual committransferAccountRuntimeException 开始转账业务------------------------transferAccountRuntimeException 张三开始取钱------------------------2018-09-19 10:58:29,642 org.mybatis.spring.SqlSessionUtils.getSqlSession(SqlSessionUtils.java:97) org.mybatis.spring.SqlSessionUtilsDEBUG: Creating a new SqlSession2018-09-19 10:58:29,723 org.mybatis.spring.SqlSessionUtils.registerSessionHolder(SqlSessionUtils.java:128) org.mybatis.spring.SqlSessionUtilsDEBUG: Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4f1d60b0]2018-09-19 10:58:30,802 org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:87) org.mybatis.spring.transaction.SpringManagedTransactionDEBUG: JDBC Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] will be managed by Spring2018-09-19 10:58:30,855 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ABCUserMoneyDao.drawMoneyDEBUG: ==&gt; Preparing: UPDATE ABC_USER SET money = money - 200.0 WHERE username = ?java.lang.ArithmeticException: / by zero at com.rocklei123.spring.transaction.transferAccount.service.Impl.TransferAccountsServiceImpl.transferAccountRuntimeException(TransferAccountsServiceImpl.java:93) ... at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207) at com.sun.proxy.$Proxy21.transferAccountRuntimeException(Unknown Source) at tansferAccountTest.SpringTransactionTest.testTransferAccountsFromZsABCBankToLsICBCBankRuntimeException(SpringTransactionTest.java:62) .... at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)2018-09-19 10:58:32,027 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ABCUserMoneyDao.drawMoneyDEBUG: ==&gt; Parameters: zhangsan(String)2018-09-19 10:58:32,039 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ABCUserMoneyDao.drawMoneyDEBUG: &lt;== Updates: 12018-09-19 10:58:32,040 org.mybatis.spring.SqlSessionUtils.closeSqlSession(SqlSessionUtils.java:186) org.mybatis.spring.SqlSessionUtilsDEBUG: Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4f1d60b0]transferAccountRuntimeException 李四开始存钱------------------------2018-09-19 10:58:32,049 org.mybatis.spring.SqlSessionUtils$SqlSessionSynchronization.beforeCommit(SqlSessionUtils.java:284) org.mybatis.spring.SqlSessionUtilsDEBUG: Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4f1d60b0]2018-09-19 10:58:32,050 org.mybatis.spring.SqlSessionUtils$SqlSessionSynchronization.beforeCompletion(SqlSessionUtils.java:310) org.mybatis.spring.SqlSessionUtilsDEBUG: Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4f1d60b0]2018-09-19 10:58:32,051 org.mybatis.spring.SqlSessionUtils$SqlSessionSynchronization.beforeCompletion(SqlSessionUtils.java:315) org.mybatis.spring.SqlSessionUtilsDEBUG: Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4f1d60b0]2018-09-19 10:58:32,051 org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Initiating transaction commit2018-09-19 10:58:32,052 org.springframework.jdbc.datasource.DataSourceTransactionManager.doCommit(DataSourceTransactionManager.java:269) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Committing JDBC transaction on Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver]2018-09-19 10:58:32,059 org.springframework.jdbc.datasource.DataSourceTransactionManager.doCleanupAfterCompletion(DataSourceTransactionManager.java:327) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Releasing JDBC Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] after transaction2018-09-19 10:58:32,060 org.springframework.jdbc.datasource.DataSourceUtils.doReleaseConnection(DataSourceUtils.java:327) org.springframework.jdbc.datasource.DataSourceUtilsDEBUG: Returning JDBC Connection to DataSourcetest转账业务完成 and success = 0......... 3.4 回滚失败原因Spring的事务管理默认对Error异常和RuntimeException异常以及其子类进行事务回滚，且必须抛出异常，若使用try-catch对其异常捕获则不会进行回滚！（Error异常和RuntimeException异常抛出时不需要方法调用throws或try-catch语句）； 以下是spring-tx-4.1.7.RELEASE.jar包中的部分源码：123456789101112131415161718192021package org.springframework.transaction.interceptor;import org.springframework.transaction.TransactionDefinition;public interface TransactionAttribute extends TransactionDefinition &#123; String getQualifier(); boolean rollbackOn(Throwable var1);&#125;package org.springframework.transaction.interceptor;import org.springframework.transaction.support.DefaultTransactionDefinition;public class DefaultTransactionAttribute extends DefaultTransactionDefinition implements TransactionAttribute &#123; private String qualifier; public boolean rollbackOn(Throwable ex) &#123; return ex instanceof RuntimeException || ex instanceof Error; &#125;&#125; 3.5 回滚失败解决办法以下三种方式都可以解决try{}catch{非RuntimeException} 造成事务不回滚的问题（1） throw new RuntimeException();12345678910111213141516171819@Transactional public int transferAccountRuntimeException(String username1, String username2, double money) &#123; int success = -1; try &#123; System.out.println("transferAccountRuntimeException 开始转账业务------------------------"); System.out.println("transferAccountRuntimeException 张三开始取钱------------------------"); abcUserMoneyDao.drawMoney(username1, money); System.out.println("transferAccountRuntimeException 李四开始存钱------------------------"); int a = 1 / 0; icbcUserMoneyDao.saveMoney(username2, money); System.out.println("transferAccountRuntimeException 转账业完成务------------------------"); success = 1; &#125; catch (Exception e) &#123; e.printStackTrace(); success = 0; throw new RuntimeException(); &#125; return success; &#125; （2）配置 rollbackFor = Exception.class12345678910111213141516171819@Transactional(rollbackFor = Exception.class) public int transferAccountRuntimeException(String username1, String username2, double money) &#123; int success = -1; try &#123; System.out.println("transferAccountRuntimeException 开始转账业务------------------------"); System.out.println("transferAccountRuntimeException 张三开始取钱------------------------"); abcUserMoneyDao.drawMoney(username1, money); System.out.println("transferAccountRuntimeException 李四开始存钱------------------------"); int a = 1 / 0; icbcUserMoneyDao.saveMoney(username2, money); System.out.println("transferAccountRuntimeException 转账业完成务------------------------"); success = 1; &#125; catch (Exception e) &#123; e.printStackTrace(); success = 0; throw e; &#125; return success; &#125; （3）手动回滚事务12345678910111213141516171819@Transactional public int transferAccountSetRollbackOnly(String username1, String username2, double money) &#123; int success = -1; try &#123; System.out.println("transferAccountRuntimeException 开始转账业务------------------------"); System.out.println("transferAccountRuntimeException 张三开始取钱------------------------"); abcUserMoneyDao.drawMoney(username1, money); System.out.println("transferAccountRuntimeException 李四开始存钱------------------------"); int a = 1 / 0; icbcUserMoneyDao.saveMoney(username2, money); System.out.println("transferAccountRuntimeException 转账业完成务------------------------"); success = 1; &#125; catch (Exception e) &#123; e.printStackTrace(); success = 0; TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); &#125; return success; &#125; 4.this调用导致回滚失败4.1 测试场景1234567891011121314151617181920/** * @param username1 * @param username2 * @param money 业务需求： * 1 transferAccountRequiresNew是一个加入事务的service层方法。且必须一个方法中同时调用 abcBankDrawMoney (zhangsan) 和 icbcUserMoneyDao.saveMoney(lisi) * 2 abcBankDrawMoney (zhangsan) 允许失败，也就是说abcBankDrawMoney (zhangsan) 成功与否对icbcUserMoneyDao.saveMoney(lisi) 业务不影响 * 3 abcBankDrawMoney 是一个 @Transactional(propagation = Propagation.REQUIRES_NEW) 的方法 。该方法发生异常回滚 * 4 初始金额 abcBank zhangsan 1000 * 4 初始金额 icbcBank lisi 1000 * &lt;p&gt; * 预期效果： * 1 、abcBankDrawMoney (zhangsan) 回滚 * 2 、icbcUserMoneyDao.saveMoney(lisi) 取钱成功 * 3、 预期金额 abcBank zhangsan 1000 * 4 、预期金额 icbcBank lisi 1200 * &lt;p&gt; * 真实结果: * 1、真实金额 abcBank zhangsan 800 * 2、真实金额 icbcBank lisi 1200 */ 4.2 测试代码1234567891011121314151617181920212223242526272829@Testpublic void testTransferAccountsFromZsABCBankToLsICBCBankRequiresNew() &#123; System.out.println("test开始转账........."); transferAccountsService.transferAccountRequiresNew("zhangsan", "lisi", 200); System.out.println("test转账业务完成.........");&#125;@Transactional public void transferAccountRequiresNew(String username1, String username2, double money) &#123; try &#123; this.abcBankDrawMoney(username1, money); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("准备开始为李四存钱业务---------------"); icbcUserMoneyDao.saveMoney(username2, money); System.out.println("李四存钱成功---------------"); System.out.println("转账业务完成---------------"); &#125; @Transactional(propagation = Propagation.REQUIRES_NEW) @Override public void abcBankDrawMoney(String username, double money) &#123; System.out.println("准备开始为张三取钱业务---------------"); abcUserMoneyDao.drawMoney(username, money); int a = 1 / 0; System.out.println(username + "张三取钱成功-------------"); &#125; 4.3 测试结果我们看到即使abcBankDrawMoney 方法发生了异常，但是并未进行回滚操作，钱还是被取成功了，和我们之前预期的结果不是一样。 以下是执行结果： 执行日志，并未回滚：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960test开始转账.........2018-09-19 14:26:06,230 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:248) org.springframework.beans.factory.support.DefaultListableBeanFactoryDEBUG: Returning cached instance of singleton bean &apos;txManager&apos;2018-09-19 14:26:06,231 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:248) org.springframework.beans.factory.support.DefaultListableBeanFactoryDEBUG: Returning cached instance of singleton bean &apos;transactionManager&apos;2018-09-19 14:26:06,376 org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:367) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Creating new transaction with name [com.rocklei123.spring.transaction.transferAccount.service.Impl.TransferAccountsServiceImpl.transferAccountRequiresNew]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &apos;&apos;2018-09-19 14:26:11,187 org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:206) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Acquired Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] for JDBC transaction2018-09-19 14:26:11,229 org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:223) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Switching JDBC Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] to manual commit准备开始为张三取钱业务---------------2018-09-19 14:26:11,261 org.mybatis.spring.SqlSessionUtils.getSqlSession(SqlSessionUtils.java:97) org.mybatis.spring.SqlSessionUtilsDEBUG: Creating a new SqlSession2018-09-19 14:26:11,344 org.mybatis.spring.SqlSessionUtils.registerSessionHolder(SqlSessionUtils.java:128) org.mybatis.spring.SqlSessionUtilsDEBUG: Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4db1f211]2018-09-19 14:26:11,855 org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:87) org.mybatis.spring.transaction.SpringManagedTransactionDEBUG: JDBC Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] will be managed by Spring2018-09-19 14:26:11,875 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ABCUserMoneyDao.drawMoneyDEBUG: ==&gt; Preparing: UPDATE ABC_USER SET money = money - 200.0 WHERE username = ?2018-09-19 14:26:12,292 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ABCUserMoneyDao.drawMoneyDEBUG: ==&gt; Parameters: zhangsan(String)2018-09-19 14:26:12,477 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ABCUserMoneyDao.drawMoneyDEBUG: &lt;== Updates: 12018-09-19 14:26:12,479 org.mybatis.spring.SqlSessionUtils.closeSqlSession(SqlSessionUtils.java:186) org.mybatis.spring.SqlSessionUtilsjava.lang.ArithmeticException: / by zero at com.rocklei123.spring.transaction.transferAccount.service.Impl.TransferAccountsServiceImpl.ab .... 省略部分堆栈 at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)DEBUG: Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4db1f211]准备开始为李四存钱业务---------------2018-09-19 14:26:12,495 org.mybatis.spring.SqlSessionUtils.sessionHolder(SqlSessionUtils.java:163) org.mybatis.spring.SqlSessionUtilsDEBUG: Fetched SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4db1f211] from current transaction2018-09-19 14:26:12,497 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ICBCUserMoneyDao.saveMoneyDEBUG: ==&gt; Preparing: UPDATE ICBC_USER SET money = money + 200.0 WHERE username = ?2018-09-19 14:26:12,499 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ICBCUserMoneyDao.saveMoneyDEBUG: ==&gt; Parameters: lisi(String)2018-09-19 14:26:12,541 org.apache.ibatis.logging.jdbc.BaseJdbcLogger.debug(BaseJdbcLogger.java:159) com.rocklei123.spring.transaction.transferAccount.dao.ICBCUserMoneyDao.saveMoneyDEBUG: &lt;== Updates: 12018-09-19 14:26:12,542 org.mybatis.spring.SqlSessionUtils.closeSqlSession(SqlSessionUtils.java:186) org.mybatis.spring.SqlSessionUtilsDEBUG: Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4db1f211]李四存钱成功---------------转账业务完成---------------2018-09-19 14:26:12,544 org.mybatis.spring.SqlSessionUtils$SqlSessionSynchronization.beforeCommit(SqlSessionUtils.java:284) org.mybatis.spring.SqlSessionUtilsDEBUG: Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4db1f211]2018-09-19 14:26:12,545 org.mybatis.spring.SqlSessionUtils$SqlSessionSynchronization.beforeCompletion(SqlSessionUtils.java:310) org.mybatis.spring.SqlSessionUtilsDEBUG: Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4db1f211]2018-09-19 14:26:12,546 org.mybatis.spring.SqlSessionUtils$SqlSessionSynchronization.beforeCompletion(SqlSessionUtils.java:315) org.mybatis.spring.SqlSessionUtilsDEBUG: Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4db1f211]2018-09-19 14:26:12,546 org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:755) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Initiating transaction commit2018-09-19 14:26:12,547 org.springframework.jdbc.datasource.DataSourceTransactionManager.doCommit(DataSourceTransactionManager.java:269) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Committing JDBC transaction on Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver]2018-09-19 14:26:12,552 org.springframework.jdbc.datasource.DataSourceTransactionManager.doCleanupAfterCompletion(DataSourceTransactionManager.java:327) org.springframework.jdbc.datasource.DataSourceTransactionManagerDEBUG: Releasing JDBC Connection [jdbc:oracle:thin:@127.0.0.1:1521:XE, UserName=APPROBE, Oracle JDBC driver] after transaction2018-09-19 14:26:12,553 org.springframework.jdbc.datasource.DataSourceUtils.doReleaseConnection(DataSourceUtils.java:327) org.springframework.jdbc.datasource.DataSourceUtilsDEBUG: Returning JDBC Connection to DataSourcetest转账业务完成......... 4.4 回滚失败原因在SpringIoC容器中返回的调用的对象是代理对象而不是真实的对象，只有被动态代理直接调用的才会产生事务。this调用并非代理对象。 4.5 回滚失败解决办法通过AopContext.currentProxy(); 获取代理对象，通过代理对象调用abcBankDrawMoney()方法。12345678910111213@Transactional public void transferAccountRequiresNew(String username1, String username2, double money) &#123; try &#123; TransferAccountsService proxy = (TransferAccountsService) AopContext.currentProxy(); proxy.abcBankDrawMoney(username1, money); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("准备开始为李四存钱业务---------------"); icbcUserMoneyDao.saveMoney(username2, money); System.out.println("李四存钱成功---------------"); System.out.println("转账业务完成---------------"); &#125; 可能出现如下异常：123java.lang.IllegalStateException: Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available. at org.springframework.aop.framework.AopContext.currentProxy(AopContext.java:64) at com.rocklei123.spring.transaction.transferAccount.service.Impl.TransferAccountsServiceImpl.transferAccountRequiresNew(TransferAccountsServiceImpl.java:62) 解决办法在spring 配置文件中设置1&lt;aop:aspectj-autoproxy expose-proxy="true"/&gt; 小技巧：可以使用如下代码 确认你的bean 是代理对象吗？ 123AopUtils.isAopProxy()AopUtils.isCglibProxy() //cglibAopUtils.isJdkDynamicProxy() //jdk动态代理 5.其他原因导致回滚失败 mysql数据库且引擎是MyISAM造成的（因为不支持事务），改成InnoDB即可。 6.总结本文总结了几种spring事务无法回滚的原因，总结如下： try{}catch{} catch到非RuntimeException，并且未处理。默认spring仅对Error和RuntimeException 异常才回滚 this调用导致回滚失败。只有被动态代理直接调用的才会产生事务 mysql数据库且引擎是MyISAM造成的（因为不支持事务），改成InnoDB即可。 7.参考http://jinnianshilongnian.iteye.com/blog/1850432 图灵学院张飞老师–《架构师不得不知道的Spring事物不能回滚的深层次原因-张飞》 8.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Spring Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[org.apache.commons.dbcp.SQLNestedException: Cannot load JDBC driver class]]></title>
    <url>%2F2018%2F09%2F18%2Forg-apache-commons-dbcp-SQLNestedException-Cannot-load-JDBC-driver-class%2F</url>
    <content type="text"><![CDATA[1.问题描述SSM （Spring MVC + Spring + mybatis）项目集成时无法加载JDBC驱动，通过junit 测试dao层方法无法完成， 报出如下错误: org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot load JDBC driver class ‘${jdbc.driver_class}’ 2.环境信息 核心jar版本 1234567spring-web-4.1.7.RELEASE.jarspring-core-4.1.7.RELEASE.jarspring-jdbc-4.1.7.RELEASE.jarmybatis-spring-1.3.1.jarmybatis-3.4.6.jarojdbc6-6.0.jarjunit-4.11.jar spring-dao.xml 配置 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 配置整合mybatis过程 --&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location="classpath*:jdbc.properties" ignore-unresolvable="true"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver_class&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; ··· 略 &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.rocklei123.spring.transaction.transferAccount.entity"/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;value&gt;classpath*:mapper/*.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.rocklei123.spring.transaction.transferAccount.dao"/&gt; &lt;/bean&gt; 3.错误信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot load JDBC driver class &apos;$&#123;jdbc.driver_class&#125;&apos; at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:245) at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373) at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:463) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:276) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207) at com.sun.proxy.$Proxy21.transferAccountSetRollbackOnly(Unknown Source) at tansferAccountTest.SpringTransactionTest.testTransferAccountsFromZsABCBankToLsICBCBankSetRollbackOnly(SpringTransactionTest.java:69) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:73) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:82) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:73) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:224) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:83) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:68) at org.junit.runners.ParentRunner.run(ParentRunner.java:309) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:163) at org.junit.runner.JUnitCore.run(JUnitCore.java:160) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: org.apache.commons.dbcp.SQLNestedException: Cannot load JDBC driver class &apos;$&#123;jdbc.driver_class&#125;&apos; at org.apache.commons.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1429) at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:204) ... 36 moreCaused by: java.lang.ClassNotFoundException: $&#123;jdbc.driver_class&#125; at java.net.URLClassLoader$1.run(URLClassLoader.java:366) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:425) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:358) at org.apache.commons.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1420) ... 39 more 4.原因在spring里使用org.mybatis.spring.mapper.MapperScannerConfigurer 进行自动扫描的时候，设置了sqlSessionFactory 的话，可能会导致PropertyPlaceholderConfigurer失效，也就是用${jdbc.driver_class}这样之类的表达式，将无法获取到properties文件里的内容。 导致这一原因是因为：MapperScannerConigurer实际是在解析加载bean定义阶段的，这个时候要是设置sqlSessionFactory的话，会导致提前初始化一些类，这个时候，PropertyPlaceholderConfigurer还没来得及替换定义中的变量，导致把表达式当作字符串复制了。 但如果不设置sqlSessionFactory 属性的话，就必须要保证sessionFactory在spring中名称一定要是sqlSessionFactory ，否则就无法自动注入。又或者直接定义 MapperFactoryBean ，再或者放弃自动代理接口方式。 5.解决办法改用sqlSessionFactoryBeanName注入就没有问题(不要使用sqlSessionFactory属性注入，使用sqlSessionFactoryBeanName注入)，因为这时不会立即初始化sqlSessionFactory,传入的只是名字，非bean，所以不会引发提前初始化问题。 问题： 如果您足够仔细的话，可以看到文章最开始的配置已经通过sqlSessionFactoryBeanName注入，为什么还是会失败呢？ 答： 这里还是要改名称，如果注入时候还是value=sqlSessionFactory的话还是出现该问题。故在使用sqlSessionFactoryBeanName注入的同时，将sqlSessionFactory 更名为mySqlSessionFactory。（名称可以任意起） 正确的的配置应该为： 123456789101112131415161718192021222324&lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="mySqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.rocklei123.spring.transaction.transferAccount.entity"/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;value&gt;classpath*:mapper/*.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="mySqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.rocklei123.spring.transaction.transferAccount.dao"/&gt; &lt;/bean&gt; 6. 参考引自http://songjianyong.iteye.com/blog/1663170 7.欢迎关注米宝窝，持续更新中，谢谢！ 米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Driver</tag>
        <tag>SSM集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级开发必知必会——反射]]></title>
    <url>%2F2018%2F09%2F16%2FJava%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[1.目标与意义反射是Java开发中一个非常重要的概念，掌握了反射的知识，才能更好的学习Java高级课程。如Spring框架的核心就是使用Java反射实现的，而且对做一些Java底层的操作会很有帮助。 强烈建议大家手动敲一遍，会收获颇丰！ 目标： (1)、能够理解并应用反射机制。 (2)、能够了解反射机制在集合泛型中的应用。 (3)、有利于更好的学习框架等Java高级技术。 2.Class类的使用 (1） 在面向对象的世界里，万事万物皆对象。（java语言中，静态的成员、普通数据类型除外) 问题： 类是不是对象呢?类是(哪个类的对象呢?)谁的对象呢? 答： 类是对象，类是java.lang.Class类的实例对象（类对象） (2）这个对象到底如何表示（三种表示方法） 通过隐藏的静态成员变量Student.class获取 通过对象 stu1.getClass();方法获取 通过Class.forName(类路径) 获取 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.rocklei123.reflect;public class ClassDemo1 &#123; public static void main(String[] args) &#123; //Student的实例对象如何表示 Student stu1 = new Student(); //Student 这个类 也是一个实例对象，Class类的实例对象,如何表示呢 //任何一个类都是Class的实例对象，这个实例对象有三种表示方式 //第一种表示方式---&gt;实际在告诉我们任何一个类都有一个隐含的静态成员变量class Class c1 = Student.class; //第二中表达方式 已经知道该类的对象通过getClass方法 Class c2 = stu1.getClass(); //第三种表达方式 Class c3 = null; try &#123; c3 = Class.forName("com.rocklei123.reflect.Student"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; //不管c1 or c2 or c3都代表了Student类的类类型，一个类只可能是Class类的一个实例对象. System.out.println(c1 == c2); //结果True System.out.println(c2 == c3);//结果True //我们完全可以通过类的类类型创建该类的对象实例----&gt;通过c1 or c2 or c3创建Student的实例对象 try &#123; Student stu2 = (Student) c1.newInstance();//需要有无参数的构造方法 stu2.print(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Student &#123; void print() &#123; System.out.println("I am a student"); &#125;&#125; 另外Class类对象不可以new 出来，因为它的构造方法为私有的，只有JVM 才可以创建类对象 12345678910/* * Private constructor. Only the Java Virtual Machine creates Class objects. * This constructor is not used and prevents the default constructor being * generated. */private Class(ClassLoader loader) &#123; // Initialize final field for classLoader. The initialization value of non-null // prevents future JIT optimizations from assuming this final field is null. classLoader = loader;&#125; 3.Java动态加载类 请大家区分编译、运行： 编译时刻加载类是静态加载类、运行时刻加载类是动态加载类 (1) new 创建的对象，是静态类加载，在编译时刻就需要加载所有的可能使用到的类。 (2)Class.forName(“类的全称”)不仅表示了，类的类类型，还代表了动态加载类，在运行时刻加载。 4.图解类的正常加载过程和反射的原理在与class对象图解类的正常加载过程和反射的原理在与class对象 图解类的加载过程中各对象创建时占用的JVM内存区域 5.基本的数据类型、void关键字的类类型基本的数据类型、void等关键字等都存在类类型 1234567891011121314151617181920212223242526272829303132package com.rocklei123.reflect;public class ClassDemo2 &#123; public static void main(String[] args) &#123; Class c1 = int.class;//int 的类类型 Class c2 = String.class;//String类的类类型 String类字节码（自己发明的) Class c3 = double.class; Class c4 = Double.class; Class c5 = void.class; Class c6 = Enum.class; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c2.getSimpleName());//不包含包名的类的名称 System.out.println(c3.getName()); System.out.println(c4.getName()); System.out.println(c5.getName()); System.out.println(c6.getName()); /** * 结果： * c1: int * c2: java.lang.String * c2: String * c3: double * c4: java.lang.Double * c5: void * c6: java.lang.Enum */ &#125;&#125; 6.通过反射获取方法信息、成员变量、构造函数信息实体类信息：1234567891011121314151617181920212223242526272829303132333435363738package com.rocklei123.spring.transaction.transferAccount.entity;/** * @Title: SpringTransactionTest * @Description: * @Author: rocklei123 * @Date: 2018/8/14 14:52 * @Version: 1.0 */public class User &#123; private String username; private double money; public User(String username, double money) &#123; this.username = username; this.money = money; &#125; public User()&#123; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125;&#125; 反射ClassUtil打印类的信息，包括类的成员函数、成员变量(只获取成员函数)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.rocklei123.reflect;import com.rocklei123.spring.transaction.transferAccount.entity.User;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * @ClassName: ClassUtil * @Auther: rocklei123 * @Date: 2018/9/16 09:40 * @Description: 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * @Version 1.0 */public class ClassUtil &#123; /** * 打印类信息 * * @param object */ public static void printClassInfoMessage(Object object) &#123; Class c = object.getClass(); System.out.println("类加载器为:" + c.getClassLoader()); System.out.println("包名为:" + c.getPackage()); System.out.println("类名称为:" + c.getName()); System.out.println("==========================================="); &#125; /** * 打印方法信息 * * @param object */ public static void printClassMethodMessage(Object object) &#123; Class c = object.getClass(); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] methods = c.getMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; Method method = methods[i]; System.out.print("方法名称为：" + method.getName() + " ,"); Class returnType = method.getReturnType(); System.out.print(" 方法返回值类型为：" + returnType.getName() + " 方法参数类型("); Class[] parameterTypes = method.getParameterTypes(); for (int j = 0; j &lt; parameterTypes.length; j++) &#123; System.out.print(parameterTypes[j].getName()); &#125; System.out.println(")"); System.out.println("------------------------------------"); &#125; System.out.println("==========================================="); &#125; /** * 打印成员变量信息 * * @param object */ public static void pirntClassFiledsMessage(Object object) &#123; /* * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ Class c = object.getClass(); Field[] fields = c.getFields(); for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; Class fieldType = field.getType(); String fieldName = field.getName(); System.out.print("成员属性类型为:" + fieldType.getName() + ",属性名称为：" + fieldName + " , "); &#125; System.out.println("==========================================="); &#125; /** * 打印构造方法信息 * * @param object */ public static void printConstructMessage(Object object) &#123; /* * 构造函数也是对象 * java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ Class c = object.getClass(); Constructor[] constructors = c.getConstructors(); for (int i = 0; i &lt; constructors.length; i++) &#123; Constructor cons = constructors[i]; System.out.print("构造方法：" + cons.getName() + "("); //获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = cons.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + ","); &#125; System.out.println(")"); &#125; System.out.println("==========================================="); &#125; public static void main(String[] args) &#123; User user = new User(); ClassUtil.printClassInfoMessage(user); ClassUtil.printClassMethodMessage(user); ClassUtil.printConstructMessage(user); &#125;&#125; 执行结果：123456789101112131415161718192021222324252627282930313233类加载器为:sun.misc.Launcher$AppClassLoader@4921a90包名为:package com.rocklei123.spring.transaction.transferAccount.entity类名称为:com.rocklei123.spring.transaction.transferAccount.entity.User===========================================方法名称为：getUsername , 方法返回值类型为：java.lang.String 方法参数类型()------------------------------------方法名称为：setUsername , 方法返回值类型为：void 方法参数类型(java.lang.String)------------------------------------方法名称为：getMoney , 方法返回值类型为：double 方法参数类型()------------------------------------方法名称为：setMoney , 方法返回值类型为：void 方法参数类型(double)------------------------------------方法名称为：wait , 方法返回值类型为：void 方法参数类型(longint)------------------------------------方法名称为：wait , 方法返回值类型为：void 方法参数类型(long)------------------------------------方法名称为：wait , 方法返回值类型为：void 方法参数类型()------------------------------------方法名称为：equals , 方法返回值类型为：boolean 方法参数类型(java.lang.Object)------------------------------------方法名称为：toString , 方法返回值类型为：java.lang.String 方法参数类型()------------------------------------方法名称为：hashCode , 方法返回值类型为：int 方法参数类型()------------------------------------方法名称为：getClass , 方法返回值类型为：java.lang.Class 方法参数类型()------------------------------------方法名称为：notify , 方法返回值类型为：void 方法参数类型()------------------------------------方法名称为：notifyAll , 方法返回值类型为：void 方法参数类型()===========================================构造方法：com.rocklei123.spring.transaction.transferAccount.entity.User(java.lang.String,double,)构造方法：com.rocklei123.spring.transaction.transferAccount.entity.User()=========================================== 7.方法的反射1）如何获取某个方法 方法的名称和方法的参数列表才能唯一决定某个方法 2)方法反射的操作 method.invoke(对象，参数列表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.rocklei123.reflect;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @ClassName: MethodDemo1 * @Auther: rocklei123 * @Date: 2018/9/16 11:11 * @Description: TODO * @Version 1.0 */public class MethodDemo1 &#123; public static void main(String[] args) &#123; Demo demo = new Demo(); Class demoClass = demo.getClass(); /* * 2.获取方法 名称和参数列表来决定 * getMethod获取的是public的方法 * getDelcaredMethod自己声明的方法 */ try &#123; //两种获取方式 //Method m = c.getMethod("("", new Class[]&#123;int.class,int.class&#125;); //Method m = c.getMethod("add", int.class, int.class); Method addMethod = demoClass.getMethod("add", int.class, int.class); addMethod.invoke(demo, new Object[]&#123;10, 20&#125;); Method printMethod = demoClass.getMethod("print", new Class[]&#123;String.class, String.class&#125;); printMethod.invoke(demo, "hello", "world"); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; /** * 结果： * sum=30 * HELLO WORLD ! */&#125;class Demo &#123; public int add(int a, int b) &#123; int c = a + b; System.out.println("sum=" + c); return c; &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase() + " " + b.toUpperCase() + " !"); &#125;&#125; 8.通过Class,Method来认识泛型的本质 编译之后集合的泛型是去泛型化的 Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译就无效了 验证：我们可以通过方法的反射来操作，绕过编译 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.rocklei123.reflect;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * @ClassName: MethodDemo2 * @Auther: rocklei123 * @Date: 2018/9/16 12:22 * @Description: TODO * @Version 1.0 */public class MethodDemo2 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; listInt = new ArrayList&lt;Integer&gt;(); List&lt;String&gt; listStr = new ArrayList&lt;String&gt;(); listStr.add("Hello"); Class classListInt = listInt.getClass(); Class classListStr = listStr.getClass(); System.out.println(classListInt == classListStr); /* * classListInt == classListStr 结果返回true说明编译之后集合的泛型是去泛型化的 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译就无效了 * 验证：我们可以通过方法的反射来操作，绕过编译 */ try &#123; Method method = classListStr.getMethod("add", Object.class); method.invoke(listStr, 20); System.out.println("listStr大小：" + listStr.size()); System.out.println("listStr值：" + listStr); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; /** * 结果： * true * listStr大小：2 * listStr值：[Hello, 20] */ &#125;&#125; 9.参考慕课网 https://www.imooc.com/learn/199 Java基础之—反射（非常重要） https://blog.csdn.net/sinat_38259539/article/details/71799078 10.建议大家手动敲一遍会收获颇丰！11.欢迎关注米宝窝，持续更新中，谢谢！ 米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-数据泵导入导出数据步骤]]></title>
    <url>%2F2018%2F09%2F14%2FOracle-%E6%95%B0%E6%8D%AE%E6%B3%B5%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[0.目标通过Oracle数据泵工具导入导出数据 测试版本 Oracle Release 11.2.0.4.0 - 64bit Production 1 从原始库通过expdp 导出数据库指定对象或一个用户schema 到文件dmp中 2 通过impdp将数据文件导入到目标库中 1. 创建导出文件夹目录12SQL&gt;create directory expdir as 'D:\myjava\olm\20170913\approbe0904';SQL&gt;grant read,write on directory expdir to public; 2. 查询已经有的directory查看当前数据库导入导出路径 1select * from dba_directories; 3. 导出dmp文件注意users是本地的表空间，请用实际的表空间替换users 操作系统命令：1expdp "'/ as sysdba'" directory=expdir dumpfile=si0915.dmp logfile=si0915_exp.log schemas=appuser 4.目标数据库导入全量表方法如下：（1） 删除approbe用户 1drop user approbe cascade; （2）导入新的全量数据 注意—users是本地的表空间，请用实际的表空间替换users将appuser用户的数据导入到approbe用户下 操作系统命令：1impdp "'/ as sysdba'" directory=expdir dumpfile=si0915.dmp logfile=si0915_imp.log remap_schema=appuser:approbe 5.可能遇到的问题5.1 问题1 ：Object type TYPE failed to create with error5.1.1 错误信息12345678910111213141516171819202122232425262728293031TYPE:ORA-39083: Object type TYPE failed to create with error:ORA-02304: invalid object identifier literalFailing sql is:CREATE TYPE "APPROBEBAK"."XXX_TAB_XXX_DDL" OID '253439611478D21AE050A8C0D240D7B3' as object (id number, PROJECT_ID number, module_id number, TABLE_NAME VARCHAR2(30), status varchar2(20), action varchar2(20), ddl_part_flag number, ddl_str varchar2(32767) )ORA-39083: Object type TYPE failed to create with error:ORA-02304: invalid object identifier literalFailing sql is:CREATE TYPE "APPROBEBAK"."XXX_TAB_XXX_RM" OID '253439611487D21AE050A8C0D240D7B3' as object( owner VARCHAR2(30), table_name VARCHAR2(30), column_name VARCHAR2(30), data_type VARCHAR2(106), data_length NUMBER, data_precision NUMBER, data_scale NUMBER, nullable VARCHAR2(1), column_id NUMBER, default_length NUMBER, data_defau 5.1.2 错误原因这个错误是因为同一个OID的对象已经在数据库中存在了，所以导致冲突无法创建，通过impdp help=y命令查看帮助，发现有参数如下：1123 TRANSFORM Metadata transform to apply to applicable objects. Valid transform keywords: SEGMENT_ATTRIBUTES, STORAGE OID, and PCTSPACE. 查看联机文档发现关于OID这个参数的解释如下：11 OID - If the value is specified as n, the assignment of the exported OID during the creation of object tables and types is inhibited. Instead, a new OID is assigned. This can be useful for cloning schemas, but does not affect referenced objects. The default value is y. 意思就是说如果这个OID参数设置为“N”，那么导出的对象的OID在object table和type被创建时会被抑制，它会被分配一个新的OID，这个参数可以被用来clone schema，但是对被引用的对象是无效的。这个参数默认值为“Y”于是只要将参数transform的OID显示的设置为N即可解决，如下所示： http://www.ask600.com/ora-39083-object-type-type-failed-to-create-with-error.html 5.1.3 解决办法1impdp "'/ as sysdba'" directory=approbebak dumpfile=APPROBE_V2.4.DMP logfile=APPROBE_V2.4_imp.log remap_schema=approbe:approbebak transform=oid:n 5.2 问题2：违反唯一性约束 JOB_ID重复5.2.1 错误日志123456ORA-39083: Object type JOB failed to create with error:ORA-00001: unique constraint (SYS.I_JOB_JOB) violatedFailing sql is: BEGIN SYS.XXXX.SUBMIT( JOB=&gt; 401, LUSER=&gt; 'XXX', PUSER=&gt; 'XXX', CUSER=&gt; 'XXX', NEXT_DATE=&gt; TO_DATE('2014-11-13 22:03:45', 'YYYY-MM-DD:HH24:MI:SS'), INTERVAL=&gt; 'SYSDATE + 120/1440 ', BROKEN=&gt; FALSE, WHAT=&gt; 'dbms_refresh.refresh(''"XXX"."XXX"'');', NLSENV=&gt; 'NLS_LANGUAGE=''AMERICAN'' NLS_TERRITORY=''AMERICA'' NLS_CURRENCY=''$'' NLS_ISO_CURRENCY=''AMERProcessing object type SCHEMA_EXPORT/REFRESH_GROUPJob "SYSTEM"."SYS_IMPORT_SCHEMA_02" completed with 4 error(s) at Fri Nov 14 09:00:27 2014 elapsed 0 00:30:37 5.2.2 解决办法 （1）导出dmp文件中的ddl sql语句 1impdp &quot;&apos;/ as sysdba&apos;&quot; directory=approbebak dumpfile=APPROBE_V2.4.DMP logfile=APPROBE_V2.4_imp.log remap_schema=approbe:approbebak transform=oid:n SQLFILE=impdp.sql （2）在SQLFILE=impdp.sql找到相关JOB id的创建语句12345678910111213141516171819202122232425262728-- new object type path: SCHEMA_EXPORT/JOB BEGIN SYS.DBMS_IJOB.SUBMIT( JOB=&gt; 401, LUSER=&gt; 'APPROBEBAK', PUSER=&gt; 'APPROBEBAK', CUSER=&gt; 'APPROBEBAK', NEXT_DATE=&gt; TO_DATE('2017-12-15 09:08:27', 'YYYY-MM-DD:HH24:MI:SS'), INTERVAL=&gt; 'sysdate+1', BROKEN=&gt; FALSE, WHAT=&gt; 'pkg_XXXXX;', NLSENV=&gt; 'NLS_LANGUAGE=''AMERICAN'' NLS_TERRITORY=''AMERICA'' NLS_CURRENCY=''$'' NLS_ISO_CURRENCY=''AMERICA'' NLS_NUMERIC_CHARACTERS=''.,'' NLS_DATE_FORMAT=''DD-MON-RR'' NLS_DATE_LANGUAGE=''AMERICAN'' NLS_SORT=''BINARY''', ENV=&gt; '0102000200000000'); END; / BEGIN SYS.DBMS_IJOB.SUBMIT( JOB=&gt; 402, LUSER=&gt; 'APPROBEBAK', PUSER=&gt; 'APPROBEBAK', CUSER=&gt; 'APPROBEBAK', NEXT_DATE=&gt; TO_DATE('2017-12-15 09:08:27', 'YYYY-MM-DD:HH24:MI:SS'), INTERVAL=&gt; 'sysdate+1', BROKEN=&gt; FALSE, WHAT=&gt; 'pkg_XXXXX.222_XXXXX;', NLSENV=&gt; 'NLS_LANGUAGE=''AMERICAN'' NLS_TERRITORY=''AMERICA'' NLS_CURRENCY=''$'' NLS_ISO_CURRENCY=''AMERICA'' NLS_NUMERIC_CHARACTERS=''.,'' NLS_DATE_FORMAT=''DD-MON-RR'' NLS_DATE_LANGUAGE=''AMERICAN'' NLS_SORT=''BINARY''', ENV=&gt; '0102000200000000'); END; / （3） 查到最大JOB_ID修改语句 1select max (job) from dba_jobs; （4） 调整报错SQL语句为最大JOB_ID ，本例为403 404，手工创建如下语句 SYStem用户执行 12345678910111213141516171819202122232425262728-- new object type path: SCHEMA_EXPORT/JOB BEGIN SYS.DBMS_IJOB.SUBMIT( JOB=&gt; 403, LUSER=&gt; 'APPROBEBAK', PUSER=&gt; 'APPROBEBAK', CUSER=&gt; 'APPROBEBAK', NEXT_DATE=&gt; TO_DATE('2017-12-15 09:08:27', 'YYYY-MM-DD:HH24:MI:SS'), INTERVAL=&gt; 'sysdate+1', BROKEN=&gt; FALSE, WHAT=&gt; 'pkg_XXXXX;', NLSENV=&gt; 'NLS_LANGUAGE=''AMERICAN'' NLS_TERRITORY=''AMERICA'' NLS_CURRENCY=''$'' NLS_ISO_CURRENCY=''AMERICA'' NLS_NUMERIC_CHARACTERS=''.,'' NLS_DATE_FORMAT=''DD-MON-RR'' NLS_DATE_LANGUAGE=''AMERICAN'' NLS_SORT=''BINARY''', ENV=&gt; '0102000200000000'); END; / BEGIN SYS.DBMS_IJOB.SUBMIT( JOB=&gt; 404, LUSER=&gt; 'APPROBEBAK', PUSER=&gt; 'APPROBEBAK', CUSER=&gt; 'APPROBEBAK', NEXT_DATE=&gt; TO_DATE('2017-12-15 09:08:27', 'YYYY-MM-DD:HH24:MI:SS'), INTERVAL=&gt; 'sysdate+1', BROKEN=&gt; FALSE, WHAT=&gt; 'pkg_XXXXX.222_XXXXX;', NLSENV=&gt; 'NLS_LANGUAGE=''AMERICAN'' NLS_TERRITORY=''AMERICA'' NLS_CURRENCY=''$'' NLS_ISO_CURRENCY=''AMERICA'' NLS_NUMERIC_CHARACTERS=''.,'' NLS_DATE_FORMAT=''DD-MON-RR'' NLS_DATE_LANGUAGE=''AMERICAN'' NLS_SORT=''BINARY''', ENV=&gt; '0102000200000000'); END; / （5）查看最后结果是否插入成功 12345678910111213141516171819202122232425SQL&gt; select job,SCHEMA_USER,what from dba_jobs; JOB SCHEMA_USER---------- ------------------------------WHAT-------------------------------------------------------------------------------- 403 APPROBEBAKpkg_XXXXX.222_XXXXX; 404 APPROBEBAKpkg_XXXXX; 402 APPROBEpkg_XXXXX.222_XXXXX; JOB SCHEMA_USER---------- ------------------------------WHAT-------------------------------------------------------------------------------- 401 APPROBEpkg_XXXXX;SQL&gt; 6.欢迎关注米宝窝，持续更新中，谢谢！ 米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据泵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP实践-统计Action层方法执行时间]]></title>
    <url>%2F2018%2F09%2F10%2FSpring-AOP%E5%AE%9E%E8%B7%B5-%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[1.目标 背景：基于Spring+Strust2+Ibatis 的JAVA Web项目，后台实现分传统的3层结构，dao层，service层，action层。业务调用链一般为 action层–&gt; service层 –&gt; dao层。 目标：统计Action层某个方法的执行时间，只需要在该方法上加入一个注解便可以打印出该方法的执行时间。（通过Action层统计方法，基本能粗略统计从客户发起到完成请求反馈给前台页面的总时间。） 2.项目环境基于Spring Strust2 Ibatis JAVA Web项目 spring-XXX-3.0.5.RELEASE.jar aspectjrt-1.6.8.jar struts2-core-2.3.24.jar log4j-1.2.17.jar（等） 3.通过Spring AOP 实现3.1 注解类（为统计方法上加入该注解）1234567891011121314151617181920212223package com.rocklei123.annotaion;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @Title: rocklei123 用于记录方法耗时 * @Description: * @Author: rocklei123 * @Date: 2018/8/10 17:59 * @Version: 1.0 */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MethodPerformanceLog &#123; String module() default ""; //功能模块 String remark() default ""; // 操作备注 String operateType() default ""; // 操作类型：Add/Update/Delete/Search/Login等&#125; 3.2 log4j 配置（单独生成文件并按日期滚动）%l 表示：输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数123456789101112131415161718192021222324252627282930loglevel=DEBUGlog4j.rootLogger=$&#123;loglevel&#125;,stdout,perfilelog4j.logger.com.mchange=ERRORlog4j.logger.org.apache=ERRORlog4j.logger.org.springframework=ERRORlog4j.logger.org.apache.catalina=ERRORlog4j.logger.org.apache.struts2=ERRORlog4j.logger.org.apache.struts2.util.StrutsTypeConverter=ERRORlog4j.logger.com.opensymphony.xwork2=ERRORlog4j.logger.org.quartz=ERRORlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[sqlrobe] %d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%-5p] %t(%c:%L) - %m%nlog4j.appender.perfile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.perfile.File=$&#123;catalina.base&#125;/logs/sqlrobe/sqlrobe.loglog4j.appender.perfile.layout.ConversionPattern=[sqlrobe] %d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%-5p] %t(%c:%L) - %m%nlog4j.appender.perfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.perfile.threshold=DEBUGlog4j.appender.perfile.DatePattern='.'yyyy-MM-ddlog4j.appender.perfile.BufferedIO=truelog4j.appender.perfile.BufferSize=8192##middlewarelog4j.logger.middleware=$&#123;loglevel&#125;,middleware log4j.appender.middleware=org.apache.log4j.DailyRollingFileAppender log4j.appender.middleware.File=$&#123;catalina.base&#125;/logs/sqlrobe/middleware.loglog4j.appender.middleware.DatePattern='.'yyyy-MM-ddlog4j.appender.middleware.layout=org.apache.log4j.PatternLayout log4j.appender.middleware.layout.ConversionPattern=[middleware] %d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%-5p] %t(%l) - %m%nlog4j.additivity.middleware=false 3.3 利用 Spring AOP的思想来统计方法执行时间并打印1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.rocklei123.aop;import org.apache.log4j.Logger;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;/** * @Title: sqlrobe * @Description: * @Author: rocklei123 * @Date: 2018/8/10 17:59 * @Version: 1.0 */@Aspectpublic class PerformanceMonitorMiddleware &#123; //日志记录 private static final Logger logger = Logger.getLogger("middleware"); // 一分钟，即60000ms。为超过一分钟的方法统计到日志中 private static final long ONE_MINUTE = 60000; //定义切点 @Pointcut("@annotation(com.approbe.annotaion.MethodPerformanceLog)") public void methodCachePointcut() &#123; &#125; /** * 统计方法执行耗时Around环绕通知 * * @param joinPoint * @return */ @Around("methodCachePointcut()") public Object timeAround(ProceedingJoinPoint joinPoint) &#123; // 定义返回对象、得到方法需要的参数 Object obj = null; Object[] args = joinPoint.getArgs(); long startTime = System.currentTimeMillis(); try &#123; obj = joinPoint.proceed(args); &#125; catch (Throwable e) &#123; e.printStackTrace(); logger.error("统计某方法执行耗时环绕通知出错", e); &#125; // 获取执行的方法名 long endTime = System.currentTimeMillis(); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); String methodName = signature.getDeclaringTypeName() + "." + signature.getName(); // 打印耗时的信息 this.printExecTime(methodName, startTime, endTime); return obj; &#125; /** * 打印方法执行耗时的信息，如果超过了一定的时间，才打印 * * @param methodName * @param startTime * @param endTime */ private void printExecTime(String methodName, long startTime, long endTime) &#123; long diffTime = endTime - startTime; //超过1分钟的方法单独打印 if (diffTime &gt; ONE_MINUTE) &#123; logger.warn("-----" + methodName + " 方法执行耗时：" + diffTime + " ms"); &#125; logger.info("--------------------------------------------" + methodName + " 方法执行耗时：" + diffTime + " ms"); System.out.println("--------------------------------------" + methodName + " 方法执行耗时：" + diffTime + " ms"); &#125;&#125; 3.4 Spring 配置文件配置1234567&lt;aop:config&gt; &lt;aop:aspect id="performenceMonitorMiddlewareAop" ref="performenceMonitorMiddleware"/&gt;&lt;/aop:config&gt; &lt;!-- 注入bean--&gt;&lt;bean id="performenceMonitorMiddleware" class="com.approbe.aop.PerformanceMonitorMiddleware"&gt;&lt;/bean&gt;&lt;!-- 强制使用cglib代理--&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 为什么强制使用cglib代理呢？ spring的动态代理如果不指定，他会根据类的信息来进行代理，如果类有接口的会使用JDK的动态代理，如果类没有接口的就会使用cglib，因为struts2的ActionSupport是有实现接口的，所以他用了JDK的动态代理，那样你类中自己的属性自然就没有了。而你指定了使用cglib，那他就会动态生成一个继承你这个Action的子类，自然你Action类中可供子类访问的属性都有了。 不过struts2有自己的拦截器没必要也是不建议用spring的AOP 出处：http://bbs.csdn.net/topics/390630278 3.5 Struts2 配置文件配置分析：一般struts2+spring应用中，spring的插件只负责action的ioc部分，但并没有进行功能加强，即采用代理的机制，所有的action还是使用struts2进行管理，在使用AOP后，这些action需要由spring进行管理，如果没有被spring进行呢代理，将出现注入失败。 12 &lt;!-- 让struts2始终先考虑spring的自动装箱--&gt;&lt;constant name="struts.objectFactory.spring.autoWire.alwaysRespect" value="true" /&gt; 故如果不增加这句话，Action 中的service方法为空。会报空指针异常： 123456789101112131415java.lang.NullPointerException at com.approbe.middlware.action.WlsServerInfoAction.updateWlsBySystemId(WlsServerInfoAction.java:92) at com.approbe.middlware.action.WlsServerInfoAction$$FastClassByCGLIB$$2291828.invoke(&lt;generated&gt;) at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191) at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:688) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:91) at com.approbe.aop.PerformanceMonitorMiddleware.timeAround(PerformanceMonitorMiddleware.java:46) at sun.reflect.GeneratedMethodAccessor543.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:65) 3.6 实现效果 在希望统计的方法上加注释 123456789@RequestMapping("updateWlsBySystemId")@MethodPerformanceLog(module = "中间件批量修改/中间件树结构管理", remark = "更新功能", operateType = "更新")@Transactionalpublic void updateWlsBySystemId() throws IOException &#123; System.out.println("更新系统------------------------"); middlewareLogger.info("更新系统----------------"); String remoteAddr = GetRemoteAddrUtil.getRemoteIpAddr(request); String requestUserName = HttpSessionUtil.getSessionUserName(request); 执行方法打印执行时间 1--------------------------------------com.approbe.middlware.action.WlsServerInfoAction.updateWlsBySystemId 方法执行耗时：6853 ms 4.参考京东jinnianshilongnian 《java开发常见问题分析》 http://jinnianshilongnian.iteye.com/category/283252 京东jinnianshilongnian 《请不要再使用低级别的AOP API》 http://jinnianshilongnian.iteye.com/blog/1901694 《spring aop拦截action配置》 https://blog.csdn.net/unei66/article/details/9422339 5.欢迎关注米宝窝，持续更新中，谢谢！ 米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某保险公司核心系统中间件Hibernate 一级缓存导致内存溢出的故障诊断]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%9F%90%E4%BF%9D%E9%99%A9%E5%85%AC%E5%8F%B8%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%97%B4%E4%BB%B6Hibernate-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%2F</url>
    <content type="text"><![CDATA[1.客户环境 Weblogic版本：9.2 Linux ：suse 12 JDK版本： Sun JDK 1.5 2.故障现象在 201X 年 X 月 X 日早上 10 点多时，某保险公司核心系统多个Weblogic 的应用服务器都极度缓慢，正常的业务都无法开展。 3.详细分析应用缓慢原因检查 Weblogic 的相关日志文件，发现有内存溢出的情况发生，如下：java.lang.OutOfMemoryError: Java heap space 并产生了相关的内存溢出 HeapDump 文件：java_pid25528.hprof 随后对该文件进行下一步分析，可知： 其中占据内存较多的两组对象都是产生了 Stuck 的 Weblogic 线程，分别占用的内存是 84.85%和 10.40%，这两部分加起来是 95.25%， 说明已经占用了整个 Weblogic Server 的绝大部分内存。 进一步分析内存溢出对象进一步分析，发现大量的对象都被缓存在（org.hibernate.engine.StatefulPersistenceContext）中. 在这个缓存中的 对 象 是我们的业务对象 业务对象如下：12com.**.scms.inf.model.ScmsCcommissioncom.**.scms.inf.model.ScmsCcomissionId 由于这些缓存的数据无法释放，系统在业务量较大时，内存迅速 在 2 分钟内从 1G 增长到 4G，并且不断地进行 Full GC，导致系统极其缓慢。 StatefulPersistenceContext 解密SessionImplHibernate的一级缓存就是指Session缓存。通过查看Session接口的实现类——SessionImpl.java的源码可发现有如下两个类：12161 private transient ActionQueue actionQueue;162 private transient StatefulPersistenceContext persistenceContext; actionQueue它是一个行动队列，它主要记录crud操作的相关信息。persistenceContext它是持久化上下文，它其实才是真正的缓存。 persistenceContext缓存存储方式当执行完以下这句代码：1Customer customer = session.get(Customer.class, 1); 就会向一级缓存中存储数据，一级缓存其底层使用了一个Map集合来存储，Map的key存储的是一级缓存对象，而value存储的是快照。通过在这句代码上打个断点，然后以debug的方式运行，Watch一下session会看得更加清楚，如下： Hibernate session的清理方法从如下的代码中，也可以看出，session在执行相关清理工作时，也会执行persistenceContext.clear();1234567891011121314151617public void clear() &#123; 281 errorIfClosed(); 282 checkTransactionSynchStatus(); 283 persistenceContext.clear(); 284 actionQueue.clear(); 285 &#125; 466 /** 467 * clear all the internal collections, just 468 * to help the garbage collector, does not 469 * clear anything that is needed during the 470 * afterTransactionCompletion() phase 471 */ 472 private void cleanup() &#123; 473 persistenceContext.clear(); 474 &#125; StatefulPersistenceContext源码StatefulPersistenceContext源码 org.hibernate.engine.StatefulPersistenceContext结合以上代码和该类的实现类可以确定是一个缓存上下文引用，而且从session.cleanup()方法session.cleanup()实际调用的就是persistenceContext.clear()，注意这句话clear all the internal collections, just to help the garbage collector; 123456789101112131415/**58 import org.hibernate.util.IdentityMap;59 import org.hibernate.util.MarkerObject; 62 * A &lt;tt&gt;PersistenceContext&lt;/tt&gt; represents the state of persistent "stuff" which 63 * Hibernate is tracking. This includes persistent entities, collections, 64 * as well as proxies generated. 65 * &lt;/p&gt; 66 * There is meant to be a one-to-one correspondence between a SessionImpl and 67 * a PersistentContext. The SessionImpl uses the PersistentContext to track 68 * the current state of its context. Event-listeners then use the 69 * PersistentContext to drive their processing. 70 * 71 * @author Steve Ebersole 72 */ 4.建议由于 Hibernate 的一级缓存是其内部使用的，无法关闭或停用（随着Session 销毁）。从Hibernate 的手册或文档中可知，Hibernate 的一级缓存的清除可通过以下方式：1）对于单个对象的清除： Session session=sessionFactory.getCurrentSession(); session.evict(entity); 2）对于实体集合的清除： Session session=sessionFactory.getCurrentSession(); session.clear();建议在程序中加入对 Hibernate 一级缓存的清除工作，以便可以其内存数据可以及时释放。 关于Hibernate缓存问题可参考：Hibernate缓存策略 5.可能场景如果应用会定时启动几个quartz任务来处理复杂且影响页面、响应时间的业务，这部分业务的业务数据是从数据库查的，只有业务数据全都被处理完后这个quartz才会结束。当这几个 quartz任务的业务数据较多的时候，就会有很多对象被填入一级缓存这样一来持久化上下文中保存的对象越来越多。最终导致OOM. 6.参考http://www.docjar.com/html/api/org/hibernate/engine/StatefulPersistenceContext.java.html http://www.docjar.com/html/api/org/hibernate/impl/SessionImpl.java.html https://blog.csdn.net/yerenyuan_pku/article/details/70148567 https://www.cnblogs.com/hyl8218/p/5076338.html 7.了解Hibernate缓存策略请看Hibernate缓存策略Hibernate缓存策略 8.欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>缓存</tag>
        <tag>WebLogic</tag>
        <tag>内存溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate缓存策略]]></title>
    <url>%2F2018%2F09%2F02%2FHibernate%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一、什么是Hibernate一级缓存1、 一级缓存范围（1）Hibernate 一级缓存又称之为”Session 缓存”、“会话级缓存”（2）通过Session从数据库查询时会吧实体在内存中存储起来，下一次查询同一实体时不再从数据库获取，而是从内存中获取，这就是缓存。（3）一级缓存的生命周期和session相同;Session 销毁它也会销毁（4）一级缓存中的数据可适用范围在当前会话之内 测试用例（1）： 2、 清理一级缓存一级缓存无法取消，用两个方法管理。（1）session.evict(obj) ：会把指定的缓冲对象进行清除。（2） session.clear() ：把缓冲区内的全部对象清除，但不包括操作中的对象。 测试用例1session.evict(obj) 清理当前对象后，再次查询需要查询数据库： 测试用例2 session.clear 后（需要从数据库中查询）： 3、一级缓存注意问题：（1）query.list()是不会使用一级缓存的（2）query.iterate()会使用一级缓存，当缓存中有数据的时候，query.iterate()将所有对象的id查询出来然后到缓存中将所有对象都查询出来，如果缓存中没有数据，query.iterate()则把对象从数据库中一条一条的将数据查出来（3）一级缓存也有些时候会对程序的性能产生影响，因为在对数据库进行增删改的时候同时也要更新缓存 测试用例1 query.list 不会使用缓存： 测试用例2 query.iterate()会使用一级缓存：我们看到，当如果通过iterator()方法来获得我们对象的时候，hibernate首先会发出1条sql去查询出所有对象的 id 值，当我们如果需要查询到某个对象的具体信息的时候，hibernate此时会根据查询出来的 id 值再发sql语句去从数据库中查询对象的信息，这就是典型的 N+1 的问题。 二、Hibernate二级缓存1、 二级缓存简介二级缓存的生命周期是SessionFactory,当SessionFactory关闭时,缓存才会清空.二级缓存是每个session共用的缓存,并不是默认开启的,需要手动去配置. 2 、二级缓存配置步骤1.添加二级缓存对应的jar包.jar包:commons-logging-1.1.3.jar、ehcache.jar 2.在Hibernate的配置文件中添加Provider类的描述(即添加二级缓存接口对应外部的实现类). net.sf.ehcache.hibernate.EhCacheProvider 123456 &lt;!-- 开启二级缓存 --&gt;&lt;property name="hibernate.cache.use_second_level_cache"&gt;true&lt;/property&gt;&lt;!-- 二级缓存的提供类 在hibernate4.0版本以后我们都是配置这个属性来指定二级缓存的提供类--&gt;&lt;property name="hibernate.cache.region.factory_class"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt;&lt;!-- 二级缓存配置文件的位置 --&gt;&lt;property name="hibernate.cache.provider_configuration_file_resource_path"&gt;ehcache.xml&lt;/property&gt; 3.添加二级缓存的属性配置文件,直接放在src根目录即可.ehcache.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;ehcache&gt; &lt;!-- Sets the path to the directory where cache .data files are created. If the path is a Java System Property it is replaced by its value in the running VM. The following properties are translated: user.home - User's home directory user.dir - User's current working directory java.io.tmpdir - Default temp file path --&gt; &lt;!--指定二级缓存存放在磁盘上的位置--&gt; &lt;diskStore path="user.dir"/&gt; &lt;!--我们可以给每个实体类指定一个对应的缓存，如果没有匹配到该类，则使用这个默认的缓存配置--&gt; &lt;defaultCache maxElementsInMemory="10000" //在内存中存放的最大对象数 eternal="false" //是否永久保存缓存，设置成false timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="true" //如果对象数量超过内存中最大的数，是否将其保存到磁盘中，设置成true /&gt; &lt;!-- 1、timeToLiveSeconds的定义是：以创建时间为基准开始计算的超时时长； 2、timeToIdleSeconds的定义是：在创建时间和最近访问时间中取出离现在最近的时间作为基准计算的超时时长； 3、如果仅设置了timeToLiveSeconds，则该对象的超时时间=创建时间+timeToLiveSeconds，假设为A； 4、如果没设置timeToLiveSeconds，则该对象的超时时间=max(创建时间，最近访问时间)+timeToIdleSeconds，假设为B； 5、如果两者都设置了，则取出A、B最少的值，即min(A,B)，表示只要有一个超时成立即算超时。 --&gt; &lt;!--可以给每个实体类指定一个配置文件，通过name属性指定，要使用类的全名--&gt; &lt;cache name="com.xiaoluo.bean.Student" maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="300" timeToLiveSeconds="600" overflowToDisk="true" /&gt; &lt;cache name="sampleCache2" maxElementsInMemory="1000" eternal="true" timeToIdleSeconds="0" timeToLiveSeconds="0" overflowToDisk="false" /&gt; --&gt;&lt;/ehcache&gt; 4.如果使用xml配置，我们需要在 Student.hbm.xml 中加上一下配置。在需要被缓存的表所对应的映射文件中添加标签. 配置文件配置在标签下添加 123456789101112&lt;hibernate-mapping package="com.xiaoluo.bean"&gt; &lt;class name="Student" table="t_student"&gt; &lt;!-- 二级缓存一般设置为只读的 --&gt; &lt;cache usage="read-only"/&gt; &lt;id name="id" type="int" column="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name" column="name" type="string"&gt;&lt;/property&gt; &lt;property name="sex" column="sex" type="string"&gt;&lt;/property&gt; &lt;many-to-one name="room" column="rid" fetch="join"&gt;&lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 注解方式如果使用annotation配置，我们需要在Student这个类上加上这样一个注解：1234567891011@Entity@Table(name="t_student")@Cache(usage=CacheConcurrencyStrategy.READ_ONLY) // 表示开启二级缓存，并使用read-only策略public class Student&#123; private int id; private String name; private String sex; private Classroom room; .......&#125; 3、二级缓存注意事项（1）二级缓存的使用策略一般有这几种：read-only、nonstrict-read-write、read-write、transactional。注意：我们通常使用二级缓存都是将其配置成 read-only ，即我们应当在那些不需要进行修改的实体类上使用二级缓存，否则如果对缓存进行读写的话，性能会变差，这样设置缓存就失去了意义。（2）二级缓存缓存的仅仅是对象，如果查询出来的是对象的一些属性，则不会被加到缓存中去（3）当我们如果通过 list() 去查询两次对象时，二级缓存虽然会缓存查询出来的对象，但是我们看到发出了两条相同的查询语句，这是因为二级缓存不会缓存我们的hql查询语句，要想解决这个问题，我们就要配置我们的查询缓存了。（4）查询缓存(sessionFactory级别) 我们如果要配置查询缓存，只需要在hibernate.cfg.xml中加入一条配置即可：12 &lt;!-- 开启查询缓存 --&gt;&lt;property name="hibernate.cache.use_query_cache"&gt;true&lt;/property&gt; 然后我们如果在查询hql语句时要使用查询缓存，就需要在查询语句后面设置这样一个方法: 1234List&lt;Student&gt; ls = session.createQuery("from Student where name like ?") .setCacheable(true) //开启查询缓存，查询缓存也是SessionFactory级别的缓存 .setParameter(0, "%王%") .setFirstResult(0).setMaxResults(50).list(); 如果是在annotation中，我们还需要在这个类上加上这样一个注解：@Cacheable 4、 二级缓存使用场景 三、Hibernate一级、二级缓存的对比 参考https://www.cnblogs.com/xiaoluo501395377/p/3377604.htmlhttps://www.imooc.com/learn/465 欢迎关注米宝窝，持续更新中，谢谢！ 米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将 Oracle WebLogic Server 使用的 JDK 升级到不同的版本 (文档 ID 1600832.1)]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%A6%82%E4%BD%95%E5%B0%86-Oracle-WebLogic-Server-%E4%BD%BF%E7%94%A8%E7%9A%84-JDK-%E5%8D%87%E7%BA%A7%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E7%89%88%E6%9C%AC-%E6%96%87%E6%A1%A3-ID-1600832-1%2F</url>
    <content type="text"><![CDATA[适用于:Oracle WebLogic Server - 版本 8.1 和更高版本本文档所含信息适用于所有平台 目标本文的主要目标是说明将 Oracle WebLogic Server 安装所用的 JDK 升级到更新版本的步骤。必须注意，支持将 Java SE（或分为 JDK/JRE）更新到最新版本的前提是，这样做仍然能得到认证。因此，用户应检查目标 JDK版本是否已经过相应 Weblogic Server 版本的认证，然后自行实施以下说明中的事项。免责声明Oracle WebLogic Server 可以作为独立产品使用，也可以作为许多其它多层产品的核心，例如对于 Oracle Fusion Middleware 11g 安装。本文不会考虑新 JDK 能否得到特定 Fusion Middleware 版本认证这一点，因此，用户应自己负责查看产品认证表，以确认您的安装类型是否支持所需的 JDK 版本。 1) 对于 Oracle Fusion Middleware 11g，查看以下两个文档中的认证信息： Document 1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g ProductsDocument 431578.1 - How to Find Certification Details for Oracle Application Server 10g and Oracle Fusion Middleware.2) 对于个别的 Oracle Weblogic Server 配置，涉及 10.3.0 之前版本的，查看以下位置的认证信息：http://download.oracle.com/docs/cd/E13196_01/platform/suppconfigs/config_wls.html3) 对于 Weblogic Server 12.1.2 ，请参阅 Document 1616397.1 - After JDK Upgrade How To Change JDK References For WebLogic Server 12c如果安装的是 Oracle Fusion Middleware 11g，请参阅以下文档：Document 1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g Products 本文未涉及的两种情况： 1) 如果您的目标不是升级，而是从 Java SUN JDK 转换到 Oracle JRockit JDK，请参阅： - How To Change Type of JDK (Sun / JRockit) for FMW 11g Domain. 2) 如果您的目标是将 32 位 JDK 版本替换为新的 64 位 JDK 版本，本文不适用。请参阅： - How Re-Create, Copy, or Re-Use Existing WLS Domains from 32 bit to 64 bit Architecture 本文中的步骤通常适用于从安装过程中默认使用的 JDK 转换到更高的版本，甚至也可以同样地用来降低版本。 解决方案备选方案有两种不同方法可用来实现所需的目标。以下将分别简要介绍：A) 安装新的 JDK 主目录，使用符号链接对现有的和新的 JDK 目录进行“重命名”。按照这种方法，将不改变在安装过程中最初使用的 JDK 位置，因此只有很小的缺点，也即会保留带有版本的名称，例如 “$INSTALL_HOME/jdk_“。在任何情况下，这种方法都要比方法 B) 更为简单且不易出错。 B) 安装新的 JDK 主目录，替换所有引用 JAVA_HOME 环境变量的脚本中的该变量。 如果要进行部分升级（只影响特定域，或不影响节点管理器），这是首选的方法，但其难点在于如何知道哪些文件将会引用 JDK 位置。 要更改的初始文件列表将如下： $INSTALL_HOME/wlserver_10.3/common/bin/commEnv.sh $INSTALL_HOME/user_projects/domains//bin/setDomainEnv.sh $INSTALL_HOME/wlserver_10.3/common/nodemanager/nodemanager.properties $INSTALL_HOME/utils/bsu/bsu.sh $INSTALL_HOME/utils/quickstart/quickstart.sh $INSTALL_HOME/utils/uninstall/uninstall.sh还有更为详尽的方法来确定这些文件，即运行以下命令：1find . -type f -name &quot;*.sh&quot; -exec grep -il JAVA_HOME &#123;&#125; \; 逐步操作方法A)1) 假设源和目标位置如下：sourceJDK: /oracle/wls1033/jdk160_18targetJDK: /oracle/wls1033/jdk1.6.0_242) 停止使用当前 FMW_HOME 的所有进程。这指的是 所有域中的全部 AdminServer 和 Managed_servers， 在该 FMW_HOME 中运行的所有 nodemanager 进程，以及 有可能在特定时刻运行 Bea SmartUpgrade 的进程。 3) 重命名目录： a) 转至源 JDK 的父目录：% cd $INSTALL_HOME/b) 您可以通过执行命令 “ls -ld jdk“ 来确定其位置是否为符号链接：% ls -ld jdk160_18 如果所列出内容中jdk160_18 的属性为lrwxrwxrwx (注意第一个字母为 ‘l’)，那它是一个链接。如果所列出内容中jdk160_18 的属性为drwxrwxrwx (注意第一个字母为’d’) 那它是一个目录。c) 将现有 JDK 位置转移到“备份名称”，例如：% mv jdk160_18 jdk160_18.orig这会将 jdk160_18 重命名为 jdk160_18.orig，无论其原来是目录还是链接。 d) 创建类似如下的符号链接：% ln -s /oracle/wls1033/jdk1.6.0_24 jdk160_18e) 通过运行以下命令，验证此步骤是否成功完成：% $INSTALL_HOME/jdk160_18/bin/java -fullversion如果没有返回已安装的 JSDK 的预期版本字符串，请检查符号链接是否有效，或者向 UNIX 系统管理员寻求其它帮助。4)只有在您使用的是 WLS 10.3.6 且目标 JDK 使用的是已认证的 JAVA 7 版本（版本 1.7.0_x）的情况下，才需要手动复制某些 jar 文件，如下所示：将以下文件从 $INSTALL_HOME/modules 复制到 targetJDK/jre/lib/endorsed 目录javax.annotation_1.0.0.0_1-0.jarjavax.xml.bind_2.1.1.jarjavax.xml.ws_2.1.1.jar5) 像通常一样重新启动相应进程，它们将使用新的 JDK 版本。 方法 B)1) 找到涉及的 JDK 版本。a) sourceJDK：假设使用的 JDK 为 $INSTALL_HOME/jdk 对于使用 WLS 平台安装程序（针对 32 位 Windows、Linux 和 Solaris）执行的安装，使用的 JDK 将是 $INSTALL_HOME/jdk。对于使用 WLS 通用安装程序（针对 64 位及所有其它平台）执行的安装，JDK 可能位于文件系统中的任何其它位置。 b) targetJDK： 假设新 JDK 位于 /opt/newjdk对于以上示例，将使用以下命令：sourceJDK: /oracle/wls1033/jdk160_18targetJDK: /oracle/wls1033/jdk1.6.0_242) 停止使用当前 FMW_HOME 的所有进程。这指的是 所有域中的全部 AdminServer 和 managed_servers， 在该 FMW_HOME 中运行的所有 nodemanager 进程，以及 有可能在特定时刻运行 Bea SmartUpgrade 的进程。 3) 编辑 $INSTALL_HOME/wlserver_10.3/common/bin/commEnv.sh，更改 JAVA_HOME 位置。例如，从：1234567891011# Reset JAVA_HOME, JAVA_VENDOR and PRODUCTION_MODE unless JAVA_HOME# and JAVA_VENDOR are pre-defined.if [ -z &quot;$&#123;JAVA_HOME&#125;&quot; -o -z &quot;$&#123;JAVA_VENDOR&#125;&quot; ]; then# Set up JAVA HOMEJAVA_HOME=&quot;/oracle/wls1033/jdk160_18&quot;# Set up JAVA VENDOR, possible values are#Oracle, HP, IBM, Sun ...JAVA_VENDOR=Sun# PRODUCTION_MODE, default to the development modePRODUCTION_MODE=&quot;&quot;fi 更改为：:1234567891011# Reset JAVA_HOME, JAVA_VENDOR and PRODUCTION_MODE unless JAVA_HOME# and JAVA_VENDOR are pre-defined.if [ -z &quot;$&#123;JAVA_HOME&#125;&quot; -o -z &quot;$&#123;JAVA_VENDOR&#125;&quot; ]; then# Set up JAVA HOMEJAVA_HOME=&quot;/oracle/wls1033/jdk1.6.0_24&quot;# Set up JAVA VENDOR, possible values are#Oracle, HP, IBM, Sun ...JAVA_VENDOR=Sun# PRODUCTION_MODE, default to the development modePRODUCTION_MODE=&quot;&quot;fi 4) 对于每个域，更改其 “setDomainEnv.sh” 脚本以适应新的 JAVA_HOME。 对于默认位置和默认脚本，setDomainEnv.sh 将放在以下位置：$INSTALL_HOME/user_projects/domains//bin/setDomainEnv.sh仔细检查在何处、以何种方式更改了 JAVA_HOME 环境变量，因为这可能在不同版本之间发生变化。 例如在 WLS 10.3.3 中，这些信息如下所示：BEA_JAVA_HOME=”/oracle/wls1033/jrockit_160_17_R28.0.0-679”export BEA_JAVA_HOME SUN_JAVA_HOME=”/oracle/wls1033/jdk160_18”export SUN_JAVA_HOME if [ “${JAVA_VENDOR}” = “Oracle” ] ; thenJAVA_HOME=”${BEA_JAVA_HOME}”export JAVA_HOMEelseif [ “${JAVA_VENDOR}” = “Sun” ] ; thenJAVA_HOME=”${SUN_JAVA_HOME}”export JAVA_HOMEelseJAVA_VENDOR=”Sun”export JAVA_VENDORJAVA_HOME=”/oracle/wls1033/jdk160_18”export JAVA_HOMEfifi因此，必须对 SUN_JAVA_HOME 进行更改，以指定新的位置：SUN_JAVA_HOME=”/oracle/wls1033/jdk1.6.0_24”export SUN_JAVA_HOME5) 对默认的以及任何其它现有的 nodemanager 进程，更改在 nodemanager.properties 中指定的 JDK 位置： a) 为 $INSTALL_HOME/wlserver_10.3/common/nodemanager/nodemanager.properties 创建备份 从：PropertiesVersion=10.3javaHome=/oracle/wls1033/jdk160_18AuthenticationEnabled=trueNodeManagerHome=/oracle/wls1033/wlserver_10.3/common/nodemanagerJavaHome=/oracle/wls1033/jdk160_18/jreLogLevel=INFO更改为：PropertiesVersion=10.3javaHome=/oracle/wls1033/jdk1.6.0_24AuthenticationEnabled=trueNodeManagerHome=/oracle/wls1033/wlserver_10.3/common/nodemanagerJavaHome=/oracle/wls1033/jdk1.6.0_24/jreLogLevel=INFO6) 对于在相同 FMW_HOME 中使用的所有次要工具（如 BSU、uninstall.sh 等），均替换为新的 JDK 位置对于 Bea SmartUpgrade 工具 $INSTALL_HOME/utils/bsu/bsu.sh 更新以下行： fromJAVA_HOME=”/opt/JDK1.6.14”toJAVA_HOME=”/oracle/wls1033/jdk1.6.0_24”类似地，更改其余三个文件的 JAVA_HOME 值 $INSTALL_HOME/utils/quickstart/quickstart.sh $INSTALL_HOME/utils/uninstall/uninstall.sh7) 只有在您使用的是 WLS 10.3.6 且目标 JDK 使用的是已认证的 JAVA 7 版本（版本 1.7.0_x）的情况下，才需要手动复制某些 jar 文件，如下所示：将以下文件从 $INSTALL_HOME/modules 复制到 targetJDK/jre/lib/endorsed 目录javax.annotation_1.0.0.0_1-0.jarjavax.xml.bind_2.1.1.jarjavax.xml.ws_2.1.1.jar8) 重新启动所有需要的进程。参考NOTE:1058804.1 - How To Change The JDK Type (Sun / JRockit) or JDK Version for a Given FMW 11g DomainNOTE:1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g Products NOTE:1312755.1 - How Re-Create, Copy, or Re-Use Existing WLS Domains from 32-bit to 64-bit Architecture .欢迎关注米宝窝，持续更新中，谢谢！米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>WebLogic</category>
      </categories>
      <tags>
        <tag>weblogic</tag>
        <tag>jdk</tag>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows平台npm install hexo-cli -g 卡住问题的解决办法]]></title>
    <url>%2F2018%2F03%2F29%2Fwindows%E5%B9%B3%E5%8F%B0npm-install-hexo-cli-g-%E5%8D%A1%E4%BD%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1 问题现象windows平台npm install hexo-cli -g 卡住问题的解决办法 2 问题解决办法可以试试切换下你的NPM源。看是否能得到解决。国内的NPM有CNPM和淘宝的NPM源比较稳定。npm源切换和工具可参照站内贴 【nrm工具的使用】或者是直接用命令切换: 1npm config set registry https://registry.npm.taobao.org 3.欢迎关注米宝窝，持续更新中，谢谢！ 米宝窝 https://rocklei123.github.io/]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F03%2F28%2Fhello-world-1%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客，从此开启点滴技术生活。 水滴石穿合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。 12345678910111213141516171819202122232425262728293031323334353637package com.rocklei123.test;/** * @Title: sqlrobe * @Description: * @Author: rocklei123 * @Date: 2018/8/27 13:19 * @Version: 1.0 */public class PrintHeart &#123; public static void main(String[] args) &#123; System.out.println(printHeart("*")); &#125; private static String printHeart(String input) &#123; int[] array = &#123;0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 4, 5, 2, 3, 4, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;; StringBuffer pi = new StringBuffer(); for (int i = 0; i &lt; array.length; i++) &#123; if (i % 7 == 0) pi.append("\n"); if (array[i] == 0) pi.append(" "); else if (array[i] == 4) pi.append(" "); else if (array[i] == 5) pi.append(" 周 "); else if (array[i] == 2) pi.append(" 书 "); else if (array[i] == 3) pi.append(" 瑶 "); else pi.append(" " + input); &#125; return pi.toString(); &#125;&#125; 谨以此文献给我的女儿周书瑶！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
