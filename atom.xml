<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rocklei123 米宝窝</title>
  
  <subtitle>水滴石穿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-14T06:16:24.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rocklei123</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring AOP实践-统计方法执行时间</title>
    <link href="http://yoursite.com/2018/09/10/Spring-AOP%E5%AE%9E%E8%B7%B5-%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2018/09/10/Spring-AOP实践-统计方法执行时间/</id>
    <published>2018-09-10T14:23:37.000Z</published>
    <updated>2018-09-14T06:16:24.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h1><ul><li><p>背景：<br>基于Spring+Strust2+Ibatis 的JAVA Web项目，后台实现分传统的3层结构，dao层，service层，action层。业务调用链一般为 action层–&gt; service层 –&gt; dao层。</p></li><li><p>目标：<br>统计Action层某个方法的执行时间，只需要在该方法上加入一个注解便可以打印出该方法的执行时间。（通过Action层统计方法，基本能粗略统计从客户发起到完成请求反馈给前台页面的总时间。）</p></li></ul><h1 id="2-项目环境"><a href="#2-项目环境" class="headerlink" title="2.项目环境"></a>2.项目环境</h1><p>基于Spring Strust2 Ibatis JAVA Web项目</p><ul><li>spring-XXX-3.0.5.RELEASE.jar</li><li>aspectjrt-1.6.8.jar</li><li>struts2-core-2.3.24.jar</li><li>log4j-1.2.17.jar<br>（等）</li></ul><a id="more"></a><h1 id="3-通过Spring-AOP-实现"><a href="#3-通过Spring-AOP-实现" class="headerlink" title="3.通过Spring AOP 实现"></a>3.通过Spring AOP 实现</h1><h2 id="3-1-注解类（为统计方法上加入该注解）"><a href="#3-1-注解类（为统计方法上加入该注解）" class="headerlink" title="3.1 注解类（为统计方法上加入该注解）"></a>3.1 注解类（为统计方法上加入该注解）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rocklei123.annotaion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: rocklei123 用于记录方法耗时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: rocklei123</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/10 17:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodPerformanceLog &#123;</span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;  <span class="comment">//功能模块</span></span><br><span class="line">    <span class="function">String <span class="title">remark</span><span class="params">()</span> <span class="keyword">default</span> ""</span>; <span class="comment">// 操作备注</span></span><br><span class="line">    <span class="function">String <span class="title">operateType</span><span class="params">()</span> <span class="keyword">default</span> ""</span>; <span class="comment">// 操作类型：Add/Update/Delete/Search/Login等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-log4j-配置（单独生成文件并按日期滚动）"><a href="#3-2-log4j-配置（单独生成文件并按日期滚动）" class="headerlink" title="3.2 log4j 配置（单独生成文件并按日期滚动）"></a>3.2 log4j 配置（单独生成文件并按日期滚动）</h2><p>%l 表示：输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">loglevel=DEBUG</span><br><span class="line">log4j.rootLogger=$&#123;loglevel&#125;,stdout,perfile</span><br><span class="line">log4j.logger.com.mchange=ERROR</span><br><span class="line">log4j.logger.org.apache=ERROR</span><br><span class="line">log4j.logger.org.springframework=ERROR</span><br><span class="line">log4j.logger.org.apache.catalina=ERROR</span><br><span class="line">log4j.logger.org.apache.struts2=ERROR</span><br><span class="line">log4j.logger.org.apache.struts2.util.StrutsTypeConverter=ERROR</span><br><span class="line">log4j.logger.com.opensymphony.xwork2=ERROR</span><br><span class="line">log4j.logger.org.quartz=ERROR</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[sqlrobe] %d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%-5p] %t(%c:%L) - %m%n</span><br><span class="line">log4j.appender.perfile=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.perfile.File=$&#123;catalina.base&#125;/logs/sqlrobe/sqlrobe.log</span><br><span class="line">log4j.appender.perfile.layout.ConversionPattern=[sqlrobe] %d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%-5p] %t(%c:%L) - %m%n</span><br><span class="line">log4j.appender.perfile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.perfile.threshold=DEBUG</span><br><span class="line">log4j.appender.perfile.DatePattern='.'yyyy-MM-dd</span><br><span class="line">log4j.appender.perfile.BufferedIO=true</span><br><span class="line">log4j.appender.perfile.BufferSize=8192</span><br><span class="line"></span><br><span class="line">##middleware</span><br><span class="line">log4j.logger.middleware=$&#123;loglevel&#125;,middleware    </span><br><span class="line">log4j.appender.middleware=org.apache.log4j.DailyRollingFileAppender   </span><br><span class="line">log4j.appender.middleware.File=$&#123;catalina.base&#125;/logs/sqlrobe/middleware.log</span><br><span class="line">log4j.appender.middleware.DatePattern='.'yyyy-MM-dd</span><br><span class="line">log4j.appender.middleware.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.middleware.layout.ConversionPattern=[middleware] %d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%-5p] %t(%l) - %m%n</span><br><span class="line">log4j.additivity.middleware=false</span><br></pre></td></tr></table></figure></p><h2 id="3-3-利用-Spring-AOP的思想来统计方法执行时间并打印"><a href="#3-3-利用-Spring-AOP的思想来统计方法执行时间并打印" class="headerlink" title="3.3 利用 Spring AOP的思想来统计方法执行时间并打印"></a>3.3 利用 Spring AOP的思想来统计方法执行时间并打印</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rocklei123.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sqlrobe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: rocklei123</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/10 17:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceMonitorMiddleware</span> </span>&#123;</span><br><span class="line">    <span class="comment">//日志记录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(<span class="string">"middleware"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一分钟，即60000ms。为超过一分钟的方法统计到日志中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ONE_MINUTE = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.approbe.annotaion.MethodPerformanceLog)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodCachePointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计方法执行耗时Around环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"methodCachePointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">timeAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义返回对象、得到方法需要的参数</span></span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = joinPoint.proceed(args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(<span class="string">"统计某方法执行耗时环绕通知出错"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取执行的方法名</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        String methodName = signature.getDeclaringTypeName() + <span class="string">"."</span> + signature.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印耗时的信息</span></span><br><span class="line">        <span class="keyword">this</span>.printExecTime(methodName, startTime, endTime);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印方法执行耗时的信息，如果超过了一定的时间，才打印</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printExecTime</span><span class="params">(String methodName, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diffTime = endTime - startTime;</span><br><span class="line">        <span class="comment">//超过1分钟的方法单独打印</span></span><br><span class="line">        <span class="keyword">if</span> (diffTime &gt; ONE_MINUTE) &#123;</span><br><span class="line">            logger.warn(<span class="string">"-----"</span> + methodName + <span class="string">" 方法执行耗时："</span> + diffTime + <span class="string">" ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"--------------------------------------------"</span> + methodName + <span class="string">" 方法执行耗时："</span> + diffTime + <span class="string">" ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------"</span> + methodName + <span class="string">" 方法执行耗时："</span> + diffTime + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Spring-配置文件配置"><a href="#3-4-Spring-配置文件配置" class="headerlink" title="3.4 Spring 配置文件配置"></a>3.4 Spring 配置文件配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"performenceMonitorMiddlewareAop"</span> <span class="attr">ref</span>=<span class="string">"performenceMonitorMiddleware"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"performenceMonitorMiddleware"</span> <span class="attr">class</span>=<span class="string">"com.approbe.aop.PerformanceMonitorMiddleware"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制使用cglib代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong> 为什么强制使用cglib代理呢？</strong></p><p>spring的动态代理如果不指定，他会根据类的信息来进行代理，如果类有接口的会使用JDK的动态代理，如果类没有接口的就会使用cglib，因为struts2的ActionSupport是有实现接口的，所以他用了JDK的动态代理，那样你类中自己的属性自然就没有了。而你指定了使用cglib，那他就会动态生成一个继承你这个Action的子类，自然你Action类中可供子类访问的属性都有了。 不过struts2有自己的拦截器没必要也是不建议用spring的AOP 出处：<a href="http://bbs.csdn.net/topics/390630278" target="_blank" rel="noopener">http://bbs.csdn.net/topics/390630278</a></p><h2 id="3-5-Struts2-配置文件配置"><a href="#3-5-Struts2-配置文件配置" class="headerlink" title="3.5 Struts2 配置文件配置"></a>3.5 Struts2 配置文件配置</h2><p>分析：一般struts2+spring应用中，spring的插件只负责action的ioc部分，但并没有进行功能加强，即采用代理的机制，所有的action还是使用struts2进行管理，在使用AOP后，这些action需要由spring进行管理，如果没有被spring进行呢代理，将出现注入失败。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- 让struts2始终先考虑spring的自动装箱--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.objectFactory.spring.autoWire.alwaysRespect"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>故如果不增加这句话，Action 中的service方法为空。会报空指针异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.approbe.middlware.action.WlsServerInfoAction.updateWlsBySystemId(WlsServerInfoAction.java:<span class="number">92</span>)</span><br><span class="line">at com.approbe.middlware.action.WlsServerInfoAction$$FastClassByCGLIB$$<span class="number">2291828</span>.invoke(&lt;generated&gt;)</span><br><span class="line">at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:<span class="number">191</span>)</span><br><span class="line">at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:<span class="number">688</span>)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class="number">150</span>)</span><br><span class="line">at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:<span class="number">91</span>)</span><br><span class="line">at com.approbe.aop.PerformanceMonitorMiddleware.timeAround(PerformanceMonitorMiddleware.java:<span class="number">46</span>)</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor543.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">at java.lang.reflect.Method.invoke(Unknown Source)</span><br><span class="line">at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:<span class="number">621</span>)</span><br><span class="line">at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:<span class="number">610</span>)</span><br><span class="line">at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:<span class="number">65</span>)</span><br></pre></td></tr></table></figure><h2 id="3-6-实现效果"><a href="#3-6-实现效果" class="headerlink" title="3.6 实现效果"></a>3.6 实现效果</h2><ul><li>在希望统计的方法上加注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"updateWlsBySystemId"</span>)</span><br><span class="line"><span class="meta">@MethodPerformanceLog</span>(<span class="keyword">module</span> = <span class="string">"中间件批量修改/中间件树结构管理"</span>, remark = <span class="string">"更新功能"</span>, operateType = <span class="string">"更新"</span>)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateWlsBySystemId</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"更新系统------------------------"</span>);</span><br><span class="line">    middlewareLogger.info(<span class="string">"更新系统----------------"</span>);</span><br><span class="line">    String remoteAddr = GetRemoteAddrUtil.getRemoteIpAddr(request);</span><br><span class="line">    String requestUserName = HttpSessionUtil.getSessionUserName(request);</span><br></pre></td></tr></table></figure><ul><li>执行方法打印执行时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------com.approbe.middlware.action.WlsServerInfoAction.updateWlsBySystemId 方法执行耗时：<span class="number">6853</span> ms</span><br></pre></td></tr></table></figure><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h1><p><a href="http://jinnianshilongnian.iteye.com/category/283252" title="京东jinnianshilongnian 《java开发常见问题分析》" target="_blank" rel="noopener">京东jinnianshilongnian 《java开发常见问题分析》 http://jinnianshilongnian.iteye.com/category/283252 </a></p><p><a href="http://jinnianshilongnian.iteye.com/blog/1901694" title="京东jinnianshilongnian 《请不要再使用低级别的AOP API》" target="_blank" rel="noopener">京东jinnianshilongnian 《请不要再使用低级别的AOP API》 http://jinnianshilongnian.iteye.com/blog/1901694</a></p><p><a href="https://blog.csdn.net/unei66/article/details/9422339" title="9876- 《spring aop拦截action配置》" target="_blank" rel="noopener">《spring aop拦截action配置》 https://blog.csdn.net/unei66/article/details/9422339</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-目标&quot;&gt;&lt;a href=&quot;#1-目标&quot; class=&quot;headerlink&quot; title=&quot;1.目标&quot;&gt;&lt;/a&gt;1.目标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景：&lt;br&gt;基于Spring+Strust2+Ibatis 的JAVA Web项目，后台实现分传统的3层结构，dao层，service层，action层。业务调用链一般为 action层–&amp;gt; service层 –&amp;gt; dao层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目标：&lt;br&gt;统计Action层某个方法的执行时间，只需要在该方法上加入一个注解便可以打印出该方法的执行时间。（通过Action层统计方法，基本能粗略统计从客户发起到完成请求反馈给前台页面的总时间。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-项目环境&quot;&gt;&lt;a href=&quot;#2-项目环境&quot; class=&quot;headerlink&quot; title=&quot;2.项目环境&quot;&gt;&lt;/a&gt;2.项目环境&lt;/h1&gt;&lt;p&gt;基于Spring Strust2 Ibatis JAVA Web项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spring-XXX-3.0.5.RELEASE.jar&lt;/li&gt;
&lt;li&gt;aspectjrt-1.6.8.jar&lt;/li&gt;
&lt;li&gt;struts2-core-2.3.24.jar&lt;/li&gt;
&lt;li&gt;log4j-1.2.17.jar&lt;br&gt;（等）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring AOP" scheme="http://yoursite.com/tags/Spring-AOP/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>某保险公司核心系统中间件Hibernate 一级缓存导致内存溢出的故障诊断</title>
    <link href="http://yoursite.com/2018/09/02/%E6%9F%90%E4%BF%9D%E9%99%A9%E5%85%AC%E5%8F%B8%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%97%B4%E4%BB%B6Hibernate-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/"/>
    <id>http://yoursite.com/2018/09/02/某保险公司核心系统中间件Hibernate-一级缓存导致内存溢出的故障诊断/</id>
    <published>2018-09-02T14:15:45.000Z</published>
    <updated>2018-09-14T01:52:46.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-客户环境"><a href="#1-客户环境" class="headerlink" title="1.客户环境"></a>1.客户环境</h2><ul><li>Weblogic版本：9.2</li><li>Linux ：suse 12</li><li>JDK版本： Sun JDK 1.5</li></ul><h2 id="2-故障现象"><a href="#2-故障现象" class="headerlink" title="2.故障现象"></a>2.故障现象</h2><p>在 201X 年 X 月 X 日早上 10 点多时，某保险公司核心系统多个<br>Weblogic 的应用服务器都极度缓慢，正常的业务都无法开展。</p><a id="more"></a><h2 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h2><h3 id="应用缓慢原因"><a href="#应用缓慢原因" class="headerlink" title="应用缓慢原因"></a>应用缓慢原因</h3><p>检查 Weblogic 的相关日志文件，发现有内存溢出的情况发生，如下：<br>java.lang.OutOfMemoryError: Java heap space</p><p>并产生了相关的内存溢出 HeapDump 文件：java_pid25528.hprof 随后对该文件进行下一步分析，可知：</p><p><img src="/2018/09/02/某保险公司核心系统中间件Hibernate-一级缓存导致内存溢出的故障诊断/markdown-img-paste-2018090222312212.png" alt="hibernate_cache_outOfmemory1"></p><p>其中占据内存较多的两组对象都是产生了 Stuck 的 Weblogic 线程，分别占用的内存是 84.85%和 10.40%，这两部分加起来是 95.25%，</p><p>说明已经占用了整个 Weblogic Server 的绝大部分内存。</p><h3 id="进一步分析内存溢出对象"><a href="#进一步分析内存溢出对象" class="headerlink" title="进一步分析内存溢出对象"></a>进一步分析内存溢出对象</h3><p>进一步分析，发现大量的对象都被缓存在<br>（org.hibernate.engine.StatefulPersistenceContext）中.<br><img src="/2018/09/02/某保险公司核心系统中间件Hibernate-一级缓存导致内存溢出的故障诊断/markdown-img-paste-20180902223516304.png" alt="hibernate_cache_outofMemory_statefulPeristence"></p><p>在这个缓存中的    对    象    是我们的业务对象</p><p><img src="/2018/09/02/某保险公司核心系统中间件Hibernate-一级缓存导致内存溢出的故障诊断/markdown-img-paste-20180902223734874.png" alt="hibernate_cache_outofMemory_entityName"></p><p>业务对象如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.**.scms.inf.model.ScmsCcommission</span><br><span class="line">com.**.scms.inf.model.ScmsCcomissionId</span><br></pre></td></tr></table></figure></p><p>由于这些缓存的数据无法释放，系统在业务量较大时，内存迅速 在 2 分钟内从 1G 增长到 4G，并且不断地进行 Full GC，导致系统极其缓慢。</p><h3 id="StatefulPersistenceContext-解密"><a href="#StatefulPersistenceContext-解密" class="headerlink" title="StatefulPersistenceContext 解密"></a>StatefulPersistenceContext 解密</h3><h4 id="SessionImpl"><a href="#SessionImpl" class="headerlink" title="SessionImpl"></a>SessionImpl</h4><p>Hibernate的一级缓存就是指Session缓存。通过查看Session接口的实现类——SessionImpl.java的源码可发现有如下两个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">161</span>   <span class="keyword">private</span> <span class="keyword">transient</span> ActionQueue actionQueue;</span><br><span class="line"><span class="number">162</span>   <span class="keyword">private</span> <span class="keyword">transient</span> StatefulPersistenceContext persistenceContext;</span><br></pre></td></tr></table></figure></p><p>actionQueue它是一个行动队列，它主要记录crud操作的相关信息。<br>persistenceContext它是持久化上下文，它其实才是真正的缓存。</p><h4 id="persistenceContext缓存存储方式"><a href="#persistenceContext缓存存储方式" class="headerlink" title="persistenceContext缓存存储方式"></a>persistenceContext缓存存储方式</h4><p>当执行完以下这句代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer customer = session.get(Customer.class, 1);</span><br></pre></td></tr></table></figure></p><p>就会向一级缓存中存储数据，一级缓存其底层使用了一个Map集合来存储，Map的key存储的是一级缓存对象，而value存储的是快照。通过在这句代码上打个断点，然后以debug的方式运行，Watch一下session会看得更加清楚，如下：</p><p><img src="/2018/09/02/某保险公司核心系统中间件Hibernate-一级缓存导致内存溢出的故障诊断/markdown-img-paste-20180902232812809.png" alt="persistenceContext-debug1"></p><p><img src="/2018/09/02/某保险公司核心系统中间件Hibernate-一级缓存导致内存溢出的故障诊断/markdown-img-paste-20180902233103142.png" alt="persistenceContext-debug2"></p><h4 id="Hibernate-session的清理方法"><a href="#Hibernate-session的清理方法" class="headerlink" title="Hibernate session的清理方法"></a>Hibernate session的清理方法</h4><p>从如下的代码中，也可以看出，session在执行相关清理工作时，也会执行persistenceContext.clear();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">  281   errorIfClosed();</span><br><span class="line">  282   checkTransactionSynchStatus();</span><br><span class="line">  283   persistenceContext.clear();</span><br><span class="line">  284   actionQueue.clear();</span><br><span class="line">  285   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  466   /**</span><br><span class="line">  467    * clear all the internal collections, just</span><br><span class="line">  468    * to help the garbage collector, does not</span><br><span class="line">  469    * clear anything that is needed during the</span><br><span class="line">  470    * afterTransactionCompletion() phase</span><br><span class="line">  471    */</span><br><span class="line">  472   private void cleanup() &#123;</span><br><span class="line">  473   persistenceContext.clear();</span><br><span class="line">  474   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="StatefulPersistenceContext源码"><a href="#StatefulPersistenceContext源码" class="headerlink" title="StatefulPersistenceContext源码"></a>StatefulPersistenceContext源码</h4><p><a href="http://www.docjar.com/html/api/org/hibernate/engine/StatefulPersistenceContext.java.html &quot;StatefulPersistenceContext源码" target="_blank" rel="noopener">StatefulPersistenceContext源码</a></p><p>org.hibernate.engine.StatefulPersistenceContext<br>结合以上代码和该类的实现类可以确定是一个缓存上下文引用，而且从session.cleanup()方法session.cleanup()实际调用的就是persistenceContext.clear()，注意这句话<strong>clear all the internal collections, just to help the garbage collector;</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">58   import org.hibernate.util.IdentityMap;</span></span><br><span class="line"><span class="comment">59   import org.hibernate.util.MarkerObject;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   62    * A &lt;tt&gt;PersistenceContext&lt;/tt&gt; represents the state of persistent "stuff" which</span></span><br><span class="line"><span class="comment">   63    * Hibernate is tracking.  This includes persistent entities, collections,</span></span><br><span class="line"><span class="comment">   64    * as well as proxies generated.</span></span><br><span class="line"><span class="comment">   65    * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   66    * There is meant to be a one-to-one correspondence between a SessionImpl and</span></span><br><span class="line"><span class="comment">   67    * a PersistentContext.  The SessionImpl uses the PersistentContext to track</span></span><br><span class="line"><span class="comment">   68    * the current state of its context.  Event-listeners then use the</span></span><br><span class="line"><span class="comment">   69    * PersistentContext to drive their processing.</span></span><br><span class="line"><span class="comment">   70    *</span></span><br><span class="line"><span class="comment">   71    * <span class="doctag">@author</span> Steve Ebersole</span></span><br><span class="line"><span class="comment">   72    */</span></span><br></pre></td></tr></table></figure></p><h2 id="4-建议"><a href="#4-建议" class="headerlink" title="4.建议"></a>4.建议</h2><p><strong>由于 Hibernate 的一级缓存是其内部使用的，无法关闭或停用</strong>（随着Session 销毁）。从<br>Hibernate 的手册或文档中可知，Hibernate 的一级缓存的清除可通过以下方式：<br>1）对于单个对象的清除：</p><p>Session session=sessionFactory.getCurrentSession(); session.evict(entity);</p><p>2）对于实体集合的清除：</p><p>Session session=sessionFactory.getCurrentSession(); session.clear();<br>建议在程序中加入对 Hibernate 一级缓存的清除工作，以便可以其<br>内存数据可以及时释放。</p><p>关于Hibernate缓存问题可参考：<br><a href="https://rocklei123.github.io/2018/09/02/Hibernate缓存策略/" title="Hibernate缓存策略" target="_blank" rel="noopener">Hibernate缓存策略</a></p><h2 id="5-可能场景"><a href="#5-可能场景" class="headerlink" title="5.可能场景"></a>5.可能场景</h2><p>如果应用会定时启动几个quartz任务来处理复杂且影响页面、响应时间的业务，这部分业务的业务数据是从数据库查的，只有业务数据全都被处理完后这个quartz才会结束。<br>当这几个 quartz任务的业务数据较多的时候，就会有很多对象被填入一级缓存这样一来持久化上下文中保存的对象越来越多。最终导致OOM.</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><p><a href="http://www.docjar.com/html/api/org/hibernate/engine/StatefulPersistenceContext.java.html" target="_blank" rel="noopener">http://www.docjar.com/html/api/org/hibernate/engine/StatefulPersistenceContext.java.html</a></p><p><a href="http://www.docjar.com/html/api/org/hibernate/impl/SessionImpl.java.html" target="_blank" rel="noopener">http://www.docjar.com/html/api/org/hibernate/impl/SessionImpl.java.html</a></p><p><a href="https://blog.csdn.net/yerenyuan_pku/article/details/70148567" target="_blank" rel="noopener">https://blog.csdn.net/yerenyuan_pku/article/details/70148567</a></p><p><a href="https://www.cnblogs.com/hyl8218/p/5076338.html" target="_blank" rel="noopener">https://www.cnblogs.com/hyl8218/p/5076338.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-客户环境&quot;&gt;&lt;a href=&quot;#1-客户环境&quot; class=&quot;headerlink&quot; title=&quot;1.客户环境&quot;&gt;&lt;/a&gt;1.客户环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Weblogic版本：9.2&lt;/li&gt;
&lt;li&gt;Linux ：suse 12&lt;/li&gt;
&lt;li&gt;JDK版本： Sun JDK 1.5&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-故障现象&quot;&gt;&lt;a href=&quot;#2-故障现象&quot; class=&quot;headerlink&quot; title=&quot;2.故障现象&quot;&gt;&lt;/a&gt;2.故障现象&lt;/h2&gt;&lt;p&gt;在 201X 年 X 月 X 日早上 10 点多时，某保险公司核心系统多个&lt;br&gt;Weblogic 的应用服务器都极度缓慢，正常的业务都无法开展。&lt;/p&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://yoursite.com/categories/Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="内存溢出" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
      <category term="WebLogic" scheme="http://yoursite.com/tags/WebLogic/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate缓存策略</title>
    <link href="http://yoursite.com/2018/09/02/Hibernate%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2018/09/02/Hibernate缓存策略/</id>
    <published>2018-09-02T08:29:56.000Z</published>
    <updated>2018-09-02T13:31:45.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Hibernate一级缓存"><a href="#一、什么是Hibernate一级缓存" class="headerlink" title="一、什么是Hibernate一级缓存"></a>一、什么是Hibernate一级缓存</h2><h3 id="1、-一级缓存范围"><a href="#1、-一级缓存范围" class="headerlink" title="1、 一级缓存范围"></a>1、 一级缓存范围</h3><p>（1）Hibernate 一级缓存又称之为”Session 缓存”、“会话级缓存”<br>（2）通过Session从数据库查询时会吧实体在内存中存储起来，下一次查询同一实体时不再从数据库获取，而是从内存中获取，这就是缓存。<br>（3）一级缓存的生命周期和session相同;Session 销毁它也会销毁<br>（4）一级缓存中的数据可适用范围在当前会话之内</p><p>测试用例（1）：<br><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-20180902171836974.png" alt="test1"></p><a id="more"></a><h3 id="2、-清理一级缓存"><a href="#2、-清理一级缓存" class="headerlink" title="2、 清理一级缓存"></a>2、 清理一级缓存</h3><p>一级缓存无法取消，用两个方法管理。<br>（1）session.evict(obj) ：会把指定的缓冲对象进行清除。<br>（2）  session.clear() ：把缓冲区内的全部对象清除，但不包括操作中的对象。</p><p>测试用例1session.evict(obj)  清理当前对象后，再次查询需要查询数据库：<br><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-2018090217192062.png" alt="hibernate_evict_test"></p><p>测试用例2 session.clear 后（需要从数据库中查询）：<br><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-2018090217195599.png" alt="hibernate_clear_test"></p><h3 id="3、一级缓存注意问题："><a href="#3、一级缓存注意问题：" class="headerlink" title="3、一级缓存注意问题："></a>3、一级缓存注意问题：</h3><p>（1）query.list()是不会使用一级缓存的<br>（2）query.iterate()会使用一级缓存，当缓存中有数据的时候，query.iterate()将所有对象的id查询出来然后到缓存中将所有对象都查询出来，如果缓存中没有数据，query.iterate()则把对象从数据库中一条一条的将数据查出来<br>（3）一级缓存也有些时候会对程序的性能产生影响，因为在对数据库进行增删改的时候同时也要更新缓存</p><p>测试用例1 query.list 不会使用缓存：<br><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-20180902172130128.png" alt="hibernate_query_list"></p><p>测试用例2 query.iterate()会使用一级缓存：<br><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-20180902172229735.png" alt="hibernate_query_iterate"><br>我们看到，当如果通过iterator()方法来获得我们对象的时候，hibernate首先会发出1条sql去查询出所有对象的 id 值，当我们如果需要查询到某个对象的具体信息的时候，hibernate此时会根据查询出来的 id 值再发sql语句去从数据库中查询对象的信息，这就是典型的 N+1 的问题。</p><h2 id="二、Hibernate二级缓存"><a href="#二、Hibernate二级缓存" class="headerlink" title="二、Hibernate二级缓存"></a>二、Hibernate二级缓存</h2><h3 id="1、-二级缓存简介"><a href="#1、-二级缓存简介" class="headerlink" title="1、 二级缓存简介"></a>1、 二级缓存简介</h3><p>二级缓存的生命周期是SessionFactory,当SessionFactory关闭时,缓存才会清空.<br>二级缓存是每个session共用的缓存,并不是默认开启的,需要手动去配置.</p><p><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-20180902172334211.png" alt="introduce_hibernate_cache2"></p><h3 id="2-、二级缓存配置步骤"><a href="#2-、二级缓存配置步骤" class="headerlink" title="2 、二级缓存配置步骤"></a>2 、二级缓存配置步骤</h3><p>1.添加二级缓存对应的jar包.<br>jar包:commons-logging-1.1.3.jar、ehcache.jar</p><p>2.在Hibernate的配置文件中添加Provider类的描述(即添加二级缓存接口对应外部的实现类).</p><property name="cache.provider_class">net.sf.ehcache.hibernate.EhCacheProvider</property><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　　　 <span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.use_second_level_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 二级缓存的提供类 在hibernate4.0版本以后我们都是配置这个属性来指定二级缓存的提供类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.region.factory_class"</span>&gt;</span>org.hibernate.cache.ehcache.EhCacheRegionFactory<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 二级缓存配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.provider_configuration_file_resource_path"</span>&gt;</span>ehcache.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.添加二级缓存的属性配置文件,直接放在src根目录即可.<br>ehcache.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Sets the path to the directory where cache .data files are created.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         If the path is a Java System Property it is replaced by</span></span><br><span class="line"><span class="comment">         its value in the running VM.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The following properties are translated:</span></span><br><span class="line"><span class="comment">         user.home - User's home directory</span></span><br><span class="line"><span class="comment">         user.dir - User's current working directory</span></span><br><span class="line"><span class="comment">         java.io.tmpdir - Default temp file path --&gt;</span></span><br><span class="line">　　</span><br><span class="line">　　<span class="comment">&lt;!--指定二级缓存存放在磁盘上的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"user.dir"</span>/&gt;</span>　　</span><br><span class="line"></span><br><span class="line">　　<span class="comment">&lt;!--我们可以给每个实体类指定一个对应的缓存，如果没有匹配到该类，则使用这个默认的缓存配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span>　　//在内存中存放的最大对象数</span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">"false"</span>　　　　　　　　　//是否永久保存缓存，设置成<span class="attr">false</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span>　　　　</span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span>　　　　</span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">"true"</span>　　　　　//如果对象数量超过内存中最大的数，是否将其保存到磁盘中，设置成<span class="attr">true</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">　　</span><br><span class="line">　　<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">　　　　1、timeToLiveSeconds的定义是：以创建时间为基准开始计算的超时时长；</span></span><br><span class="line"><span class="comment">　　　　2、timeToIdleSeconds的定义是：在创建时间和最近访问时间中取出离现在最近的时间作为基准计算的超时时长；</span></span><br><span class="line"><span class="comment">　　　　3、如果仅设置了timeToLiveSeconds，则该对象的超时时间=创建时间+timeToLiveSeconds，假设为A；</span></span><br><span class="line"><span class="comment">　　　　4、如果没设置timeToLiveSeconds，则该对象的超时时间=max(创建时间，最近访问时间)+timeToIdleSeconds，假设为B；</span></span><br><span class="line"><span class="comment">　　　　5、如果两者都设置了，则取出A、B最少的值，即min(A,B)，表示只要有一个超时成立即算超时。</span></span><br><span class="line"><span class="comment">　　--&gt;</span></span><br><span class="line"></span><br><span class="line">　　<span class="comment">&lt;!--可以给每个实体类指定一个配置文件，通过name属性指定，要使用类的全名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"com.xiaoluo.bean.Student"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"sampleCache2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span> --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.如果使用xml配置，我们需要在 Student.hbm.xml 中加上一下配置。在需要被缓存的表所对应的映射文件中添加<cache>标签.</cache></p><h4 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h4><p>在<class>标签下添加<cache usage="read-only"></cache></class></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.xiaoluo.bean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Student"</span> <span class="attr">table</span>=<span class="string">"t_student"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 二级缓存一般设置为只读的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cache</span> <span class="attr">usage</span>=<span class="string">"read-only"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"room"</span> <span class="attr">column</span>=<span class="string">"rid"</span> <span class="attr">fetch</span>=<span class="string">"join"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><p>如果使用annotation配置，我们需要在Student这个类上加上这样一个注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"t_student"</span>)</span><br><span class="line"><span class="meta">@Cache</span>(usage=CacheConcurrencyStrategy.READ_ONLY)　　<span class="comment">//　　表示开启二级缓存，并使用read-only策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Classroom room;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、二级缓存注意事项"><a href="#3、二级缓存注意事项" class="headerlink" title="3、二级缓存注意事项"></a>3、二级缓存注意事项</h3><p>（1）二级缓存的使用策略一般有这几种：read-only、nonstrict-read-write、read-write、transactional。注意：我们通常使用二级缓存都是将其配置成 read-only ，即我们应当在那些不需要进行修改的实体类上使用二级缓存，否则如果对缓存进行读写的话，性能会变差，这样设置缓存就失去了意义。<br>（2）二级缓存缓存的仅仅是对象，如果查询出来的是对象的一些属性，则不会被加到缓存中去<br>（3）当我们如果通过 list() 去查询两次对象时，二级缓存虽然会缓存查询出来的对象，但是我们看到发出了两条相同的查询语句，这是因为二级缓存不会缓存我们的hql查询语句，要想解决这个问题，我们就要配置我们的查询缓存了。<br>（4）查询缓存(sessionFactory级别)</p><p>我们如果要配置查询缓存，只需要在hibernate.cfg.xml中加入一条配置即可：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　　　　<span class="comment">&lt;!-- 开启查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.use_query_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后我们如果在查询hql语句时要使用查询缓存，就需要在查询语句后面设置这样一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; ls = session.createQuery(<span class="string">"from Student where name like ?"</span>)</span><br><span class="line">                    .setCacheable(<span class="keyword">true</span>)　　<span class="comment">//开启查询缓存，查询缓存也是SessionFactory级别的缓存</span></span><br><span class="line">                    .setParameter(<span class="number">0</span>, <span class="string">"%王%"</span>)</span><br><span class="line">                    .setFirstResult(<span class="number">0</span>).setMaxResults(<span class="number">50</span>).list();</span><br></pre></td></tr></table></figure><p>如果是在annotation中，我们还需要在这个类上加上这样一个注解：@Cacheable</p><h3 id="4、-二级缓存使用场景"><a href="#4、-二级缓存使用场景" class="headerlink" title="4、 二级缓存使用场景"></a>4、 二级缓存使用场景</h3><p><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-20180902172551857.png" alt="hibernate_cache2_use"></p><h2 id="三、Hibernate一级、二级缓存的对比"><a href="#三、Hibernate一级、二级缓存的对比" class="headerlink" title="三、Hibernate一级、二级缓存的对比"></a>三、Hibernate一级、二级缓存的对比</h2><p><img src="/2018/09/02/Hibernate缓存策略/markdown-img-paste-20180902172656770.png" alt="hibernate_cache_compare"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xiaoluo501395377/p/3377604.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoluo501395377/p/3377604.html</a><br><a href="https://www.imooc.com/learn/465" target="_blank" rel="noopener">https://www.imooc.com/learn/465</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是Hibernate一级缓存&quot;&gt;&lt;a href=&quot;#一、什么是Hibernate一级缓存&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Hibernate一级缓存&quot;&gt;&lt;/a&gt;一、什么是Hibernate一级缓存&lt;/h2&gt;&lt;h3 id=&quot;1、-一级缓存范围&quot;&gt;&lt;a href=&quot;#1、-一级缓存范围&quot; class=&quot;headerlink&quot; title=&quot;1、 一级缓存范围&quot;&gt;&lt;/a&gt;1、 一级缓存范围&lt;/h3&gt;&lt;p&gt;（1）Hibernate 一级缓存又称之为”Session 缓存”、“会话级缓存”&lt;br&gt;（2）通过Session从数据库查询时会吧实体在内存中存储起来，下一次查询同一实体时不再从数据库获取，而是从内存中获取，这就是缓存。&lt;br&gt;（3）一级缓存的生命周期和session相同;Session 销毁它也会销毁&lt;br&gt;（4）一级缓存中的数据可适用范围在当前会话之内&lt;/p&gt;
&lt;p&gt;测试用例（1）：&lt;br&gt;&lt;img src=&quot;/2018/09/02/Hibernate缓存策略/markdown-img-paste-20180902171836974.png&quot; alt=&quot;test1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://yoursite.com/categories/Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>如何将 Oracle WebLogic Server 使用的 JDK 升级到不同的版本 (文档 ID 1600832.1)</title>
    <link href="http://yoursite.com/2018/05/04/%E5%A6%82%E4%BD%95%E5%B0%86-Oracle-WebLogic-Server-%E4%BD%BF%E7%94%A8%E7%9A%84-JDK-%E5%8D%87%E7%BA%A7%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E7%89%88%E6%9C%AC-%E6%96%87%E6%A1%A3-ID-1600832-1/"/>
    <id>http://yoursite.com/2018/05/04/如何将-Oracle-WebLogic-Server-使用的-JDK-升级到不同的版本-文档-ID-1600832-1/</id>
    <published>2018-05-04T07:16:52.000Z</published>
    <updated>2018-09-02T08:20:38.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="适用于"><a href="#适用于" class="headerlink" title="适用于:"></a>适用于:</h2><p>Oracle WebLogic Server - 版本 8.1 和更高版本<br>本文档所含信息适用于所有平台</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>本文的主要目标是说明将 Oracle WebLogic Server 安装所用的 JDK 升级到更新版本的步骤。<br>必须注意，支持将 Java SE（或分为 JDK/JRE）更新到最新版本的前提是，这样做仍然能得到认证。因此，用户应检查目标 JDK版本是否已经过相应 Weblogic Server 版本的认证，然后自行实施以下说明中的事项。<br>免责声明<br>Oracle WebLogic Server 可以作为独立产品使用，也可以作为许多其它多层产品的核心，例如对于 Oracle Fusion Middleware 11g 安装。本文不会考虑新 JDK 能否得到特定 Fusion Middleware 版本认证这一点，因此，用户应自己负责查看产品认证表，以确认您的安装类型是否支持所需的 JDK 版本。</p><p>1) 对于 Oracle Fusion Middleware 11g，查看以下两个文档中的认证信息：</p><p>Document 1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g Products<br>Document 431578.1 - How to Find Certification Details for Oracle Application Server 10g and Oracle Fusion Middleware.<br>2) 对于个别的 Oracle Weblogic Server 配置，涉及 10.3.0 之前版本的，查看以下位置的认证信息：<br><a href="http://download.oracle.com/docs/cd/E13196_01/platform/suppconfigs/config_wls.html" target="_blank" rel="noopener">http://download.oracle.com/docs/cd/E13196_01/platform/suppconfigs/config_wls.html</a><br>3) 对于 Weblogic Server 12.1.2 ，请参阅 Document 1616397.1 - After JDK Upgrade How To Change JDK References For WebLogic Server 12c<br>如果安装的是 Oracle Fusion Middleware 11g，请参阅以下文档：<br>Document 1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g Products</p><p>本文未涉及的两种情况：</p><p>1) 如果您的目标不是升级，而是从 Java SUN JDK 转换到 Oracle JRockit JDK，请参阅： <document 1058804.1=""> - How To Change Type of JDK (Sun / JRockit) for FMW 11g Domain.</document></p><p>2) 如果您的目标是将 32 位 JDK 版本替换为新的 64 位 JDK 版本，本文不适用。请参阅： <document 1312755.1=""> - How Re-Create, Copy, or Re-Use Existing WLS Domains from 32 bit to 64 bit Architecture</document></p><p>本文中的步骤通常适用于从安装过程中默认使用的 JDK 转换到更高的版本，甚至也可以同样地用来降低版本。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>备选方案<br>有两种不同方法可用来实现所需的目标。以下将分别简要介绍：<br>A) 安装新的 JDK 主目录，使用符号链接对现有的和新的 JDK 目录进行“重命名”。<br>按照这种方法，将不改变在安装过程中最初使用的 JDK 位置，因此只有很小的缺点，也即会保留带有版本的名称，例如 “$INSTALL_HOME/jdk_<version>“。<br>在任何情况下，这种方法都要比方法 B) 更为简单且不易出错。</version></p><p>B) 安装新的 JDK 主目录，替换所有引用 JAVA_HOME 环境变量的脚本中的该变量。</p><p>如果要进行部分升级（只影响特定域，或不影响节点管理器），这是首选的方法，但其难点在于如何知道哪些文件将会引用 JDK 位置。</p><p>要更改的初始文件列表将如下：</p><ul><li>$INSTALL_HOME/wlserver_10.3/common/bin/commEnv.sh</li><li>$INSTALL_HOME/user_projects/domains/<mydomain>/bin/setDomainEnv.sh</mydomain></li><li>$INSTALL_HOME/wlserver_10.3/common/nodemanager/nodemanager.properties</li><li>$INSTALL_HOME/utils/bsu/bsu.sh</li><li>$INSTALL_HOME/utils/quickstart/quickstart.sh</li><li>$INSTALL_HOME/utils/uninstall/uninstall.sh<br>还有更为详尽的方法来确定这些文件，即运行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.sh&quot; -exec grep -il JAVA_HOME &#123;&#125; \;</span><br></pre></td></tr></table></figure></li></ul><h2 id="逐步操作"><a href="#逐步操作" class="headerlink" title="逐步操作"></a>逐步操作</h2><h3 id="方法A"><a href="#方法A" class="headerlink" title="方法A)"></a>方法A)</h3><p>1) 假设源和目标位置如下：<br>sourceJDK: /oracle/wls1033/jdk160_18<br>targetJDK: /oracle/wls1033/jdk1.6.0_24<br>2) 停止使用当前 FMW_HOME 的所有进程。这指的是</p><ul><li>所有域中的全部 AdminServer 和 Managed_servers，</li><li>在该 FMW_HOME 中运行的所有 nodemanager 进程，以及</li><li>有可能在特定时刻运行 Bea SmartUpgrade 的进程。</li></ul><p>3) 重命名目录：</p><p>a) 转至源 JDK 的父目录：<br>% cd $INSTALL_HOME/<br>b) 您可以通过执行命令 “ls -ld jdk<version>“ 来确定其位置是否为符号链接：<br>% ls -ld jdk160_18</version></p><p>如果所列出内容中jdk160_18 的属性为lrwxrwxrwx (注意第一个字母为 ‘l’)，那它是一个链接。<br>如果所列出内容中jdk160_18 的属性为drwxrwxrwx (注意第一个字母为’d’) 那它是一个目录。<br>c) 将现有 JDK 位置转移到“备份名称”，例如：<br>% mv jdk160_18 jdk160_18.orig<br>这会将 jdk160_18 重命名为 jdk160_18.orig，无论其原来是目录还是链接。</p><p>d) 创建类似如下的符号链接：<br>% ln -s /oracle/wls1033/jdk1.6.0_24 jdk160_18<br>e) 通过运行以下命令，验证此步骤是否成功完成：<br>% $INSTALL_HOME/jdk160_18/bin/java -fullversion<br>如果没有返回已安装的 JSDK 的预期版本字符串，请检查<br>符号链接是否有效，或者向 UNIX 系统管理员寻求其它帮助。<br>4)只有在您使用的是 WLS 10.3.6 且目标 JDK 使用的是已认证的 JAVA 7 版本（版本 1.7.0_x）的情况下，才需要手动复制某些 jar 文件，如下所示：<br>将以下文件从 $INSTALL_HOME/modules 复制到 targetJDK/jre/lib/endorsed 目录<br>javax.annotation_1.0.0.0_1-0.jar<br>javax.xml.bind_2.1.1.jar<br>javax.xml.ws_2.1.1.jar<br>5) 像通常一样重新启动相应进程，它们将使用新的 JDK 版本。</p><h3 id="方法-B"><a href="#方法-B" class="headerlink" title="方法 B)"></a>方法 B)</h3><p>1) 找到涉及的 JDK 版本。<br>a) sourceJDK：假设使用的 JDK 为 $INSTALL_HOME/jdk<version></version></p><p>对于使用 WLS 平台安装程序（针对 32 位 Windows、Linux 和 Solaris）执行的安装，使用的 JDK 将是 $INSTALL_HOME/jdk<version>。<br>对于使用 WLS 通用安装程序（针对 64 位及所有其它平台）执行的安装，JDK 可能位于文件系统中的任何其它位置。</version></p><p>b) targetJDK： 假设新 JDK 位于 /opt/newjdk<br>对于以上示例，将使用以下命令：<br>sourceJDK: /oracle/wls1033/jdk160_18<br>targetJDK: /oracle/wls1033/jdk1.6.0_24<br>2) 停止使用当前 FMW_HOME 的所有进程。这指的是</p><ul><li>所有域中的全部 AdminServer 和 managed_servers，</li><li>在该 FMW_HOME 中运行的所有 nodemanager 进程，以及</li><li>有可能在特定时刻运行 Bea SmartUpgrade 的进程。</li></ul><p>3) 编辑 $INSTALL_HOME/wlserver_10.3/common/bin/commEnv.sh，更改 JAVA_HOME 位置。例如，从：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Reset JAVA_HOME, JAVA_VENDOR and PRODUCTION_MODE unless JAVA_HOME</span><br><span class="line"># and JAVA_VENDOR are pre-defined.</span><br><span class="line">if [ -z &quot;$&#123;JAVA_HOME&#125;&quot; -o -z &quot;$&#123;JAVA_VENDOR&#125;&quot; ]; then</span><br><span class="line"># Set up JAVA HOME</span><br><span class="line">JAVA_HOME=&quot;/oracle/wls1033/jdk160_18&quot;</span><br><span class="line"># Set up JAVA VENDOR, possible values are</span><br><span class="line">#Oracle, HP, IBM, Sun ...</span><br><span class="line">JAVA_VENDOR=Sun</span><br><span class="line"># PRODUCTION_MODE, default to the development mode</span><br><span class="line">PRODUCTION_MODE=&quot;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>更改为：:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Reset JAVA_HOME, JAVA_VENDOR and PRODUCTION_MODE unless JAVA_HOME</span><br><span class="line"># and JAVA_VENDOR are pre-defined.</span><br><span class="line">if [ -z &quot;$&#123;JAVA_HOME&#125;&quot; -o -z &quot;$&#123;JAVA_VENDOR&#125;&quot; ]; then</span><br><span class="line"># Set up JAVA HOME</span><br><span class="line">JAVA_HOME=&quot;/oracle/wls1033/jdk1.6.0_24&quot;</span><br><span class="line"># Set up JAVA VENDOR, possible values are</span><br><span class="line">#Oracle, HP, IBM, Sun ...</span><br><span class="line">JAVA_VENDOR=Sun</span><br><span class="line"># PRODUCTION_MODE, default to the development mode</span><br><span class="line">PRODUCTION_MODE=&quot;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>4) 对于每个域，更改其 “setDomainEnv.sh” 脚本以适应新的 JAVA_HOME。</p><p>对于默认位置和默认脚本，setDomainEnv.sh 将放在以下位置：<br>$INSTALL_HOME/user_projects/domains/<domainname>/bin/setDomainEnv.sh<br>仔细检查在何处、以何种方式更改了 JAVA_HOME 环境变量，因为这可能在不同版本之间发生变化。</domainname></p><p>例如在 WLS 10.3.3 中，这些信息如下所示：<br>BEA_JAVA_HOME=”/oracle/wls1033/jrockit_160_17_R28.0.0-679”<br>export BEA_JAVA_HOME</p><p>SUN_JAVA_HOME=”/oracle/wls1033/jdk160_18”<br>export SUN_JAVA_HOME</p><p>if [ “${JAVA_VENDOR}” = “Oracle” ] ; then<br>JAVA_HOME=”${BEA_JAVA_HOME}”<br>export JAVA_HOME<br>else<br>if [ “${JAVA_VENDOR}” = “Sun” ] ; then<br>JAVA_HOME=”${SUN_JAVA_HOME}”<br>export JAVA_HOME<br>else<br>JAVA_VENDOR=”Sun”<br>export JAVA_VENDOR<br>JAVA_HOME=”/oracle/wls1033/jdk160_18”<br>export JAVA_HOME<br>fi<br>fi<br>因此，必须对 SUN_JAVA_HOME 进行更改，以指定新的位置：<br>SUN_JAVA_HOME=”/oracle/wls1033/jdk1.6.0_24”<br>export SUN_JAVA_HOME<br>5) 对默认的以及任何其它现有的 nodemanager 进程，更改在 nodemanager.properties 中指定的 JDK 位置：</p><p>a) 为 $INSTALL_HOME/wlserver_10.3/common/nodemanager/nodemanager.properties 创建备份</p><p>从：<br>PropertiesVersion=10.3<br>javaHome=/oracle/wls1033/jdk160_18<br>AuthenticationEnabled=true<br>NodeManagerHome=/oracle/wls1033/wlserver_10.3/common/nodemanager<br>JavaHome=/oracle/wls1033/jdk160_18/jre<br>LogLevel=INFO<br>更改为：<br>PropertiesVersion=10.3<br>javaHome=/oracle/wls1033/jdk1.6.0_24<br>AuthenticationEnabled=true<br>NodeManagerHome=/oracle/wls1033/wlserver_10.3/common/nodemanager<br>JavaHome=/oracle/wls1033/jdk1.6.0_24/jre<br>LogLevel=INFO<br>6) 对于在相同 FMW_HOME 中使用的所有次要工具（如 BSU、uninstall.sh 等），均替换为新的 JDK 位置<br>对于 Bea SmartUpgrade 工具 $INSTALL_HOME/utils/bsu/bsu.sh</p><p>更新以下行：</p><p>from<br>JAVA_HOME=”/opt/JDK1.6.14”<br>to<br>JAVA_HOME=”/oracle/wls1033/jdk1.6.0_24”<br>类似地，更改其余三个文件的 JAVA_HOME 值</p><ul><li>$INSTALL_HOME/utils/quickstart/quickstart.sh</li><li>$INSTALL_HOME/utils/uninstall/uninstall.sh<br>7) 只有在您使用的是 WLS 10.3.6 且目标 JDK 使用的是已认证的 JAVA 7 版本（版本 1.7.0_x）的情况下，才需要手动复制某些 jar 文件，如下所示：<br>将以下文件从 $INSTALL_HOME/modules 复制到 targetJDK/jre/lib/endorsed 目录<br>javax.annotation_1.0.0.0_1-0.jar<br>javax.xml.bind_2.1.1.jar<br>javax.xml.ws_2.1.1.jar<br>8) 重新启动所有需要的进程。<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>NOTE:1058804.1 - How To Change The JDK Type (Sun / JRockit) or JDK Version for a Given FMW 11g Domain<br>NOTE:1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g Products</li></ul><p>NOTE:1312755.1 - How Re-Create, Copy, or Re-Use Existing WLS Domains from 32-bit to 64-bit Architecture</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;适用于&quot;&gt;&lt;a href=&quot;#适用于&quot; class=&quot;headerlink&quot; title=&quot;适用于:&quot;&gt;&lt;/a&gt;适用于:&lt;/h2&gt;&lt;p&gt;Oracle WebLogic Server - 版本 8.1 和更高版本&lt;br&gt;本文档所含信息适用于所有平台&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;本文的主要目标是说明将 Oracle WebLogic Server 安装所用的 JDK 升级到更新版本的步骤。&lt;br&gt;必须注意，支持将 Java SE（或分为 JDK/JRE）更新到最新版本的前提是，这样做仍然能得到认证。因此，用户应检查目标 JDK版本是否已经过相应 Weblogic Server 版本的认证，然后自行实施以下说明中的事项。&lt;br&gt;免责声明&lt;br&gt;Oracle WebLogic Server 可以作为独立产品使用，也可以作为许多其它多层产品的核心，例如对于 Oracle Fusion Middleware 11g 安装。本文不会考虑新 JDK 能否得到特定 Fusion Middleware 版本认证这一点，因此，用户应自己负责查看产品认证表，以确认您的安装类型是否支持所需的 JDK 版本。&lt;/p&gt;
&lt;p&gt;1) 对于 Oracle Fusion Middleware 11g，查看以下两个文档中的认证信息：&lt;/p&gt;
&lt;p&gt;Document 1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g Products&lt;br&gt;Document 431578.1 - How to Find Certification Details for Oracle Application Server 10g and Oracle Fusion Middleware.&lt;br&gt;2) 对于个别的 Oracle Weblogic Server 配置，涉及 10.3.0 之前版本的，查看以下位置的认证信息：&lt;br&gt;&lt;a href=&quot;http://download.oracle.com/docs/cd/E13196_01/platform/suppconfigs/config_wls.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://download.oracle.com/docs/cd/E13196_01/platform/suppconfigs/config_wls.html&lt;/a&gt;&lt;br&gt;3) 对于 Weblogic Server 12.1.2 ，请参阅 Document 1616397.1 - After JDK Upgrade How To Change JDK References For WebLogic Server 12c&lt;br&gt;如果安装的是 Oracle Fusion Middleware 11g，请参阅以下文档：&lt;br&gt;Document 1492980.1 - How to Maintain the Java SE Installed or Used with FMW 11g Products&lt;/p&gt;
&lt;p&gt;本文未涉及的两种情况：&lt;/p&gt;
&lt;p&gt;1) 如果您的目标不是升级，而是从 Java SUN JDK 转换到 Oracle JRockit JDK，请参阅： &lt;document 1058804.1=&quot;&quot;&gt; - How To Change Type of JDK (Sun / JRockit) for FMW 11g Domain.&lt;/document&gt;&lt;/p&gt;
&lt;p&gt;2) 如果您的目标是将 32 位 JDK 版本替换为新的 64 位 JDK 版本，本文不适用。请参阅： &lt;document 1312755.1=&quot;&quot;&gt; - How Re-Create, Copy, or Re-Use Existing WLS Domains from 32 bit to 64 bit Architecture&lt;/document&gt;&lt;/p&gt;
&lt;p&gt;本文中的步骤通常适用于从安装过程中默认使用的 JDK 转换到更高的版本，甚至也可以同样地用来降低版本。&lt;/p&gt;
    
    </summary>
    
      <category term="WebLogic" scheme="http://yoursite.com/categories/WebLogic/"/>
    
    
      <category term="weblogic" scheme="http://yoursite.com/tags/weblogic/"/>
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
      <category term="升级" scheme="http://yoursite.com/tags/%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>windows平台npm install hexo-cli -g 卡住问题的解决办法</title>
    <link href="http://yoursite.com/2018/03/29/windows%E5%B9%B3%E5%8F%B0npm-install-hexo-cli-g-%E5%8D%A1%E4%BD%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/29/windows平台npm-install-hexo-cli-g-卡住问题的解决办法/</id>
    <published>2018-03-29T08:35:59.000Z</published>
    <updated>2018-09-02T07:50:52.926Z</updated>
    
    <content type="html"><![CDATA[<p>可以试试切换下你的NPM源。看是否能得到解决。<br>国内的NPM有CNPM和淘宝的NPM源比较稳定。<br>npm源切换和工具可参照站内贴 <a href="https://segmentfault.com/a/1190000000473869" target="_blank" rel="noopener">【nrm工具的使用】</a><br>或者是直接用命令切换:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以试试切换下你的NPM源。看是否能得到解决。&lt;br&gt;国内的NPM有CNPM和淘宝的NPM源比较稳定。&lt;br&gt;npm源切换和工具可参照站内贴 &lt;a href=&quot;https://segmentfault.com/a/1190000000473869&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="其他技术" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2018/03/28/hello-world-1/"/>
    <id>http://yoursite.com/2018/03/28/hello-world-1/</id>
    <published>2018-03-28T05:14:54.000Z</published>
    <updated>2018-09-02T07:52:47.986Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客，从此开启点滴技术生活。</p><p>水滴石穿<br>合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。</p><p><img src="/2018/03/28/hello-world-1/zsy1.JPG" alt="zsy1.JPG"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.rocklei123.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sqlrobe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: rocklei123</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/27 13:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintHeart</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(printHeart(<span class="string">"*"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">printHeart</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">StringBuffer pi = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">pi.append(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (array[i] == <span class="number">0</span>)</span><br><span class="line">pi.append(<span class="string">"   "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (array[i] == <span class="number">4</span>)</span><br><span class="line">pi.append(<span class="string">"  "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (array[i] == <span class="number">5</span>)</span><br><span class="line">pi.append(<span class="string">" 周 "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (array[i] == <span class="number">2</span>)</span><br><span class="line">pi.append(<span class="string">" 书 "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (array[i] == <span class="number">3</span>)</span><br><span class="line">pi.append(<span class="string">" 瑶 "</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pi.append(<span class="string">"  "</span> + input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pi.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/28/hello-world-1/love.jpg" alt="love.jpg"></p><p> 谨以此文献给我的女儿周书瑶！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我的第一篇博客，从此开启点滴技术生活。&lt;/p&gt;
&lt;p&gt;水滴石穿&lt;br&gt;合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/28/hello-world-1/zsy1.JPG&quot; alt=&quot;zsy1.JPG&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
</feed>
